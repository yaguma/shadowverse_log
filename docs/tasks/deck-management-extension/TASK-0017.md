# TASK-0017: DeckStoreæ‹¡å¼µï¼ˆMyDeck CRUDï¼‰

## ã‚¿ã‚¹ã‚¯æ¦‚è¦

- **ã‚¿ã‚¹ã‚¯ID**: TASK-0017
- **ã‚¿ã‚¤ãƒˆãƒ«**: DeckStoreæ‹¡å¼µï¼ˆMyDeck CRUDï¼‰
- **ã‚¿ã‚¤ãƒ—**: TDD
- **æ¨å®šå·¥æ•°**: 2æ™‚é–“
- **ãƒ•ã‚§ãƒ¼ã‚º**: Phase 3 - ä½¿ç”¨ãƒ‡ãƒƒã‚­ç®¡ç†æ©Ÿèƒ½
- **ä¿¡é ¼æ€§**: ğŸ”µï¼ˆarchitecture.md 5.1ã‚ˆã‚Šï¼‰
- **ä¾å­˜ã‚¿ã‚¹ã‚¯**: TASK-0015, TASK-0016
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0018
- **ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: [ ] æœªç€æ‰‹

---

## è¦ä»¶

### æ©Ÿèƒ½è¦ä»¶

- addMyDeck é–¢æ•°è¿½åŠ 
- deleteMyDeck é–¢æ•°è¿½åŠ 
- myDecks é…åˆ—ç®¡ç†
- isLoading, error ã‚¹ãƒ†ãƒ¼ãƒˆç®¡ç†

### é–¢é€£è¨­è¨ˆ

- architecture.md 5.1 DeckStoreè¨­è¨ˆ

---

## å®Ÿè£…è©³ç´°

### 1. DeckStore ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹æ‹¡å¼µ

```typescript
// packages/web/src/store/deckStore.ts

import { create } from 'zustand';
import { MyDeck } from '@shadowverse-log/shared';

interface MyDeckState {
  // State
  myDecks: MyDeck[];
  isLoading: boolean;
  error: string | null;

  // Actions
  fetchMyDecks: () => Promise<void>;
  addMyDeck: (input: CreateMyDeckInput) => Promise<MyDeck>;
  deleteMyDeck: (id: string) => Promise<void>;
  clearError: () => void;
}

interface CreateMyDeckInput {
  deckId: string;
  deckName: string;
  deckCode?: string;
}
```

### 2. Zustand Store å®Ÿè£…

```typescript
// packages/web/src/store/deckStore.ts

import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import { myDeckApi } from '../api/myDeckApi';
import type { MyDeck } from '@shadowverse-log/shared';

interface CreateMyDeckInput {
  deckId: string;
  deckName: string;
  deckCode?: string;
}

interface DeckStore {
  // State
  myDecks: MyDeck[];
  isLoading: boolean;
  error: string | null;

  // Actions
  fetchMyDecks: () => Promise<void>;
  addMyDeck: (input: CreateMyDeckInput) => Promise<MyDeck>;
  deleteMyDeck: (id: string) => Promise<void>;
  clearError: () => void;
}

export const useDeckStore = create<DeckStore>()(
  devtools(
    (set, get) => ({
      // Initial State
      myDecks: [],
      isLoading: false,
      error: null,

      // Fetch all MyDecks
      fetchMyDecks: async () => {
        set({ isLoading: true, error: null });
        try {
          const response = await myDeckApi.getAll();
          if (response.success) {
            set({ myDecks: response.data, isLoading: false });
          } else {
            set({ error: response.error.message, isLoading: false });
          }
        } catch (e) {
          set({
            error: e instanceof Error ? e.message : 'äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ',
            isLoading: false,
          });
        }
      },

      // Add new MyDeck
      addMyDeck: async (input: CreateMyDeckInput) => {
        set({ isLoading: true, error: null });
        try {
          const response = await myDeckApi.create(input);
          if (response.success) {
            set((state) => ({
              myDecks: [...state.myDecks, response.data],
              isLoading: false,
            }));
            return response.data;
          } else {
            set({ error: response.error.message, isLoading: false });
            throw new Error(response.error.message);
          }
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : 'äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
          set({ error: errorMessage, isLoading: false });
          throw new Error(errorMessage);
        }
      },

      // Delete MyDeck
      deleteMyDeck: async (id: string) => {
        set({ isLoading: true, error: null });
        try {
          const response = await myDeckApi.delete(id);
          if (response.success) {
            set((state) => ({
              myDecks: state.myDecks.filter((deck) => deck.id !== id),
              isLoading: false,
            }));
          } else {
            set({ error: response.error.message, isLoading: false });
            throw new Error(response.error.message);
          }
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : 'äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
          set({ error: errorMessage, isLoading: false });
          throw new Error(errorMessage);
        }
      },

      // Clear error
      clearError: () => {
        set({ error: null });
      },
    }),
    { name: 'deck-store' }
  )
);
```

### 3. API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå®Ÿè£…

```typescript
// packages/web/src/api/myDeckApi.ts

import { apiClient } from './client';
import type { MyDeck, ApiResponse } from '@shadowverse-log/shared';

interface CreateMyDeckInput {
  deckId: string;
  deckName: string;
  deckCode?: string;
}

export const myDeckApi = {
  async getAll(): Promise<ApiResponse<MyDeck[]>> {
    return apiClient.get('/api/my-decks');
  },

  async create(input: CreateMyDeckInput): Promise<ApiResponse<MyDeck>> {
    return apiClient.post('/api/my-decks', input);
  },

  async delete(id: string): Promise<ApiResponse<void>> {
    return apiClient.delete(`/api/my-decks/${id}`);
  },
};
```

---

## ãƒ†ã‚¹ãƒˆè¦ä»¶

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä¸€è¦§

| No | ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ | æœŸå¾…çµæœ | å„ªå…ˆåº¦ |
|----|-------------|----------|--------|
| 1 | addMyDeckå¾Œã«myDecksé…åˆ—ã«è¿½åŠ ã•ã‚Œã‚‹ | é…åˆ—ã«æ–°è¦ã‚¢ã‚¤ãƒ†ãƒ  | é«˜ |
| 2 | deleteMyDeckå¾Œã«myDecksé…åˆ—ã‹ã‚‰å‰Šé™¤ã•ã‚Œã‚‹ | é…åˆ—ã‹ã‚‰ã‚¢ã‚¤ãƒ†ãƒ å‰Šé™¤ | é«˜ |
| 3 | fetchMyDecksæˆåŠŸæ™‚ã«myDecksãŒæ›´æ–°ã•ã‚Œã‚‹ | é…åˆ—ãŒæ›´æ–° | é«˜ |
| 4 | ã‚¨ãƒ©ãƒ¼æ™‚ã«errorã‚¹ãƒ†ãƒ¼ãƒˆãŒè¨­å®šã•ã‚Œã‚‹ | error !== null | é«˜ |
| 5 | isLoadingãŒtrueâ†’falseã«å¤‰åŒ–ã™ã‚‹ | ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ç®¡ç† | ä¸­ |
| 6 | clearErrorã§ã‚¨ãƒ©ãƒ¼ãŒã‚¯ãƒªã‚¢ã•ã‚Œã‚‹ | error === null | ä¸­ |

### ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ä¾‹

```typescript
// packages/web/src/store/__tests__/deckStore.test.ts

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { useDeckStore } from '../deckStore';
import { myDeckApi } from '../../api/myDeckApi';

// ãƒ¢ãƒƒã‚¯
vi.mock('../../api/myDeckApi');

describe('useDeckStore', () => {
  beforeEach(() => {
    // Storeã‚’ãƒªã‚»ãƒƒãƒˆ
    useDeckStore.setState({
      myDecks: [],
      isLoading: false,
      error: null,
    });
    vi.clearAllMocks();
  });

  describe('addMyDeck', () => {
    it('è¿½åŠ å¾Œã«myDecksé…åˆ—ã«è¿½åŠ ã•ã‚Œã‚‹ã“ã¨', async () => {
      const newDeck = {
        id: 'new-deck-id',
        deckId: 'deck-001',
        deckName: 'ãƒ†ã‚¹ãƒˆãƒ‡ãƒƒã‚­',
        deckCode: '',
        className: 'ã‚¦ã‚£ãƒƒãƒ',
        isActive: true,
        createdAt: '2025-01-01T00:00:00.000Z',
      };

      vi.mocked(myDeckApi.create).mockResolvedValueOnce({
        success: true,
        data: newDeck,
        meta: { timestamp: new Date().toISOString() },
      });

      const { result } = renderHook(() => useDeckStore());

      await act(async () => {
        await result.current.addMyDeck({
          deckId: 'deck-001',
          deckName: 'ãƒ†ã‚¹ãƒˆãƒ‡ãƒƒã‚­',
        });
      });

      expect(result.current.myDecks).toContainEqual(newDeck);
      expect(result.current.isLoading).toBe(false);
      expect(result.current.error).toBeNull();
    });

    it('ã‚¨ãƒ©ãƒ¼æ™‚ã«errorã‚¹ãƒ†ãƒ¼ãƒˆãŒè¨­å®šã•ã‚Œã‚‹ã“ã¨', async () => {
      vi.mocked(myDeckApi.create).mockResolvedValueOnce({
        success: false,
        error: {
          code: 'VALIDATION_ERROR',
          message: 'ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼',
        },
        meta: { timestamp: new Date().toISOString() },
      });

      const { result } = renderHook(() => useDeckStore());

      await expect(
        act(async () => {
          await result.current.addMyDeck({
            deckId: 'deck-001',
            deckName: '',
          });
        })
      ).rejects.toThrow();

      expect(result.current.error).toBe('ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼');
      expect(result.current.isLoading).toBe(false);
    });
  });

  describe('deleteMyDeck', () => {
    it('å‰Šé™¤å¾Œã«myDecksé…åˆ—ã‹ã‚‰å‰Šé™¤ã•ã‚Œã‚‹ã“ã¨', async () => {
      const existingDeck = {
        id: 'existing-deck-id',
        deckId: 'deck-001',
        deckName: 'ãƒ†ã‚¹ãƒˆãƒ‡ãƒƒã‚­',
        deckCode: '',
        className: 'ã‚¦ã‚£ãƒƒãƒ',
        isActive: true,
        createdAt: '2025-01-01T00:00:00.000Z',
      };

      useDeckStore.setState({ myDecks: [existingDeck] });

      vi.mocked(myDeckApi.delete).mockResolvedValueOnce({
        success: true,
        meta: { timestamp: new Date().toISOString() },
      });

      const { result } = renderHook(() => useDeckStore());

      await act(async () => {
        await result.current.deleteMyDeck('existing-deck-id');
      });

      expect(result.current.myDecks).not.toContainEqual(existingDeck);
      expect(result.current.myDecks).toHaveLength(0);
    });

    it('å‰Šé™¤åˆ¶ç´„ã‚¨ãƒ©ãƒ¼æ™‚ã«errorã‚¹ãƒ†ãƒ¼ãƒˆãŒè¨­å®šã•ã‚Œã‚‹ã“ã¨', async () => {
      const existingDeck = {
        id: 'existing-deck-id',
        deckId: 'deck-001',
        deckName: 'ãƒ†ã‚¹ãƒˆãƒ‡ãƒƒã‚­',
        deckCode: '',
        className: 'ã‚¦ã‚£ãƒƒãƒ',
        isActive: true,
        createdAt: '2025-01-01T00:00:00.000Z',
      };

      useDeckStore.setState({ myDecks: [existingDeck] });

      vi.mocked(myDeckApi.delete).mockResolvedValueOnce({
        success: false,
        error: {
          code: 'DELETE_CONSTRAINT_ERROR',
          message: 'å¯¾æˆ¦å±¥æ­´ã‹ã‚‰å‚ç…§ã•ã‚Œã¦ã„ã‚‹ãŸã‚å‰Šé™¤ã§ãã¾ã›ã‚“',
        },
        meta: { timestamp: new Date().toISOString() },
      });

      const { result } = renderHook(() => useDeckStore());

      await expect(
        act(async () => {
          await result.current.deleteMyDeck('existing-deck-id');
        })
      ).rejects.toThrow();

      expect(result.current.error).toBe('å¯¾æˆ¦å±¥æ­´ã‹ã‚‰å‚ç…§ã•ã‚Œã¦ã„ã‚‹ãŸã‚å‰Šé™¤ã§ãã¾ã›ã‚“');
      // å‰Šé™¤å¤±æ•—æ™‚ã¯myDecksé…åˆ—ã¯å¤‰æ›´ã•ã‚Œãªã„
      expect(result.current.myDecks).toContainEqual(existingDeck);
    });
  });

  describe('clearError', () => {
    it('ã‚¨ãƒ©ãƒ¼ãŒã‚¯ãƒªã‚¢ã•ã‚Œã‚‹ã“ã¨', () => {
      useDeckStore.setState({ error: 'ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼' });

      const { result } = renderHook(() => useDeckStore());

      act(() => {
        result.current.clearError();
      });

      expect(result.current.error).toBeNull();
    });
  });
});
```

---

## å®Œäº†æ¡ä»¶

- [ ] addMyDecké–¢æ•°ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] deleteMyDecké–¢æ•°ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] myDecksé…åˆ—ç®¡ç†ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] isLoading, errorã‚¹ãƒ†ãƒ¼ãƒˆç®¡ç†ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ãŒæˆåŠŸã™ã‚‹
- [ ] ã‚³ãƒ¼ãƒ‰ã‚«ãƒãƒ¬ãƒƒã‚¸80%ä»¥ä¸Š

---

## å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰

```bash
# TDDãƒ•ãƒ­ãƒ¼
/tsumiki:tdd-red           # ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
/tsumiki:tdd-green         # æœ€å°å®Ÿè£…ï¼ˆæˆåŠŸï¼‰
/tsumiki:tdd-refactor      # ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
/tsumiki:tdd-verify-complete  # å“è³ªç¢ºèª
```

---

## æ¤œè¨¼æ‰‹é †

1. ãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã™ã‚‹ã“ã¨ã‚’ç¢ºèªï¼ˆRedï¼‰
2. æœ€å°é™ã®å®Ÿè£…ã§ãƒ†ã‚¹ãƒˆãŒæˆåŠŸã™ã‚‹ã“ã¨ã‚’ç¢ºèªï¼ˆGreenï¼‰
3. ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°å¾Œã‚‚ãƒ†ã‚¹ãƒˆãŒæˆåŠŸã™ã‚‹ã“ã¨ã‚’ç¢ºèª
4. `pnpm test` ã§å…¨ãƒ†ã‚¹ãƒˆãŒæˆåŠŸã™ã‚‹ã“ã¨ã‚’ç¢ºèª
5. `pnpm lint` ã§ã‚¨ãƒ©ãƒ¼ãŒãªã„ã“ã¨ã‚’ç¢ºèª
6. `pnpm type-check` ã§å‹ã‚¨ãƒ©ãƒ¼ãŒãªã„ã“ã¨ã‚’ç¢ºèª

---

## å‚è€ƒè³‡æ–™

- [architecture.md - 5.1 DeckStore](../../../docs/design/deck-management-extension/architecture.md)
- [Zustand Documentation](https://zustand-demo.pmnd.rs/)
