# TASK-0032: ç›¸æ‰‹ãƒ‡ãƒƒã‚­é¸æŠè‚¢ã‚½ãƒ¼ãƒˆæ©Ÿèƒ½å®Ÿè£…

## ã‚¿ã‚¹ã‚¯æƒ…å ±

- **ã‚¿ã‚¹ã‚¯ID**: TASK-0032
- **ã‚¿ã‚¤ãƒ—**: TDD
- **æ¨å®šå·¥æ•°**: 2æ™‚é–“
- **ãƒ•ã‚§ãƒ¼ã‚º**: Phase 6 - å¯¾æˆ¦å±¥æ­´UIæ”¹å–„
- **ä¿¡é ¼æ€§**: ğŸ”µï¼ˆREQ-EXT-302ã‚ˆã‚Šã€dataflow.md 4.1ã‚ˆã‚Šï¼‰
- **ä¾å­˜ã‚¿ã‚¹ã‚¯**: TASK-0005, TASK-0031
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0033
- **ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: [ ] æœªå®Œäº†

---

## æ¦‚è¦

ç›¸æ‰‹ãƒ‡ãƒƒã‚­ã®é¸æŠè‚¢ã‚’æœ€è¿‘ä½¿ç”¨é †ã§ã‚½ãƒ¼ãƒˆã—ã¦è¡¨ç¤ºã™ã‚‹ã€‚å¯¾æˆ¦å±¥æ­´ã§æœ€è¿‘å¯¾æˆ¦ã—ãŸç›¸æ‰‹ãƒ‡ãƒƒã‚­ã‚’ä¸Šä½ã«è¡¨ç¤ºã™ã‚‹ã“ã¨ã§ã€å…¥åŠ›ã®åŠ¹ç‡ã‚’å‘ä¸Šã•ã›ã‚‹ã€‚

---

## å®Ÿè£…å†…å®¹

### 1. APIæ‹¡å¼µ: ãƒ‡ãƒƒã‚­ãƒã‚¹ã‚¿ãƒ¼å–å¾—ã«ä½¿ç”¨å›æ•°æƒ…å ±ã‚’è¿½åŠ 

`packages/api/src/functions/getDeckMasters.ts` ã‚’æ‹¡å¼µ:

```typescript
import { Hono } from 'hono';
import { createBlobStorageClient } from '../storage/blobStorageClient';

const app = new Hono();

/**
 * GET /api/deck-masters
 * ãƒ‡ãƒƒã‚­ãƒã‚¹ã‚¿ãƒ¼ä¸€è¦§ã‚’å–å¾—
 * @query includeUsage - trueã®å ´åˆã€ä½¿ç”¨å›æ•°ã¨æœ€çµ‚ä½¿ç”¨æ—¥ã‚’å«ã‚ã‚‹
 */
app.get('/api/deck-masters', async (c) => {
  try {
    const includeUsage = c.req.query('includeUsage') === 'true';
    const blobClient = createBlobStorageClient();

    const deckMasters = await blobClient.getDeckMasters();

    if (!includeUsage) {
      // å¾“æ¥é€šã‚ŠsortOrderé †ã§è¿”ã™
      const sorted = [...deckMasters].sort((a, b) => a.sortOrder - b.sortOrder);
      return c.json({
        success: true,
        data: { deckMasters: sorted },
        meta: {
          timestamp: new Date().toISOString(),
          requestId: crypto.randomUUID(),
        },
      });
    }

    // å¯¾æˆ¦å±¥æ­´ã‹ã‚‰ä½¿ç”¨å›æ•°ã¨æœ€çµ‚ä½¿ç”¨æ—¥ã‚’è¨ˆç®—
    const battleLogs = await blobClient.getBattleLogs();

    const usageMap = new Map<string, { count: number; lastUsedDate: string }>();

    for (const log of battleLogs) {
      const deckId = log.opponentDeckId;
      const existing = usageMap.get(deckId);

      if (!existing) {
        usageMap.set(deckId, { count: 1, lastUsedDate: log.date });
      } else {
        existing.count++;
        // ã‚ˆã‚Šæ–°ã—ã„æ—¥ä»˜ã§æ›´æ–°
        if (log.date > existing.lastUsedDate) {
          existing.lastUsedDate = log.date;
        }
      }
    }

    // ä½¿ç”¨å›æ•°æƒ…å ±ã‚’ä»˜åŠ 
    const deckMastersWithUsage = deckMasters.map((deck) => {
      const usage = usageMap.get(deck.id);
      return {
        ...deck,
        usageCount: usage?.count ?? 0,
        lastUsedDate: usage?.lastUsedDate ?? null,
      };
    });

    // æœ€çµ‚ä½¿ç”¨æ—¥é™é †ï¼ˆæœ€è¿‘ä½¿ç”¨ãŒå…ˆé ­ï¼‰ã€æœªä½¿ç”¨ã¯sortOrderé †
    const sorted = [...deckMastersWithUsage].sort((a, b) => {
      // ä½¿ç”¨å±¥æ­´ãŒã‚ã‚‹ã‚‚ã®ã‚’å„ªå…ˆ
      if (a.lastUsedDate && !b.lastUsedDate) return -1;
      if (!a.lastUsedDate && b.lastUsedDate) return 1;

      // ä¸¡æ–¹ä½¿ç”¨å±¥æ­´ãŒã‚ã‚‹å ´åˆã¯æœ€çµ‚ä½¿ç”¨æ—¥ã§æ¯”è¼ƒ
      if (a.lastUsedDate && b.lastUsedDate) {
        if (a.lastUsedDate > b.lastUsedDate) return -1;
        if (a.lastUsedDate < b.lastUsedDate) return 1;
      }

      // ä½¿ç”¨å±¥æ­´ãŒãªã„å ´åˆã¯sortOrderé †
      return a.sortOrder - b.sortOrder;
    });

    return c.json({
      success: true,
      data: { deckMasters: sorted },
      meta: {
        timestamp: new Date().toISOString(),
        requestId: crypto.randomUUID(),
      },
    });
  } catch (error) {
    console.error('Failed to get deck masters:', error);
    return c.json(
      {
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'ãƒ‡ãƒƒã‚­ãƒã‚¹ã‚¿ãƒ¼ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ',
        },
        meta: {
          timestamp: new Date().toISOString(),
          requestId: crypto.randomUUID(),
        },
      },
      500
    );
  }
});

export default app;
```

### 2. å‹å®šç¾©æ‹¡å¼µ

`packages/shared/src/types/index.ts`:

```typescript
/**
 * ä½¿ç”¨å›æ•°æƒ…å ±ä»˜ããƒ‡ãƒƒã‚­ãƒã‚¹ã‚¿ãƒ¼
 */
export interface DeckMasterWithUsage extends DeckMaster {
  usageCount: number;
  lastUsedDate: string | null;
}
```

### 3. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰APIé–¢æ•°æ›´æ–°

`packages/frontend/src/api/deckMasterApi.ts`:

```typescript
import { apiClient } from './apiClient';
import type { ApiResponse, DeckMaster, DeckMasterWithUsage } from '@shadowverse-log/shared';

export const deckMasterApi = {
  /**
   * ãƒ‡ãƒƒã‚­ãƒã‚¹ã‚¿ãƒ¼ä¸€è¦§ã‚’å–å¾—
   * @param includeUsage - trueã®å ´åˆã€ä½¿ç”¨å›æ•°æƒ…å ±ã‚’å«ã‚ã‚‹
   */
  getDeckMasters: async (
    includeUsage: boolean = false
  ): Promise<ApiResponse<{ deckMasters: DeckMaster[] | DeckMasterWithUsage[] }>> => {
    const params = includeUsage ? '?includeUsage=true' : '';
    const response = await apiClient.get<ApiResponse<{ deckMasters: DeckMaster[] }>>(
      `/api/deck-masters${params}`
    );
    return response.data;
  },
};
```

### 4. BattleLogDialogã§ã®ä½¿ç”¨

`packages/frontend/src/components/battle-log/BattleLogDialog.tsx`:

```typescript
import { useEffect, useState } from 'react';
import { deckMasterApi } from '@/api/deckMasterApi';
import type { DeckMasterWithUsage } from '@shadowverse-log/shared';

// ...

export const BattleLogDialog = ({ isOpen, onClose, onSaved, defaultSeason }: BattleLogDialogProps) => {
  const [opponentDecks, setOpponentDecks] = useState<DeckMasterWithUsage[]>([]);

  useEffect(() => {
    const fetchOpponentDecks = async () => {
      // includeUsage=true ã§æœ€è¿‘ä½¿ç”¨é †ã«ã‚½ãƒ¼ãƒˆæ¸ˆã¿ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
      const response = await deckMasterApi.getDeckMasters(true);
      if (response.success && response.data) {
        setOpponentDecks(response.data.deckMasters as DeckMasterWithUsage[]);
      }
    };

    if (isOpen) {
      fetchOpponentDecks();
    }
  }, [isOpen]);

  // ...

  return (
    // ...
    <select
      id="opponentDeckId"
      name="opponentDeckId"
      value={formData.opponentDeckId}
      onChange={handleChange}
      required
      className="w-full px-3 py-2 border border-gray-300 rounded-md"
    >
      <option value="">é¸æŠã—ã¦ãã ã•ã„</option>
      {opponentDecks.map((deck) => (
        <option key={deck.id} value={deck.id}>
          {deck.deckName}
          {deck.usageCount > 0 && ` (${deck.usageCount}å›)`}
        </option>
      ))}
    </select>
    // ...
  );
};
```

---

## ãƒ†ã‚¹ãƒˆè¦ä»¶

### APIå˜ä½“ãƒ†ã‚¹ãƒˆï¼ˆVitestï¼‰

`packages/api/src/functions/__tests__/getDeckMasters.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { Hono } from 'hono';
import getDeckMastersRoute from '../getDeckMasters';

vi.mock('../../storage/blobStorageClient', () => ({
  createBlobStorageClient: vi.fn(),
}));

import { createBlobStorageClient } from '../../storage/blobStorageClient';

describe('GET /api/deck-masters', () => {
  let app: Hono;

  const mockDeckMasters = [
    { id: 'd1', deckName: 'ãƒ‡ãƒƒã‚­A', sortOrder: 3 },
    { id: 'd2', deckName: 'ãƒ‡ãƒƒã‚­B', sortOrder: 1 },
    { id: 'd3', deckName: 'ãƒ‡ãƒƒã‚­C', sortOrder: 2 },
  ];

  const mockBattleLogs = [
    { id: '1', opponentDeckId: 'd1', date: '2025/01/10' },
    { id: '2', opponentDeckId: 'd3', date: '2025/01/15' },
    { id: '3', opponentDeckId: 'd1', date: '2025/01/12' },
  ];

  beforeEach(() => {
    app = new Hono();
    app.route('/', getDeckMastersRoute);
    vi.clearAllMocks();

    vi.mocked(createBlobStorageClient).mockReturnValue({
      getDeckMasters: vi.fn().mockResolvedValue(mockDeckMasters),
      getBattleLogs: vi.fn().mockResolvedValue(mockBattleLogs),
    } as any);
  });

  describe('includeUsage=falseï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰', () => {
    it('sortOrderé †ã§è¿”ã•ã‚Œã‚‹', async () => {
      const res = await app.request('/api/deck-masters');
      const json = await res.json();

      expect(res.status).toBe(200);
      expect(json.data.deckMasters[0].id).toBe('d2'); // sortOrder: 1
      expect(json.data.deckMasters[1].id).toBe('d3'); // sortOrder: 2
      expect(json.data.deckMasters[2].id).toBe('d1'); // sortOrder: 3
    });
  });

  describe('includeUsage=true', () => {
    it('æœ€è¿‘ä½¿ç”¨é †ã§ã‚½ãƒ¼ãƒˆã•ã‚Œã‚‹', async () => {
      const res = await app.request('/api/deck-masters?includeUsage=true');
      const json = await res.json();

      expect(res.status).toBe(200);
      // d3ãŒæœ€ã‚‚æœ€è¿‘ä½¿ç”¨ï¼ˆ2025/01/15ï¼‰
      expect(json.data.deckMasters[0].id).toBe('d3');
      // d1ãŒ2ç•ªç›®ï¼ˆ2025/01/12ï¼‰
      expect(json.data.deckMasters[1].id).toBe('d1');
      // d2ã¯ä½¿ç”¨å±¥æ­´ãªã—
      expect(json.data.deckMasters[2].id).toBe('d2');
    });

    it('ä½¿ç”¨å›æ•°ãŒå«ã¾ã‚Œã‚‹', async () => {
      const res = await app.request('/api/deck-masters?includeUsage=true');
      const json = await res.json();

      const d1 = json.data.deckMasters.find((d: any) => d.id === 'd1');
      expect(d1.usageCount).toBe(2); // 2å›ä½¿ç”¨

      const d3 = json.data.deckMasters.find((d: any) => d.id === 'd3');
      expect(d3.usageCount).toBe(1); // 1å›ä½¿ç”¨

      const d2 = json.data.deckMasters.find((d: any) => d.id === 'd2');
      expect(d2.usageCount).toBe(0); // æœªä½¿ç”¨
    });

    it('æœ€çµ‚ä½¿ç”¨æ—¥ãŒå«ã¾ã‚Œã‚‹', async () => {
      const res = await app.request('/api/deck-masters?includeUsage=true');
      const json = await res.json();

      const d1 = json.data.deckMasters.find((d: any) => d.id === 'd1');
      expect(d1.lastUsedDate).toBe('2025/01/12'); // æœ€æ–°ã®ä½¿ç”¨æ—¥

      const d2 = json.data.deckMasters.find((d: any) => d.id === 'd2');
      expect(d2.lastUsedDate).toBeNull(); // æœªä½¿ç”¨
    });
  });

  describe('å¯¾æˆ¦å±¥æ­´0ä»¶', () => {
    it('sortOrderé †ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯', async () => {
      vi.mocked(createBlobStorageClient).mockReturnValue({
        getDeckMasters: vi.fn().mockResolvedValue(mockDeckMasters),
        getBattleLogs: vi.fn().mockResolvedValue([]),
      } as any);

      const res = await app.request('/api/deck-masters?includeUsage=true');
      const json = await res.json();

      expect(json.data.deckMasters[0].id).toBe('d2'); // sortOrder: 1
    });
  });
});
```

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆ

`packages/frontend/src/components/battle-log/__tests__/BattleLogDialog.opponentSort.test.tsx`:

```typescript
import { render, screen, waitFor } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { BattleLogDialog } from '../BattleLogDialog';
import { deckMasterApi } from '@/api/deckMasterApi';

vi.mock('@/api/deckMasterApi', () => ({
  deckMasterApi: {
    getDeckMasters: vi.fn(),
  },
}));

describe('BattleLogDialog ç›¸æ‰‹ãƒ‡ãƒƒã‚­ã‚½ãƒ¼ãƒˆ', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('æœ€è¿‘ä½¿ç”¨ã—ãŸãƒ‡ãƒƒã‚­ãŒä¸Šä½ã«è¡¨ç¤ºã•ã‚Œã‚‹', async () => {
    vi.mocked(deckMasterApi.getDeckMasters).mockResolvedValue({
      success: true,
      data: {
        deckMasters: [
          { id: 'd3', deckName: 'æœ€è¿‘ä½¿ç”¨ãƒ‡ãƒƒã‚­', usageCount: 5, lastUsedDate: '2025/01/20', sortOrder: 3 },
          { id: 'd1', deckName: '2ç•ªç›®ãƒ‡ãƒƒã‚­', usageCount: 3, lastUsedDate: '2025/01/15', sortOrder: 1 },
          { id: 'd2', deckName: 'æœªä½¿ç”¨ãƒ‡ãƒƒã‚­', usageCount: 0, lastUsedDate: null, sortOrder: 2 },
        ],
      },
      meta: { timestamp: '', requestId: '' },
    });

    render(<BattleLogDialog isOpen={true} onClose={vi.fn()} />);

    await waitFor(() => {
      const options = screen.getAllByRole('option');
      // æœ€åˆã¯ã€Œé¸æŠã—ã¦ãã ã•ã„ã€
      expect(options[1]).toHaveTextContent('æœ€è¿‘ä½¿ç”¨ãƒ‡ãƒƒã‚­');
      expect(options[2]).toHaveTextContent('2ç•ªç›®ãƒ‡ãƒƒã‚­');
      expect(options[3]).toHaveTextContent('æœªä½¿ç”¨ãƒ‡ãƒƒã‚­');
    });
  });

  it('ä½¿ç”¨å›æ•°ãŒè¡¨ç¤ºã•ã‚Œã‚‹', async () => {
    vi.mocked(deckMasterApi.getDeckMasters).mockResolvedValue({
      success: true,
      data: {
        deckMasters: [
          { id: 'd1', deckName: 'ãƒ†ã‚¹ãƒˆãƒ‡ãƒƒã‚­', usageCount: 10, lastUsedDate: '2025/01/20', sortOrder: 1 },
        ],
      },
      meta: { timestamp: '', requestId: '' },
    });

    render(<BattleLogDialog isOpen={true} onClose={vi.fn()} />);

    await waitFor(() => {
      expect(screen.getByText(/ãƒ†ã‚¹ãƒˆãƒ‡ãƒƒã‚­ \(10å›\)/)).toBeInTheDocument();
    });
  });
});
```

---

## å®Œäº†æ¡ä»¶

- [ ] `GET /api/deck-masters?includeUsage=true` ã§ä½¿ç”¨å›æ•°æƒ…å ±ãŒå–å¾—ã§ãã‚‹
- [ ] ç›¸æ‰‹ãƒ‡ãƒƒã‚­é¸æŠè‚¢ãŒæœ€è¿‘ä½¿ç”¨é †ã§ã‚½ãƒ¼ãƒˆã•ã‚Œã‚‹
- [ ] å¯¾æˆ¦å±¥æ­´0ä»¶æ™‚ã¯sortOrderé †ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã™ã‚‹
- [ ] ä½¿ç”¨å›æ•°ãŒé¸æŠè‚¢ã«è¡¨ç¤ºã•ã‚Œã‚‹ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
- [ ] å˜ä½“ãƒ†ã‚¹ãƒˆãŒã™ã¹ã¦æˆåŠŸã™ã‚‹

---

## å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰

```bash
# TDDãƒ•ãƒ­ãƒ¼
/tsumiki:tdd-red           # ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
/tsumiki:tdd-green         # æœ€å°å®Ÿè£…ï¼ˆæˆåŠŸï¼‰
/tsumiki:tdd-refactor      # ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
/tsumiki:tdd-verify-complete  # å“è³ªç¢ºèª
```

---

## æ¤œè¨¼æ‰‹é †

1. APIãƒ†ã‚¹ãƒˆ:
   ```bash
   curl "http://localhost:8787/api/deck-masters?includeUsage=true"
   ```
2. `pnpm test` ã§ãƒ†ã‚¹ãƒˆãŒæˆåŠŸã™ã‚‹ã‹ç¢ºèª
3. æ‰‹å‹•ç¢ºèª: å¯¾æˆ¦å±¥æ­´ç™»éŒ²ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§ç›¸æ‰‹ãƒ‡ãƒƒã‚­ãŒæœ€è¿‘ä½¿ç”¨é †ã§è¡¨ç¤ºã•ã‚Œã‚‹ã‹

---

## é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [è¦ä»¶å®šç¾© REQ-EXT-302](../../spec/deck-management-extension-requirements.md)
- [ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼è¨­è¨ˆ dataflow.md 4.1](../../design/deck-management-extension/dataflow.md)
- [TASK-0005: å…±æœ‰å‹å®šç¾©å®Ÿè£…](./TASK-0005.md)
