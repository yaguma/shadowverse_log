# TASK-0026: Statistics API - ã‚·ãƒ¼ã‚ºãƒ³åˆ¥çµ±è¨ˆå–å¾—å®Ÿè£…

## ã‚¿ã‚¹ã‚¯æƒ…å ±

- **ã‚¿ã‚¹ã‚¯ID**: TASK-0026
- **ã‚¿ã‚¤ãƒ—**: TDD
- **æ¨å®šå·¥æ•°**: 2æ™‚é–“
- **ãƒ•ã‚§ãƒ¼ã‚º**: Phase 5 - çµ±è¨ˆç”»é¢æ©Ÿèƒ½æ‹¡å¼µ
- **ä¿¡é ¼æ€§**: ğŸ”µï¼ˆapi-endpoints.md 4.2ã‚ˆã‚Šï¼‰
- **ä¾å­˜ã‚¿ã‚¹ã‚¯**: TASK-0025
- **å¾Œç¶šã‚¿ã‚¹ã‚¯**: TASK-0027
- **ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: [ ] æœªå®Œäº†

---

## æ¦‚è¦

ã‚·ãƒ¼ã‚ºãƒ³åˆ¥ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾—ã™ã‚‹APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å®Ÿè£…ã™ã‚‹ã€‚ã‚·ãƒ¼ã‚ºãƒ³ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒ‡å®šå¯èƒ½ã¨ã—ã€æŒ‡å®šãªã—ã®å ´åˆã¯æœ€æ–°ã‚·ãƒ¼ã‚ºãƒ³ã®çµ±è¨ˆã‚’è¿”ã™ã€‚

---

## å®Ÿè£…å†…å®¹

### 1. APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆæ‹¡å¼µ

`packages/api/src/functions/getStatistics.ts` ã‚’æ‹¡å¼µ:

```typescript
import { Hono } from 'hono';
import { createBlobStorageClient } from '../storage/blobStorageClient';
import { BattleLog, DeckMaster, MyDeck } from '@shadowverse-log/shared';

const app = new Hono();

/**
 * GET /api/statistics
 * çµ±è¨ˆæƒ…å ±ã‚’å–å¾—
 * @query season - ã‚·ãƒ¼ã‚ºãƒ³ç•ªå·ï¼ˆçœç•¥æ™‚ã¯æœ€æ–°ã‚·ãƒ¼ã‚ºãƒ³ï¼‰
 */
app.get('/api/statistics', async (c) => {
  try {
    const seasonParam = c.req.query('season');
    const blobClient = createBlobStorageClient();

    const [battleLogs, deckMasters, myDecks] = await Promise.all([
      blobClient.getBattleLogs(),
      blobClient.getDeckMasters(),
      blobClient.getMyDecks(),
    ]);

    // ã‚·ãƒ¼ã‚ºãƒ³ã®æ±ºå®š
    let targetSeason: number;
    if (seasonParam) {
      targetSeason = parseInt(seasonParam, 10);
      if (isNaN(targetSeason)) {
        return c.json(
          {
            success: false,
            error: {
              code: 'INVALID_PARAMETER',
              message: 'season ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯æ•°å€¤ã§æŒ‡å®šã—ã¦ãã ã•ã„',
            },
            meta: {
              timestamp: new Date().toISOString(),
              requestId: crypto.randomUUID(),
            },
          },
          400
        );
      }
    } else {
      // æœ€æ–°ã‚·ãƒ¼ã‚ºãƒ³ã‚’å–å¾—
      const seasons = [...new Set(battleLogs.map((log) => log.season))];
      if (seasons.length === 0) {
        return c.json({
          success: true,
          data: createEmptyStatistics(0),
          meta: {
            timestamp: new Date().toISOString(),
            requestId: crypto.randomUUID(),
          },
        });
      }
      targetSeason = Math.max(...seasons);
    }

    // ã‚·ãƒ¼ã‚ºãƒ³ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    const filteredLogs = battleLogs.filter((log) => log.season === targetSeason);

    // çµ±è¨ˆè¨ˆç®—
    const statistics = calculateStatistics(filteredLogs, deckMasters, myDecks, targetSeason);

    return c.json({
      success: true,
      data: statistics,
      meta: {
        timestamp: new Date().toISOString(),
        requestId: crypto.randomUUID(),
      },
    });
  } catch (error) {
    console.error('Failed to get statistics:', error);
    return c.json(
      {
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'çµ±è¨ˆæƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ',
        },
        meta: {
          timestamp: new Date().toISOString(),
          requestId: crypto.randomUUID(),
        },
      },
      500
    );
  }
});

/**
 * çµ±è¨ˆã‚’è¨ˆç®—
 */
function calculateStatistics(
  battleLogs: BattleLog[],
  deckMasters: DeckMaster[],
  myDecks: MyDeck[],
  season: number
) {
  const totalGames = battleLogs.length;
  const wins = battleLogs.filter((log) => log.result === 'å‹ã¡').length;
  const losses = totalGames - wins;

  // è‡ªåˆ†ãƒ‡ãƒƒã‚­åˆ¥çµ±è¨ˆ
  const byMyDeck = calculateDeckStatistics(battleLogs, myDecks, 'myDeckId');

  // ç›¸æ‰‹ãƒ‡ãƒƒã‚­åˆ¥çµ±è¨ˆ
  const byOpponentDeck = calculateOpponentDeckStatistics(battleLogs, deckMasters);

  // ã‚¿ãƒ¼ãƒ³åˆ¥çµ±è¨ˆ
  const byTurn = calculateTurnStatistics(battleLogs);

  return {
    season,
    overall: {
      totalGames,
      wins,
      losses,
      winRate: totalGames > 0 ? Math.round((wins / totalGames) * 100 * 10) / 10 : 0,
    },
    byMyDeck,
    byOpponentDeck,
    byTurn,
  };
}

/**
 * ç©ºã®çµ±è¨ˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
 */
function createEmptyStatistics(season: number) {
  return {
    season,
    overall: {
      totalGames: 0,
      wins: 0,
      losses: 0,
      winRate: 0,
    },
    byMyDeck: [],
    byOpponentDeck: [],
    byTurn: {
      å…ˆæ”»: { totalGames: 0, wins: 0, losses: 0, winRate: 0 },
      å¾Œæ”»: { totalGames: 0, wins: 0, losses: 0, winRate: 0 },
    },
  };
}

// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã¯çœç•¥ï¼ˆæ—¢å­˜ã®statistics.tsã‹ã‚‰æµç”¨ï¼‰

export default app;
```

### 2. çµ±è¨ˆè¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼‰

`packages/api/src/utils/statisticsCalculator.ts`:

```typescript
import { BattleLog, DeckMaster, MyDeck } from '@shadowverse-log/shared';

/**
 * ãƒ‡ãƒƒã‚­åˆ¥çµ±è¨ˆã‚’è¨ˆç®—
 */
export function calculateDeckStatistics(
  battleLogs: BattleLog[],
  decks: MyDeck[] | DeckMaster[],
  deckIdField: 'myDeckId' | 'opponentDeckId'
): Array<{
  deckId: string;
  deckName: string;
  totalGames: number;
  wins: number;
  losses: number;
  winRate: number;
}> {
  const deckMap = new Map<string, { wins: number; losses: number }>();

  for (const log of battleLogs) {
    const deckId = log[deckIdField];
    if (!deckMap.has(deckId)) {
      deckMap.set(deckId, { wins: 0, losses: 0 });
    }
    const stats = deckMap.get(deckId)!;
    if (log.result === 'å‹ã¡') {
      stats.wins++;
    } else {
      stats.losses++;
    }
  }

  return Array.from(deckMap.entries()).map(([deckId, stats]) => {
    const deck = decks.find((d) => d.id === deckId);
    const totalGames = stats.wins + stats.losses;
    return {
      deckId,
      deckName: deck?.deckName ?? 'ä¸æ˜ãªãƒ‡ãƒƒã‚­',
      totalGames,
      wins: stats.wins,
      losses: stats.losses,
      winRate: totalGames > 0 ? Math.round((stats.wins / totalGames) * 100 * 10) / 10 : 0,
    };
  });
}

/**
 * ã‚¿ãƒ¼ãƒ³åˆ¥çµ±è¨ˆã‚’è¨ˆç®—
 */
export function calculateTurnStatistics(battleLogs: BattleLog[]) {
  const stats = {
    å…ˆæ”»: { totalGames: 0, wins: 0, losses: 0, winRate: 0 },
    å¾Œæ”»: { totalGames: 0, wins: 0, losses: 0, winRate: 0 },
  };

  for (const log of battleLogs) {
    const turn = log.turn;
    stats[turn].totalGames++;
    if (log.result === 'å‹ã¡') {
      stats[turn].wins++;
    } else {
      stats[turn].losses++;
    }
  }

  // å‹ç‡è¨ˆç®—
  for (const turn of ['å…ˆæ”»', 'å¾Œæ”»'] as const) {
    const { totalGames, wins } = stats[turn];
    stats[turn].winRate = totalGames > 0 ? Math.round((wins / totalGames) * 100 * 10) / 10 : 0;
  }

  return stats;
}
```

---

## ãƒ†ã‚¹ãƒˆè¦ä»¶

### å˜ä½“ãƒ†ã‚¹ãƒˆï¼ˆVitestï¼‰

`packages/api/src/functions/__tests__/getStatistics.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { Hono } from 'hono';
import getStatisticsRoute from '../getStatistics';

vi.mock('../../storage/blobStorageClient', () => ({
  createBlobStorageClient: vi.fn(),
}));

import { createBlobStorageClient } from '../../storage/blobStorageClient';

describe('GET /api/statistics', () => {
  let app: Hono;

  const mockBattleLogs = [
    { id: '1', season: 3, myDeckId: 'd1', opponentDeckId: 'o1', turn: 'å…ˆæ”»', result: 'å‹ã¡' },
    { id: '2', season: 3, myDeckId: 'd1', opponentDeckId: 'o2', turn: 'å¾Œæ”»', result: 'è² ã‘' },
    { id: '3', season: 2, myDeckId: 'd2', opponentDeckId: 'o1', turn: 'å…ˆæ”»', result: 'å‹ã¡' },
  ];

  const mockDeckMasters = [
    { id: 'o1', deckName: 'ç›¸æ‰‹ãƒ‡ãƒƒã‚­1' },
    { id: 'o2', deckName: 'ç›¸æ‰‹ãƒ‡ãƒƒã‚­2' },
  ];

  const mockMyDecks = [
    { id: 'd1', deckName: 'ãƒã‚¤ãƒ‡ãƒƒã‚­1' },
    { id: 'd2', deckName: 'ãƒã‚¤ãƒ‡ãƒƒã‚­2' },
  ];

  beforeEach(() => {
    app = new Hono();
    app.route('/', getStatisticsRoute);
    vi.clearAllMocks();

    vi.mocked(createBlobStorageClient).mockReturnValue({
      getBattleLogs: vi.fn().mockResolvedValue(mockBattleLogs),
      getDeckMasters: vi.fn().mockResolvedValue(mockDeckMasters),
      getMyDecks: vi.fn().mockResolvedValue(mockMyDecks),
    } as any);
  });

  describe('ã‚·ãƒ¼ã‚ºãƒ³æŒ‡å®šãªã—', () => {
    it('æœ€æ–°ã‚·ãƒ¼ã‚ºãƒ³ã®çµ±è¨ˆãŒè¿”ã•ã‚Œã‚‹', async () => {
      const res = await app.request('/api/statistics');
      const json = await res.json();

      expect(res.status).toBe(200);
      expect(json.success).toBe(true);
      expect(json.data.season).toBe(3); // æœ€æ–°ã‚·ãƒ¼ã‚ºãƒ³
    });

    it('æœ€æ–°ã‚·ãƒ¼ã‚ºãƒ³ã®ãƒ‡ãƒ¼ã‚¿ã®ã¿ãŒé›†è¨ˆã•ã‚Œã‚‹', async () => {
      const res = await app.request('/api/statistics');
      const json = await res.json();

      // ã‚·ãƒ¼ã‚ºãƒ³3ã®ãƒ‡ãƒ¼ã‚¿ã¯2ä»¶
      expect(json.data.overall.totalGames).toBe(2);
    });
  });

  describe('ã‚·ãƒ¼ã‚ºãƒ³æŒ‡å®šã‚ã‚Š', () => {
    it('æŒ‡å®šã—ãŸã‚·ãƒ¼ã‚ºãƒ³ã®çµ±è¨ˆãŒè¿”ã•ã‚Œã‚‹', async () => {
      const res = await app.request('/api/statistics?season=2');
      const json = await res.json();

      expect(res.status).toBe(200);
      expect(json.data.season).toBe(2);
      expect(json.data.overall.totalGames).toBe(1); // ã‚·ãƒ¼ã‚ºãƒ³2ã¯1ä»¶
    });

    it('å­˜åœ¨ã—ãªã„ã‚·ãƒ¼ã‚ºãƒ³ã§ã¯ç©ºã®çµ±è¨ˆãŒè¿”ã•ã‚Œã‚‹', async () => {
      const res = await app.request('/api/statistics?season=99');
      const json = await res.json();

      expect(res.status).toBe(200);
      expect(json.data.overall.totalGames).toBe(0);
    });

    it('ä¸æ­£ãªã‚·ãƒ¼ã‚ºãƒ³å€¤ã§ã‚¨ãƒ©ãƒ¼ãŒè¿”ã•ã‚Œã‚‹', async () => {
      const res = await app.request('/api/statistics?season=abc');
      const json = await res.json();

      expect(res.status).toBe(400);
      expect(json.success).toBe(false);
      expect(json.error.code).toBe('INVALID_PARAMETER');
    });
  });

  describe('çµ±è¨ˆè¨ˆç®—', () => {
    it('å‹ç‡ãŒæ­£ã—ãè¨ˆç®—ã•ã‚Œã‚‹', async () => {
      const res = await app.request('/api/statistics?season=3');
      const json = await res.json();

      // 2æˆ¦1å‹1æ•— = 50%
      expect(json.data.overall.winRate).toBe(50);
    });

    it('ã‚¿ãƒ¼ãƒ³åˆ¥çµ±è¨ˆãŒè¿”ã•ã‚Œã‚‹', async () => {
      const res = await app.request('/api/statistics?season=3');
      const json = await res.json();

      expect(json.data.byTurn.å…ˆæ”»).toBeDefined();
      expect(json.data.byTurn.å¾Œæ”»).toBeDefined();
    });
  });

  describe('å¯¾æˆ¦å±¥æ­´0ä»¶', () => {
    it('ç©ºã®çµ±è¨ˆãŒè¿”ã•ã‚Œã‚‹', async () => {
      vi.mocked(createBlobStorageClient).mockReturnValue({
        getBattleLogs: vi.fn().mockResolvedValue([]),
        getDeckMasters: vi.fn().mockResolvedValue([]),
        getMyDecks: vi.fn().mockResolvedValue([]),
      } as any);

      const res = await app.request('/api/statistics');
      const json = await res.json();

      expect(res.status).toBe(200);
      expect(json.data.overall.totalGames).toBe(0);
      expect(json.data.overall.winRate).toBe(0);
    });
  });
});
```

---

## å®Œäº†æ¡ä»¶

- [ ] `GET /api/statistics?season=N` ã§ã‚·ãƒ¼ã‚ºãƒ³æŒ‡å®šçµ±è¨ˆãŒå–å¾—ã§ãã‚‹
- [ ] ã‚·ãƒ¼ã‚ºãƒ³æŒ‡å®šãªã—ã§æœ€æ–°ã‚·ãƒ¼ã‚ºãƒ³ã®çµ±è¨ˆãŒè¿”ã•ã‚Œã‚‹
- [ ] SeasonStatisticså½¢å¼ã§ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒè¿”ã•ã‚Œã‚‹
- [ ] ä¸æ­£ãªã‚·ãƒ¼ã‚ºãƒ³å€¤ã§ã‚¨ãƒ©ãƒ¼ãŒè¿”ã•ã‚Œã‚‹
- [ ] å˜ä½“ãƒ†ã‚¹ãƒˆãŒã™ã¹ã¦æˆåŠŸã™ã‚‹

---

## å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰

```bash
# TDDãƒ•ãƒ­ãƒ¼
/tsumiki:tdd-red           # ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆå¤±æ•—ï¼‰
/tsumiki:tdd-green         # æœ€å°å®Ÿè£…ï¼ˆæˆåŠŸï¼‰
/tsumiki:tdd-refactor      # ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
/tsumiki:tdd-verify-complete  # å“è³ªç¢ºèª
```

---

## æ¤œè¨¼æ‰‹é †

1. APIã‚’å®Ÿè¡Œã—ã¦ã‚·ãƒ¼ã‚ºãƒ³æŒ‡å®šãªã—ã§æœ€æ–°ã‚·ãƒ¼ã‚ºãƒ³ãŒè¿”ã‚‹ã‹ç¢ºèª:
   ```bash
   curl http://localhost:8787/api/statistics
   ```
2. ã‚·ãƒ¼ã‚ºãƒ³æŒ‡å®šã§è©²å½“ã‚·ãƒ¼ã‚ºãƒ³ã®çµ±è¨ˆãŒè¿”ã‚‹ã‹ç¢ºèª:
   ```bash
   curl http://localhost:8787/api/statistics?season=3
   ```
3. `pnpm test` ã§ãƒ†ã‚¹ãƒˆãŒæˆåŠŸã™ã‚‹ã‹ç¢ºèª

---

## é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆè¨­è¨ˆ api-endpoints.md 4.2](../../design/deck-management-extension/api-endpoints.md)
- [TASK-0025: ã‚·ãƒ¼ã‚ºãƒ³ä¸€è¦§å–å¾—å®Ÿè£…](./TASK-0025.md)
