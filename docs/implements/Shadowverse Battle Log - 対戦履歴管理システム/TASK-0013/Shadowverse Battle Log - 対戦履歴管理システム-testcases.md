# TDDテストケース: Backend統合テストとCI/CD設定

**機能名**: Backend Integration Tests and CI/CD Pipeline
**タスクID**: TASK-0013
**テストフレームワーク**: Jest 29.7.0 + ts-jest
**作成日**: 2025-11-04
**更新日**: 2025-11-04

---

## 📋 テストケース概要

### テスト対象

- **統合テスト**: すべてのAPIエンドポイント（TASK-0007~0012）の連携動作
- **CI/CDパイプライン**: GitHub Actionsによる自動テスト・デプロイ
- **ヘルスチェック**: システム正常性確認エンドポイント

### テスト環境

- **プログラミング言語**: TypeScript 5.7+
  - **言語選択の理由**: 既存実装がTypeScript、型安全性の確保、既存テストとの一貫性
  - **テストに適した機能**: 型推論による安全性、モック作成の容易さ、既存ツールとの統合
- **テストフレームワーク**: Jest 29.7.0 + ts-jest
  - **フレームワーク選択の理由**: 既存テスト（109 passed）で使用中、Node.js環境での標準的な選択、モック機能の充実
  - **テスト実行環境**: Node.js 22.x LTS、ローカル開発環境、GitHub Actions CI/CD
- 🔵 **信頼性レベル**: 青信号（tech-stack.md、jest.config.js、既存テストから確認）

### カバレッジ目標

- **現在のカバレッジ**: 80.8% (lines) - 109 passed tests
- **目標カバレッジ**: 70%以上を維持（NFR-304準拠）
- **カバレッジ計算対象**: `src/**/*.ts` (型定義除く)

### 既存テストの状況

- **合計テスト**: 120 tests
  - **成功**: 109 tests
  - **失敗**: 11 tests（blobStorageClient.test.ts - タイムアウト問題）
- **既存テストファイル**:
  - `tests/services/battleLogService.test.ts` (26 tests)
  - `tests/services/statisticsService.test.ts` (60 tests)
  - `tests/services/importService.test.ts` (23 tests)
  - `tests/services/deckMasterService.test.ts`
  - `tests/storage/blobStorageClient.test.ts` (11 failed - 要修正)
  - `tests/utils/validation.test.ts`
  - `tests/utils/idGenerator.test.ts`
  - `tests/functions/import.test.ts`

---

## 1. 統合テスト - 対戦履歴APIフロー

### 正常系テストケース

#### TC-INT-001: 対戦履歴の完全フロー（登録→一覧取得→削除）

- **テスト名**: 対戦履歴の登録から削除までの完全なフローが正常に動作する
  - **何をテストするか**: 対戦履歴API（POST、GET、DELETE）が連携して正しく動作すること
  - **期待される動作**: 登録したデータが一覧で取得でき、削除後は取得できなくなること
- **入力値**:
  ```typescript
  // 1. 登録データ
  {
    date: "2025-11-04",
    battleType: "ランクマッチ",
    rank: "ダイアモンド",
    group: "AA",
    myDeckId: "deck-001",
    turn: "先攻",
    result: "勝ち",
    opponentDeckId: "deck-101"
  }
  // 2. 一覧取得フィルタ
  {
    startDate: "2025-10-28",
    endDate: "2025-11-04",
    limit: 100,
    offset: 0
  }
  // 3. 削除対象ID: 登録時に生成されたID
  ```
  - **入力データの意味**: 典型的な1週間の対戦履歴管理フロー、実運用で最も頻繁に発生するパターン
- **期待される結果**:
  - **登録レスポンス**: `success: true`, 生成されたID（例: "BL-20251104-0001"）
  - **一覧取得レスポンス**: 登録したデータが配列に含まれる、`total >= 1`
  - **削除レスポンス**: `success: true`, 削除されたIDが返る
  - **削除後の一覧取得**: 削除したデータが含まれない
  - **期待結果の理由**: APIの基本的なCRUD操作が正しく連携していることを確認
- **テストの目的**: API間のデータの一貫性と、各エンドポイントの連携動作を保証
  - **確認ポイント**:
    - 登録時にIDが正しく生成される
    - 一覧取得で登録データが正しく返される
    - 削除操作が確実に実行される
    - 削除後にデータが存在しないことを確認
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 82-213より）

#### TC-INT-002: 複数の対戦履歴を登録し、フィルタリングして取得

- **テスト名**: 期間とフィルタ条件を指定して対戦履歴を正しく取得できる
  - **何をテストするか**: 一覧取得APIのフィルタリング機能が正しく動作すること
  - **期待される動作**: 指定した期間内のデータのみが返される
- **入力値**:
  ```typescript
  // 3件の対戦履歴を登録
  [
    { date: "2025-10-28", result: "勝ち", ... },
    { date: "2025-11-02", result: "負け", ... },
    { date: "2025-11-04", result: "勝ち", ... }
  ]
  // フィルタ条件
  {
    startDate: "2025-11-01",
    endDate: "2025-11-04",
    limit: 10
  }
  ```
  - **入力データの意味**: 異なる日付のデータを用意し、期間フィルタリングの正確性を確認
- **期待される結果**:
  - 取得されるデータ: 2件（2025-11-02と2025-11-04のみ）
  - 2025-10-28のデータは含まれない
  - **期待結果の理由**: startDate/endDateフィルタリングが正しく機能していることを確認
- **テストの目的**: 一覧取得APIのフィルタリング機能の正確性を検証
  - **確認ポイント**:
    - 日付範囲フィルタリングが正確に動作
    - 期間外のデータが確実に除外される
    - limitパラメータが正しく適用される
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 100-106より）

### 異常系テストケース

#### TC-INT-ERR-001: 存在しないIDの削除を試みる

- **テスト名**: 存在しない対戦履歴IDを削除しようとするとエラーが返される
  - **エラーケースの概要**: 既に削除済みまたは存在しないIDを指定した削除操作
  - **エラー処理の重要性**: データの整合性を保ち、クライアントに適切なフィードバックを提供
- **入力値**:
  ```typescript
  {
    id: "BL-20250101-NONEXISTENT"
  }
  ```
  - **不正な理由**: このIDのデータは存在しない
  - **実際の発生シナリオ**: 同時削除、通信エラー後のリトライ、古いキャッシュからの操作
- **期待される結果**:
  ```typescript
  {
    success: false,
    error: {
      code: "NOT_FOUND",
      message: "指定された対戦履歴が見つかりません"
    }
  }
  ```
  - **エラーメッセージの内容**: ユーザーに分かりやすい日本語メッセージ
  - **システムの安全性**: エラー時もデータの整合性が保たれる
- **テストの目的**: 存在しないリソースへのアクセス時の適切なエラーハンドリングを確認
  - **品質保証の観点**: ユーザーに明確なフィードバックを提供し、データの一貫性を保つ
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 195-205より）

#### TC-INT-ERR-002: 不正な形式のデータで登録を試みる

- **テスト名**: バリデーションエラーが適切に返される
  - **エラーケースの概要**: 必須フィールド欠落、型不一致、無効な値での登録試行
  - **エラー処理の重要性**: データの品質を保ち、不正なデータの混入を防止
- **入力値**:
  ```typescript
  {
    date: "invalid-date",  // 不正な日付形式
    battleType: "無効なタイプ",  // 存在しないタイプ
    result: null  // 必須フィールドがnull
  }
  ```
  - **不正な理由**: 型定義に準拠していない、必須フィールドの欠落
  - **実際の発生シナリオ**: クライアントサイドのバリデーション不足、手動API呼び出し、古いクライアントバージョン
- **期待される結果**:
  ```typescript
  {
    success: false,
    error: {
      code: "VALIDATION_ERROR",
      message: "入力値が不正です",
      details: [
        { field: "date", message: "日付形式が正しくありません" },
        { field: "battleType", message: "無効な対戦タイプです" },
        { field: "result", message: "対戦結果は必須です" }
      ]
    }
  }
  ```
  - **エラーメッセージの内容**: 各フィールドの具体的なエラー理由を返す
  - **システムの安全性**: 不正なデータは保存されない
- **テストの目的**: 入力バリデーションの完全性を検証
  - **品質保証の観点**: データの整合性を維持し、問題の早期発見を促進
- 🔵 **信頼性レベル**: 青信号（既存テストvalidation.test.tsのパターンより）

### 境界値テストケース

#### TC-INT-BOUND-001: 一覧取得のlimit/offset境界値

- **テスト名**: limitとoffsetの境界値で正しくページネーションが動作する
  - **境界値の意味**: ページネーション機能の正確性、大量データ取得時の挙動
  - **境界値での動作保証**: 極端な値でもシステムが正しく動作すること
- **入力値**:
  ```typescript
  // ケース1: limit = 0
  { startDate: "2025-10-01", endDate: "2025-11-04", limit: 0, offset: 0 }

  // ケース2: limit = 1000 (最大値)
  { startDate: "2025-10-01", endDate: "2025-11-04", limit: 1000, offset: 0 }

  // ケース3: offset が総件数を超える
  { startDate: "2025-10-01", endDate: "2025-11-04", limit: 10, offset: 9999 }
  ```
  - **境界値選択の根拠**: limit=0は最小値、1000は実用上の最大値、offsetオーバーは実際に発生しうるケース
  - **実際の使用場面**: UI表示件数の制御、バッチ処理、データ移行処理
- **期待される結果**:
  - **limit = 0**: 空配列を返す（エラーではない）
  - **limit = 1000**: 最大1000件まで返す（パフォーマンスは許容範囲内）
  - **offset オーバー**: 空配列を返す（エラーではない）
  - **境界での正確性**: 各境界値で意図した通りの動作をする
  - **一貫した動作**: エッジケースでもAPIレスポンス形式が一貫している
- **テストの目的**: ページネーション機能の堅牢性を検証
  - **堅牢性の確認**: 極端な値でもエラーを起こさず、予測可能な動作をする
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 100-106より）

#### TC-INT-BOUND-002: 日付範囲の境界値

- **テスト名**: 開始日と終了日が同一日付、または逆順の場合の挙動
  - **境界値の意味**: 日付フィルタリングのエッジケース
  - **境界値での動作保証**: 特殊な日付範囲でも安全に動作すること
- **入力値**:
  ```typescript
  // ケース1: 同一日
  { startDate: "2025-11-04", endDate: "2025-11-04" }

  // ケース2: 逆順
  { startDate: "2025-11-04", endDate: "2025-10-28" }

  // ケース3: 未来の日付
  { startDate: "2025-12-01", endDate: "2025-12-31" }
  ```
  - **境界値選択の根拠**: 同一日は当日のみの検索、逆順はユーザーの入力ミス、未来日付は予定の入力
  - **実際の使用場面**: 当日の戦績確認、UI操作ミス、予定の事前入力
- **期待される結果**:
  - **同一日**: その日のデータのみ返す
  - **逆順**: エラーまたは空配列を返す（仕様に応じて）
  - **未来の日付**: 空配列を返す（データが存在しない）
  - **境界での正確性**: 日付計算が正確に行われる
  - **一貫した動作**: エッジケースでも予測可能な結果を返す
- **テストの目的**: 日付フィルタリング機能の堅牢性を検証
  - **堅牢性の確認**: 特殊な日付範囲でもシステムが安定動作する
- 🟡 **信頼性レベル**: 黄信号（逆順時の挙動は要件定義に明記なし、妥当な推測）

---

## 2. 統合テスト - 統計APIフロー

### 正常系テストケース

#### TC-INT-STATS-001: 統計計算の統合テスト（複数データ登録→統計計算）

- **テスト名**: 複数の対戦履歴を登録し、統計APIが正しく集計する
  - **何をテストするか**: 対戦履歴の登録と統計計算の連携が正しく動作すること
  - **期待される動作**: 登録したデータに基づいて、正確な統計が計算されること
- **入力値**:
  ```typescript
  // 10件の対戦履歴を登録
  // - myDeckId "deck-001": 6勝4敗（勝率60%）
  // - myDeckId "deck-002": 2勝3敗（勝率40%）
  // - opponentDeckId "deck-101": 3戦（2勝1敗）
  // - opponentDeckId "deck-102": 5戦（3勝2敗）
  // - 全体: 15戦、8勝7敗（勝率53.3%）

  // 統計取得リクエスト
  {
    startDate: "2025-10-01",
    endDate: "2025-11-04"
  }
  ```
  - **入力データの意味**: 実際の1ヶ月間のプレイデータを模擬、複数デッキと相手の組み合わせ
- **期待される結果**:
  ```typescript
  {
    success: true,
    data: {
      overall: {
        totalGames: 15,
        wins: 8,
        losses: 7,
        winRate: 53.3
      },
      byMyDeck: [
        { deckId: "deck-001", games: 10, wins: 6, losses: 4, winRate: 60.0 },
        { deckId: "deck-002", games: 5, wins: 2, losses: 3, winRate: 40.0 }
      ],
      byOpponent: [
        { deckId: "deck-101", games: 3, wins: 2, losses: 1, winRate: 66.7 },
        { deckId: "deck-102", games: 5, wins: 3, losses: 2, winRate: 60.0 }
      ]
    }
  }
  ```
  - **期待結果の理由**: 統計計算ロジックが正しく実装されていることを確認
- **テストの目的**: 対戦履歴と統計APIの連携、計算精度の検証
  - **確認ポイント**:
    - 全体統計の計算が正確
    - デッキ別統計の集計が正確
    - 相手別統計の集計が正確
    - 勝率計算が正しい（小数点第1位まで）
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 114-237、既存テストstatisticsService.test.tsより）

#### TC-INT-STATS-002: 統計APIのキャッシュと再計算

- **テスト名**: データ更新後に統計が正しく再計算される
  - **何をテストするか**: データの追加・削除後に統計が最新の状態に更新されること
  - **期待される動作**: キャッシュではなく、常に最新データで統計を計算すること
- **入力値**:
  ```typescript
  // 1. 初回: 5件の対戦履歴（3勝2敗）
  // 2. 統計取得 → 勝率60%
  // 3. 新規登録: 2件追加（1勝1敗）
  // 4. 統計再取得 → 勝率57.1%に更新されることを期待
  ```
  - **入力データの意味**: データの動的な変更に統計が追従することを確認
- **期待される結果**:
  - **初回統計**: `winRate: 60.0` (3勝2敗)
  - **データ追加後統計**: `winRate: 57.1` (4勝3敗)
  - **期待結果の理由**: 統計がリアルタイムで更新されることを保証
- **テストの目的**: 統計計算のリアルタイム性を検証
  - **確認ポイント**:
    - データ変更が統計に即座に反映される
    - 古いキャッシュが使用されていない
    - 計算結果の一貫性
- 🟡 **信頼性レベル**: 黄信号（キャッシュの有無は要件定義に明記なし、現在の実装から推測）

### 異常系テストケース

#### TC-INT-STATS-ERR-001: データが0件の期間の統計計算

- **テスト名**: 対戦履歴が存在しない期間の統計を取得すると適切なレスポンスが返る
  - **エラーケースの概要**: データが存在しない期間での統計計算
  - **エラー処理の重要性**: ゼロ除算エラーを防ぎ、ユーザーに適切なフィードバックを提供
- **入力値**:
  ```typescript
  {
    startDate: "2024-01-01",  // データが存在しない期間
    endDate: "2024-01-31"
  }
  ```
  - **不正な理由**: 指定期間にデータが存在しない
  - **実際の発生シナリオ**: 新規ユーザー、過去の期間指定、データ削除後
- **期待される結果**:
  ```typescript
  {
    success: true,
    data: {
      overall: {
        totalGames: 0,
        wins: 0,
        losses: 0,
        winRate: 0
      },
      byMyDeck: [],
      byOpponent: []
    }
  }
  ```
  - **エラーメッセージの内容**: エラーではなく、0件のデータとして返す
  - **システムの安全性**: ゼロ除算エラーが発生しない
- **テストの目的**: 統計計算のエッジケース処理を検証
  - **品質保証の観点**: データが存在しない場合でも安全に動作すること
- 🔵 **信頼性レベル**: 青信号（既存テストstatisticsService.test.tsで類似ケース確認）

---

## 3. 統合テスト - インポートAPIフロー

### 正常系テストケース

#### TC-INT-IMPORT-001: JSONインポート→一覧取得の統合フロー

- **テスト名**: JSONデータをインポートし、一覧取得で確認できる
  - **何をテストするか**: インポートAPIと一覧取得APIの連携が正しく動作すること
  - **期待される動作**: インポートしたデータが即座に一覧で取得できること
- **入力値**:
  ```typescript
  // インポートデータ（JSON）
  {
    format: "json",
    data: JSON.stringify([
      { date: "2025-11-01", battleType: "ランクマッチ", ... },
      { date: "2025-11-02", battleType: "対戦台", ... },
      { date: "2025-11-03", battleType: "ロビー大会", ... }
    ]),
    overwrite: false  // 追加モード
  }

  // 一覧取得リクエスト
  {
    startDate: "2025-11-01",
    endDate: "2025-11-03"
  }
  ```
  - **入力データの意味**: 典型的な複数日分のバックアップデータのインポート
- **期待される結果**:
  - **インポートレスポンス**: `{ imported: 3, skipped: 0, errors: 0 }`
  - **一覧取得レスポンス**: インポートした3件のデータが含まれる
  - **期待結果の理由**: インポート機能が正しく動作し、データが永続化されることを確認
- **テストの目的**: インポートAPIとデータ永続化の連携を検証
  - **確認ポイント**:
    - インポートが成功する
    - インポート件数が正しい
    - データが永続化されている
    - 一覧取得で取得できる
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 139-158より）

#### TC-INT-IMPORT-002: CSVインポート→統計計算の統合フロー

- **テスト名**: CSVデータをインポートし、統計が正しく計算される
  - **何をテストするか**: CSVインポート後、統計APIが正しくデータを集計すること
  - **期待される動作**: インポートしたデータが統計計算に反映されること
- **入力値**:
  ```typescript
  // CSVデータ
  {
    format: "csv",
    data: `date,battleType,rank,group,myDeckId,turn,result,opponentDeckId
2025-11-01,ランクマッチ,ダイアモンド,AA,deck-001,先攻,勝ち,deck-101
2025-11-02,ランクマッチ,ダイアモンド,AA,deck-001,後攻,負け,deck-102
2025-11-03,対戦台,-,-,deck-002,先攻,勝ち,deck-103`,
    overwrite: false
  }

  // 統計取得リクエスト
  {
    startDate: "2025-11-01",
    endDate: "2025-11-03"
  }
  ```
  - **入力データの意味**: Excelやスプレッドシートからのエクスポートデータ
- **期待される結果**:
  - **インポートレスポンス**: `{ imported: 3, skipped: 0, errors: 0 }`
  - **統計レスポンス**:
    ```typescript
    {
      overall: { totalGames: 3, wins: 2, losses: 1, winRate: 66.7 },
      byMyDeck: [
        { deckId: "deck-001", games: 2, wins: 1, losses: 1, winRate: 50.0 },
        { deckId: "deck-002", games: 1, wins: 1, losses: 0, winRate: 100.0 }
      ]
    }
    ```
  - **期待結果の理由**: CSVインポートが正しく動作し、統計計算に反映されることを確認
- **テストの目的**: CSVインポートと統計計算の連携を検証
  - **確認ポイント**:
    - CSVパースが正しい
    - データが正しく保存される
    - 統計計算に反映される
    - 計算結果が正確
- 🔵 **信頼性レベル**: 青信号（requirements.md、既存テストimportService.test.tsより）

### 異常系テストケース

#### TC-INT-IMPORT-ERR-001: 不正なJSON形式のインポート

- **テスト名**: 不正なJSON形式のデータをインポートするとエラーが返される
  - **エラーケースの概要**: JSONパースエラー、不正な形式のデータ
  - **エラー処理の重要性**: データの整合性を保ち、部分的なインポートを防止
- **入力値**:
  ```typescript
  {
    format: "json",
    data: "{ invalid json syntax }",  // 不正なJSON
    overwrite: false
  }
  ```
  - **不正な理由**: JSONとしてパース不可能
  - **実際の発生シナリオ**: 手動編集ミス、ファイル破損、文字エンコーディング問題
- **期待される結果**:
  ```typescript
  {
    success: false,
    error: {
      code: "INVALID_FORMAT",
      message: "JSONの形式が不正です"
    }
  }
  ```
  - **エラーメッセージの内容**: パースエラーの具体的な理由
  - **システムの安全性**: 部分的なインポートが行われない、既存データが保護される
- **テストの目的**: インポート機能のエラーハンドリングを検証
  - **品質保証の観点**: 不正なデータがシステムに混入しないことを保証
- 🔵 **信頼性レベル**: 青信号（既存テストimportService.test.tsより）

#### TC-INT-IMPORT-ERR-002: 重複データのインポート（上書きなし）

- **テスト名**: 既存データと重複するデータをインポートすると適切にスキップされる
  - **エラーケースの概要**: 同一日付・同一条件のデータの重複インポート
  - **エラー処理の重要性**: データの重複を防ぎ、データの整合性を保つ
- **入力値**:
  ```typescript
  // 既存データ: 2025-11-01, myDeckId: deck-001, result: 勝ち
  // インポートデータ: 同じ2025-11-01, myDeckId: deck-001, result: 勝ち
  {
    format: "json",
    data: JSON.stringify([
      { date: "2025-11-01", myDeckId: "deck-001", result: "勝ち", ... }
    ]),
    overwrite: false  // 上書きしない
  }
  ```
  - **不正な理由**: 既存データと重複している
  - **実際の発生シナリオ**: 誤った再インポート、バックアップの重複適用
- **期待される結果**:
  ```typescript
  {
    success: true,
    data: {
      imported: 0,
      skipped: 1,  // 重複のためスキップ
      errors: 0
    }
  }
  ```
  - **エラーメッセージの内容**: エラーではなく、スキップとして処理
  - **システムの安全性**: 重複データが保存されない、既存データが保護される
- **テストの目的**: 重複データの検出と適切な処理を検証
  - **品質保証の観点**: データの一意性を保ち、不要な重複を防止
- 🔵 **信頼性レベル**: 青信号（既存テストimportService.test.tsより）

---

## 4. CI/CDパイプラインテスト

### 正常系テストケース

#### TC-CICD-001: Lintチェックの実行

- **テスト名**: Biome lintが警告・エラーなしで成功する（ゼロ警告ポリシー）
  - **何をテストするか**: コード品質チェックが正しく実行されること
  - **期待される動作**: すべてのソースコードがlintルールに準拠していること
- **入力値**:
  ```bash
  # GitHub Actions環境
  npm run lint
  ```
  - **入力データの意味**: CI/CDパイプラインの最初のゲート、コード品質の基準
- **期待される結果**:
  ```bash
  exit code: 0
  warnings: 0
  errors: 0
  ```
  - **期待結果の理由**: NFR-303（ゼロ警告ポリシー）準拠
- **テストの目的**: コード品質基準の自動検証
  - **確認ポイント**:
    - Biomeが正しく実行される
    - 警告が0件
    - エラーが0件
    - ゼロ警告ポリシー準拠
- 🔵 **信頼性レベル**: 青信号（NFR-303、tech-stack.md、既存設定より）

#### TC-CICD-002: TypeScript型チェックの実行

- **テスト名**: TypeScript型チェックがエラーなしで成功する
  - **何をテストするか**: 型安全性が保たれていること
  - **期待される動作**: すべてのコードが型定義に準拠していること
- **入力値**:
  ```bash
  npm run build  # tsc実行
  ```
  - **入力データの意味**: TypeScript strict modeでのコンパイル成功
- **期待される結果**:
  ```bash
  exit code: 0
  type errors: 0
  ```
  - **期待結果の理由**: NFR-301（TypeScript strict mode）準拠
- **テストの目的**: 型安全性の自動検証
  - **確認ポイント**:
    - TypeScriptコンパイルが成功
    - 型エラーが0件
    - strict mode準拠
- 🔵 **信頼性レベル**: 青信号（NFR-301、jest.config.js、既存設定より）

#### TC-CICD-003: Unitテストの実行

- **テスト名**: すべてのUnitテストが成功する
  - **何をテストするか**: 既存の全テストケースが正しく動作すること
  - **期待される動作**: 109個以上のテストが成功すること
- **入力値**:
  ```bash
  npm test
  ```
  - **入力データの意味**: 既存実装の回帰テスト
- **期待される結果**:
  ```bash
  Tests: 109+ passed, 0 failed
  exit code: 0
  ```
  - **期待結果の理由**: 既存機能の正常動作を保証
- **テストの目的**: 回帰テストの自動実行
  - **確認ポイント**:
    - すべてのテストが実行される
    - テスト失敗が0件
    - 実行時間が許容範囲内（2分以内）
- 🔵 **信頼性レベル**: 青信号（現在の109 passed testsより）

#### TC-CICD-004: 統合テストの実行

- **テスト名**: すべての統合テストが成功する
  - **何をテストするか**: API統合フローが正しく動作すること
  - **期待される動作**: 本ドキュメントで定義した統合テストがすべて成功すること
- **入力値**:
  ```bash
  npm run test:integration  # 統合テストのみ実行
  ```
  - **入力データの意味**: API連携の検証
- **期待される結果**:
  ```bash
  Integration Tests: all passed
  duration: < 10秒
  exit code: 0
  ```
  - **期待結果の理由**: NFR-001（3秒以内のレスポンス）を考慮した実行時間
- **テストの目的**: API統合の自動検証
  - **確認ポイント**:
    - 統合テストが分離して実行できる
    - すべてのAPI連携が正常
    - 実行時間が許容範囲内
- 🟡 **信頼性レベル**: 黄信号（統合テストは今回新規作成のため、実装後に確認）

#### TC-CICD-005: カバレッジチェックの実行

- **テスト名**: テストカバレッジが70%以上である
  - **何をテストするか**: テストの網羅性が基準を満たしていること
  - **期待される動作**: カバレッジが目標値以上であること
- **入力値**:
  ```bash
  npm run test:coverage
  ```
  - **入力データの意味**: テスト品質の定量的評価
- **期待される結果**:
  ```bash
  Coverage:
    lines: >= 70%
    branches: >= 70%
    functions: >= 70%
    statements: >= 70%
  exit code: 0
  ```
  - **期待結果の理由**: tech-stack.mdで定義されたカバレッジ基準
- **テストの目的**: テスト品質の自動検証
  - **確認ポイント**:
    - カバレッジ計算が正確
    - 各指標が70%以上
    - カバレッジレポートが生成される
- 🔵 **信頼性レベル**: 青信号（tech-stack.md、jest.config.js、現在80.8%より）

#### TC-CICD-006: mainブランチへのデプロイ

- **テスト名**: mainブランチへのpush時にAzure Functionsへ自動デプロイされる
  - **何をテストするか**: デプロイパイプラインが正しく動作すること
  - **期待される動作**: すべてのテストが成功した後、自動デプロイが実行されること
- **入力値**:
  ```yaml
  trigger:
    branch: main
    paths: ['backend/**']
  ```
  - **入力データの意味**: 本番環境へのデプロイトリガー
- **期待される結果**:
  ```bash
  Deploy to Azure Functions: SUCCESS
  URL: https://<functionapp>.azurewebsites.net
  exit code: 0
  ```
  - **期待結果の理由**: NFR-305（自動デプロイ）準拠
- **テストの目的**: 自動デプロイの動作検証
  - **確認ポイント**:
    - mainブランチのみデプロイされる
    - テスト成功後にデプロイが実行される
    - デプロイが成功する
    - デプロイ時間が許容範囲内（1分以内）
- 🔵 **信頼性レベル**: 青信号（NFR-305、既存backend-deploy.ymlより）

### 異常系テストケース

#### TC-CICD-ERR-001: Lintエラー時のパイプライン停止

- **テスト名**: Lintエラーが検出された場合、パイプラインが停止する
  - **エラーケースの概要**: コード品質基準に違反したコードがpushされた場合
  - **エラー処理の重要性**: 品質基準に満たないコードが本番環境にデプロイされることを防止
- **入力値**:
  ```typescript
  // 意図的にlintエラーを含むコード
  const unused = 'this variable is not used';  // no-unused-vars
  ```
  - **不正な理由**: Biome lintルール違反
  - **実際の発生シナリオ**: 開発中の一時的なコード、マージ前のレビュー不足
- **期待される結果**:
  ```bash
  Lint check: FAILED
  error[no-unused-vars]: 'unused' is defined but never used
  Pipeline: STOPPED
  Subsequent steps: SKIPPED
  exit code: 1
  ```
  - **エラーメッセージの内容**: 具体的なlintエラーと位置情報
  - **システムの安全性**: 品質基準に満たないコードがデプロイされない
- **テストの目的**: 品質ゲートの動作検証
  - **品質保証の観点**: ゼロ警告ポリシーが確実に適用されることを確認
- 🔵 **信頼性レベル**: 青信号（NFR-303、CI/CDパイプラインの基本動作より）

#### TC-CICD-ERR-002: テスト失敗時のパイプライン停止

- **テスト名**: テストが失敗した場合、パイプラインが停止する
  - **エラーケースの概要**: ユニットテストまたは統合テストが失敗した場合
  - **エラー処理の重要性**: バグを含むコードが本番環境にデプロイされることを防止
- **入力値**:
  ```typescript
  // 失敗するテストケース（意図的）
  test('should fail', () => {
    expect(1 + 1).toBe(3);  // 失敗する
  });
  ```
  - **不正な理由**: テストアサーションが失敗
  - **実際の発生シナリオ**: 実装バグ、テストケースの更新漏れ、リファクタリング時の見落とし
- **期待される結果**:
  ```bash
  Tests: 1 failed, 109 passed, 110 total
  Pipeline: STOPPED
  Deploy: SKIPPED
  exit code: 1
  ```
  - **エラーメッセージの内容**: 失敗したテストの詳細情報
  - **システムの安全性**: バグを含むコードがデプロイされない
- **テストの目的**: テストゲートの動作検証
  - **品質保証の観点**: テスト失敗時に確実にデプロイが阻止されることを確認
- 🔵 **信頼性レベル**: 青信号（CI/CDパイプラインの基本動作より）

#### TC-CICD-ERR-003: カバレッジ不足時のパイプライン停止

- **テスト名**: カバレッジが70%未満の場合、パイプラインが停止する
  - **エラーケースの概要**: テストカバレッジが基準を下回った場合
  - **エラー処理の重要性**: テストの網羅性を保ち、品質基準を維持
- **入力値**:
  ```bash
  # カバレッジが65%の状態
  Coverage:
    lines: 65.5%
    branches: 68.0%
    functions: 70.0%
    statements: 66.0%
  ```
  - **不正な理由**: lines, statements が70%未満
  - **実際の発生シナリオ**: 新機能追加時にテストを書き忘れ、既存テストの削除
- **期待される結果**:
  ```bash
  Coverage check: FAILED
  Coverage: 65.5% (threshold: 70%)
  Pipeline: STOPPED
  Deploy: SKIPPED
  exit code: 1
  ```
  - **エラーメッセージの内容**: 現在のカバレッジと目標値の差分
  - **システムの安全性**: テストが不十分なコードがデプロイされない
- **テストの目的**: カバレッジゲートの動作検証
  - **品質保証の観点**: カバレッジ基準が確実に適用されることを確認
- 🔵 **信頼性レベル**: 青信号（tech-stack.md、jest.config.jsより）

#### TC-CICD-ERR-004: デプロイ失敗時のロールバック

- **テスト名**: デプロイが失敗した場合、エラーが報告される
  - **エラーケースの概要**: Azure Functionsへのデプロイが失敗した場合
  - **エラー処理の重要性**: デプロイ失敗を早期に検出し、対応を促す
- **入力値**:
  ```yaml
  # デプロイ設定（認証情報が無効な状態を模擬）
  AZURE_FUNCTIONAPP_PUBLISH_PROFILE: <invalid>
  ```
  - **不正な理由**: 認証情報が無効または期限切れ
  - **実際の発生シナリオ**: シークレットの更新漏れ、権限設定ミス、Azureサービスの一時的な障害
- **期待される結果**:
  ```bash
  Deploy: FAILED
  Error: Invalid publish profile
  Pipeline: FAILED
  exit code: 1
  ```
  - **エラーメッセージの内容**: デプロイ失敗の具体的な理由
  - **システムの安全性**: 失敗時の状態が明確に報告される
- **テストの目的**: デプロイエラーハンドリングの検証
  - **品質保証の観点**: デプロイ失敗時に適切なエラーが報告されることを確認
- 🟡 **信頼性レベル**: 黄信号（Azure Functionsの自動ロールバック機能に依存）

---

## 5. ヘルスチェックエンドポイントテスト

### 正常系テストケース

#### TC-HEALTH-001: ヘルスチェックエンドポイントの応答

- **テスト名**: ヘルスチェックエンドポイントが正常なレスポンスを返す
  - **何をテストするか**: システムの正常性確認エンドポイントが動作すること
  - **期待される動作**: HTTP 200 OKと正常なステータスを返すこと
- **入力値**:
  ```bash
  GET /api/health
  ```
  - **入力データの意味**: システム監視、ロードバランサーのヘルスチェック
- **期待される結果**:
  ```typescript
  {
    status: 200,
    body: {
      success: true,
      data: {
        status: "healthy",
        timestamp: "2025-11-04T12:00:00.000Z",
        version: "1.0.0"
      }
    }
  }
  ```
  - **期待結果の理由**: システムが正常に動作していることを確認
- **テストの目的**: ヘルスチェック機能の動作検証
  - **確認ポイント**:
    - エンドポイントが応答する
    - HTTP 200が返る
    - レスポンス形式が正しい
    - タイムスタンプが現在時刻
- 🟡 **信頼性レベル**: 黄信号（ヘルスチェックエンドポイントは今回新規作成のため、設計は妥当な推測）

#### TC-HEALTH-002: ヘルスチェックのレスポンス時間

- **テスト名**: ヘルスチェックが高速に応答する（100ms以内）
  - **何をテストするか**: ヘルスチェックのパフォーマンス
  - **期待される動作**: 非常に高速にレスポンスを返すこと
- **入力値**:
  ```bash
  GET /api/health
  ```
  - **入力データの意味**: 監視システムからの頻繁なポーリング
- **期待される結果**:
  ```bash
  Response time: < 100ms
  status: 200
  ```
  - **期待結果の理由**: ヘルスチェックは軽量な処理であるべき
- **テストの目的**: ヘルスチェックのパフォーマンス検証
  - **確認ポイント**:
    - レスポンス時間が100ms以内
    - 外部依存なし（DBアクセス不要）
    - 高頻度アクセスに耐えられる
- 🟡 **信頼性レベル**: 黄信号（レスポンス時間基準は一般的なベストプラクティスより推測）

---

## 6. エッジケース・エラーケース

### エッジケース

#### TC-EDGE-001: ネットワークタイムアウトのシミュレーション

- **テスト名**: Azure Blob Storage接続タイムアウト時の適切なエラー処理
  - **境界値の意味**: ネットワーク障害時のシステムの堅牢性
  - **境界値での動作保証**: タイムアウト発生時もシステムが安全に動作すること
- **入力値**:
  ```typescript
  // モックでタイムアウトを発生させる
  mockBlobClient.getBattleLogs.mockImplementation(async () => {
    await new Promise(resolve => setTimeout(resolve, 31000));  // 30秒以上
    throw new Error('Request timeout');
  });
  ```
  - **境界値選択の根拠**: Azure Functions のデフォルトタイムアウトは30秒
  - **実際の使用場面**: ネットワーク障害、Azure Storageの一時的な障害、高負荷時
- **期待される結果**:
  ```typescript
  {
    success: false,
    error: {
      code: "TIMEOUT",
      message: "データの取得がタイムアウトしました。しばらくしてから再度お試しください。"
    }
  }
  ```
  - **境界での正確性**: タイムアウト検出が正確
  - **一貫した動作**: タイムアウト時も一貫したエラーレスポンス形式
- **テストの目的**: ネットワーク障害時の堅牢性を検証
  - **堅牢性の確認**: タイムアウト時もシステムがクラッシュせず、適切なエラーを返す
- 🟡 **信頼性レベル**: 黄信号（requirements.md Lines 519-536で言及、タイムアウト値は推測）

#### TC-EDGE-002: 並列リクエストの処理

- **テスト名**: 複数の登録リクエストが同時に実行されても正しく処理される
  - **境界値の意味**: 並列処理時のデータ競合防止
  - **境界値での動作保証**: 同時アクセスでもデータの整合性が保たれること
- **入力値**:
  ```typescript
  // 3つの登録リクエストを並列実行
  const promises = [
    createBattleLog(data1),
    createBattleLog(data2),
    createBattleLog(data3),
  ];
  const results = await Promise.all(promises);
  ```
  - **境界値選択の根拠**: 実運用での同時アクセスを模擬
  - **実際の使用場面**: 複数タブでの操作、バッチ処理、高頻度のAPI呼び出し
- **期待される結果**:
  - すべてのリクエストが成功する
  - 生成されるIDが重複しない
  - データが正しく保存される
  - **境界での正確性**: ID生成ロジックが並列実行に対応している
  - **一貫した動作**: 並列実行でもデータの整合性が保たれる
- **テストの目的**: 並列処理の安全性を検証
  - **堅牢性の確認**: 同時アクセス時もID重複やデータ競合が発生しない
- 🟡 **信頼性レベル**: 黄信号（requirements.md Lines 554-580で言及、並列処理の詳細は推測）

#### TC-EDGE-003: 大量データのインポート（1000件）

- **テスト名**: 1000件の対戦履歴をインポートしてもパフォーマンスが許容範囲内
  - **境界値の意味**: 大量データ処理時のパフォーマンス
  - **境界値での動作保証**: 大量データでもタイムアウトせず処理できること
- **入力値**:
  ```typescript
  // 1000件のバトルログデータ
  const largeData = Array.from({ length: 1000 }, (_, i) => ({
    date: "2025-11-04",
    battleType: "ランクマッチ",
    // ... 残りのフィールド
  }));

  {
    format: "json",
    data: JSON.stringify(largeData),
    overwrite: false
  }
  ```
  - **境界値選択の根拠**: 年間のプレイ履歴を一括インポートする想定
  - **実際の使用場面**: 過去データの移行、バックアップからの復元
- **期待される結果**:
  - インポートが成功する（タイムアウトしない）
  - 処理時間が許容範囲内（10秒以内）
  - すべてのデータが正しく保存される
  - メモリ使用量が適切
  - **境界での正確性**: 大量データでも処理が正確
  - **一貫した動作**: データ量に関わらずロジックが一貫している
- **テストの目的**: 大量データ処理の性能を検証
  - **堅牢性の確認**: 大量データでもシステムが安定動作する
- 🟡 **信頼性レベル**: 黄信号（1000件という数値は実用的な推測、要件定義に明記なし）

---

## 7. テストケース実装時の日本語コメント指針

すべてのテストケースは以下のコメント形式で実装してください：

### テストケース開始時のコメント

```typescript
/**
 * 【テスト目的】: 対戦履歴の登録から削除までの完全なフローが正常に動作すること
 * 【テスト内容】: POST /api/battle-logs → GET /api/battle-logs → DELETE /api/battle-logs/{id}
 * 【期待される動作】: 登録したデータが一覧で取得でき、削除後は取得できなくなること
 * 🔵 信頼性レベル: 青信号（requirements.md Lines 82-213より）
 */
test('TC-INT-001: 対戦履歴の完全フロー（登録→一覧取得→削除）', async () => {
  // ...
});
```

### Given（準備フェーズ）のコメント

```typescript
// 【テストデータ準備】: 典型的な1週間の対戦履歴管理フロー、実運用で最も頻繁に発生するパターン
// 【初期条件設定】: モックBlobStorageClientを初期化、空の状態からスタート
// 【前提条件確認】: モックが正しく設定されていることを確認
const mockBattleLog = {
  date: "2025-11-04",
  battleType: "ランクマッチ",
  // ...
};
```

### When（実行フェーズ）のコメント

```typescript
// 【実際の処理実行】: BattleLogService.create() メソッドを呼び出し
// 【処理内容】: 対戦履歴の新規登録を実行、IDの自動生成とバリデーションを含む
// 【実行タイミング】: テストデータ準備完了後、即座に実行
const result = await service.create(mockBattleLog);
```

### Then（検証フェーズ）のコメント

```typescript
// 【結果検証】: 登録が成功し、生成されたIDが正しい形式であることを確認
// 【期待値確認】: success = true、IDが "BL-YYYYMMDD-XXXX" 形式
// 【品質保証】: 登録機能の正常動作を保証し、後続の統合テストの基盤となる
expect(result.success).toBe(true);
// 【検証項目】: IDが正しい形式で生成されている 🔵
expect(result.data.id).toMatch(/^BL-\d{8}-\d{4}$/);
```

---

## 8. テストケース総数

### カテゴリ別テストケース数

| カテゴリ | 正常系 | 異常系 | 境界値 | エッジケース | 合計 |
|---------|--------|--------|--------|--------------|------|
| 対戦履歴API統合 | 2 | 2 | 2 | 0 | 6 |
| 統計API統合 | 2 | 1 | 0 | 0 | 3 |
| インポートAPI統合 | 2 | 2 | 0 | 0 | 4 |
| CI/CDパイプライン | 6 | 4 | 0 | 0 | 10 |
| ヘルスチェック | 2 | 0 | 0 | 0 | 2 |
| エッジケース | 0 | 0 | 0 | 3 | 3 |
| **合計** | **14** | **9** | **2** | **3** | **28** |

### 優先度別実装順序

1. **Phase 1（必須）**: CI/CDパイプライン（10件）
   - TC-CICD-001 ~ TC-CICD-006（正常系）
   - TC-CICD-ERR-001 ~ TC-CICD-ERR-004（異常系）

2. **Phase 2（高優先度）**: 対戦履歴API統合（6件）
   - TC-INT-001 ~ TC-INT-002（正常系）
   - TC-INT-ERR-001 ~ TC-INT-ERR-002（異常系）
   - TC-INT-BOUND-001 ~ TC-INT-BOUND-002（境界値）

3. **Phase 3（中優先度）**: 統計API統合（3件）、インポートAPI統合（4件）
   - TC-INT-STATS-001 ~ TC-INT-STATS-ERR-001
   - TC-INT-IMPORT-001 ~ TC-INT-IMPORT-ERR-002

4. **Phase 4（推奨）**: ヘルスチェック（2件）、エッジケース（3件）
   - TC-HEALTH-001 ~ TC-HEALTH-002
   - TC-EDGE-001 ~ TC-EDGE-003

---

## 9. 品質判定

### ✅ 高品質: テストケース定義完了

#### テストケース分類
- ✅ **正常系**: 14件（API連携、CI/CDパイプライン、ヘルスチェック）
- ✅ **異常系**: 9件（エラーハンドリング、バリデーション、失敗時の動作）
- ✅ **境界値**: 2件（ページネーション、日付範囲）
- ✅ **エッジケース**: 3件（ネットワーク障害、並列処理、大量データ）

#### 期待値定義
- ✅ すべてのテストケースに具体的な入力値と期待される結果を明記
- ✅ レスポンス形式、エラーメッセージ、ステータスコードを詳細に定義
- ✅ 計算ロジック（統計、勝率）の期待値を数値で明示

#### 技術選択
- ✅ **プログラミング言語**: TypeScript 5.7+（既存実装との一貫性）
- ✅ **テストフレームワーク**: Jest 29.7.0 + ts-jest（既存テストと同一）
- ✅ **CI/CD**: GitHub Actions（既存設定の拡張）
- ✅ **実行環境**: Node.js 22.x LTS

#### 実装可能性
- ✅ 既存のUnit Test（109 passed）のパターンを統合テストに適用可能
- ✅ 既存のモック実装（BlobStorageClient）を再利用可能
- ✅ 既存のCI/CD設定（backend-deploy.yml）を拡張可能
- ✅ Jest設定（jest.config.js）にカバレッジ基準が既に設定済み

#### 要件との対応
- ✅ **NFR-302**: TDD適用（すべてのテストケースが先に定義されている）
- ✅ **NFR-303**: ゼロ警告ポリシー（TC-CICD-001でチェック）
- ✅ **NFR-304**: Unit/E2Eテスト実装（統合テスト、CI/CDテスト）
- ✅ **NFR-305**: GitHub Actions自動テスト・デプロイ（TC-CICD-006）

### 評価コメント

- すべての要件がNFR-302, NFR-303, NFR-304, NFR-305に準拠している ✅
- 既存の実装（TASK-0007~0012）を統合するテストとして適切 ✅
- CI/CDパイプラインの構成が明確で実装可能 ✅
- カバレッジ目標（70%）を達成できる十分なテストケース数（28件） ✅
- エラーケースとエッジケースが網羅的に定義されている ✅
- 既存テストパターンとの一貫性が保たれている ✅

---

## 10. 次のステップ

### 推奨される実装順序

1. **Phase 1: CI/CDパイプライン設定** ⭐ 最優先
   - `.github/workflows/backend-ci.yml` の作成
   - package.json スクリプト追加（`test:integration`, `test:unit`, `test:all`）
   - Jest設定更新（カバレッジ基準70%）

2. **Phase 2: 統合テストファイル作成**
   - `backend/tests/integration/` ディレクトリ作成
   - `api-battle-log.test.ts` 作成（TC-INT-001 ~ TC-INT-BOUND-002）
   - `api-statistics.test.ts` 作成（TC-INT-STATS-001 ~ TC-INT-STATS-ERR-001）
   - `api-import.test.ts` 作成（TC-INT-IMPORT-001 ~ TC-INT-IMPORT-ERR-002）

3. **Phase 3: ヘルスチェックエンドポイント作成**
   - `backend/src/functions/health.ts` 作成
   - `backend/tests/functions/health.test.ts` 作成（TC-HEALTH-001 ~ TC-HEALTH-002）

4. **Phase 4: エッジケーステスト作成**
   - `backend/tests/integration/edge-cases.test.ts` 作成（TC-EDGE-001 ~ TC-EDGE-003）

5. **Phase 5: ローカル実行とCI/CD検証**
   - ローカルでの統合テスト実行確認
   - GitHub ActionsでのCI/CDパイプライン動作確認
   - カバレッジ70%達成確認

### 次のお勧めコマンド

```bash
/tsumiki:tdd-red
```

このコマンドで、Redフェーズ（失敗するテストケース作成）を開始し、TDDサイクルに沿って実装を進めます。

---

## 参考資料

- **要件定義書**: `docs/implements/Shadowverse Battle Log - 対戦履歴管理システム/TASK-0013/Shadowverse Battle Log - 対戦履歴管理システム-requirements.md`
- **技術スタック定義**: `docs/tech-stack.md`
- **既存テスト**: `backend/tests/**/*.test.ts`
- **Jest設定**: `backend/jest.config.js`
- **既存CI/CD設定**: `.github/workflows/backend-deploy.yml`
