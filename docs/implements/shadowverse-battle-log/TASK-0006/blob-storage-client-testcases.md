# TDD テストケース一覧: Blob Storage クライアント実装

**機能名**: BlobStorageClient (Azure Blob Storage アクセスクライアント)
**タスクID**: TASK-0006
**作成日**: 2025-10-27
**更新日**: 2025-10-27

---

## 開発言語・フレームワーク

### 🔵 プログラミング言語: TypeScript 5.7+

**言語選択の理由**:
- プロジェクト全体がTypeScriptで統一されている
- 型安全性による実行時エラーの削減
- Azure Storage Blob SDK (@azure/storage-blob) が TypeScript で実装されている
- strict mode による高品質なコード保証

**テストに適した機能**:
- 型推論によるテストコードの補完
- async/await による非同期テストの簡潔な記述
- インターフェースによるモック作成の容易性

### 🔵 テストフレームワーク: Jest 29.7.0 + ts-jest

**フレームワーク選択の理由**:
- プロジェクトに既にJest 29.7.0がインストール済み (`backend/package.json`)
- TypeScript との統合に優れている (ts-jest)
- 豊富なマッチャー機能 (expect API)
- モック機能が強力 (jest.mock, jest.spyOn)
- 非同期テストのサポートが充実
- カバレッジレポート機能内蔵

**テスト実行環境**:
- Node.js 22.x LTS
- テストディレクトリ: `backend/tests/` または `backend/src/__tests__/`
- 実行コマンド: `npm test` (jest), `npm run test:coverage` (カバレッジ付き)

**必要な追加パッケージ**:
```json
{
  "devDependencies": {
    "@types/jest": "^29.5.0",
    "ts-jest": "^29.2.0"
  }
}
```

---

## テストケース分類サマリー

| 分類 | テストケース数 | 信頼性レベル |
|------|---------------|-------------|
| **正常系** | 6件 | 🔵 90%, 🟡 10% |
| **異常系** | 7件 | 🔵 85%, 🟡 15% |
| **境界値** | 5件 | 🔵 80%, 🟡 20% |
| **統合** | 2件 | 🟡 100% |
| **合計** | **20件** | 🔵 85%, 🟡 15% |

---

## 1. 正常系テストケース（基本的な動作）

### TC-001: コンストラクタが正常にインスタンスを生成できる

- **テスト名**: 正常な接続文字列とコンテナ名でBlobStorageClientインスタンスを生成できる
  - **何をテストするか**: コンストラクタが有効なパラメータを受け取り、正常にインスタンスを初期化できることを確認
  - **期待される動作**: BlobServiceClient と ContainerClient が正しく初期化され、例外が発生しない

- **入力値**:
  - `connectionString`: `"DefaultEndpointsProtocol=https;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;"`
  - `containerName`: `"shadowverse-data"`
  - **入力データの意味**: Azure Storage Emulator (Azurite) のデフォルト接続文字列を使用し、本番環境と同じ構造でテスト可能

- **期待される結果**:
  - インスタンスが正常に生成される
  - `containerClient` プロパティが初期化される
  - エラーや例外が発生しない
  - **期待結果の理由**: 有効な接続文字列とコンテナ名が提供されているため、初期化は成功すべき

- **テストの目的**: 基本的なインスタンス化が正常に動作することを確認
  - **確認ポイント**: コンストラクタのパラメータ受け取りと内部初期化処理

- 🔵 **信頼性レベル**: 青信号（REQ-602, architecture.md Lines 205-234 より）

---

### TC-002: getBattleLogs() で対戦履歴を正常に取得できる

- **テスト名**: Blob Storageから対戦履歴データ（BattleLog[]）を正常に取得できる
  - **何をテストするか**: `getBattleLogs()` メソッドが Blob Storage から JSON データをダウンロードし、TypeScript 型に変換して返すことを確認
  - **期待される動作**: `battle-logs.json` が読み込まれ、`BattleLog[]` 型の配列として返却される

- **入力値**: なし（メソッドはパラメータを取らない）
  - **入力データの意味**: Blob Storage 上に既に `battle-logs.json` が存在する前提

- **期待される結果**:
  - `Promise<BattleLog[]>` が返却される
  - 配列の各要素が `BattleLog` 型に準拠している
  - 日付形式が `YYYY/MM/DD` である
  - **期待結果の理由**: REQ-601 (既存データ互換性) により、既存のJSON形式と互換性を保つ必要がある

- **テストの目的**: JSON ファイルの読み込みと型変換が正常に機能することを確認
  - **確認ポイント**:
    - Blob Storage SDK の `download()` メソッドが呼ばれる
    - `streamToString()` で文字列に変換される
    - `JSON.parse()` でパースされる
    - 型アサーションが正しく機能する

- 🔵 **信頼性レベル**: 青信号（REQ-602, blob-storage-design.md Lines 66-103 より）

---

### TC-003: getDeckMasters() でデッキマスターデータを正常に取得できる

- **テスト名**: Blob Storageからデッキマスターデータ（DeckMaster[]）を正常に取得できる
  - **何をテストするか**: `getDeckMasters()` メソッドが `deck-master.json` を読み込み、`DeckMaster[]` 型として返すことを確認
  - **期待される動作**: デッキマスターのマスターデータが正しく取得される

- **入力値**: なし
  - **入力データの意味**: `deck-master.json` はシステム共通のマスターデータファイル

- **期待される結果**:
  - `Promise<DeckMaster[]>` が返却される
  - 各要素が `id`, `className`, `deckName`, `sortOrder` プロパティを持つ
  - **期待結果の理由**: デッキマスターは必須のマスターデータであり、常に存在することが期待される

- **テストの目的**: 複数のJSONファイルに対して同じ読み込みロジックが機能することを確認
  - **確認ポイント**: `readJsonFile<DeckMaster[]>('deck-master.json')` が正しく呼ばれる

- 🔵 **信頼性レベル**: 青信号（blob-storage-design.md Lines 116-131 より）

---

### TC-004: getMyDecks() でマイデッキデータを正常に取得できる

- **テスト名**: Blob Storageからマイデッキデータ（MyDeck[]）を正常に取得できる
  - **何をテストするか**: `getMyDecks()` メソッドが `my-decks.json` を読み込み、`MyDeck[]` 型として返すことを確認
  - **期待される動作**: ユーザーが登録したマイデッキ情報が取得される

- **入力値**: なし
  - **入力データの意味**: `my-decks.json` はユーザー固有のデータファイル（Phase 1では全ユーザー共通）

- **期待される結果**:
  - `Promise<MyDeck[]>` が返却される
  - 各要素が `id`, `deckId`, `deckCode`, `deckName`, `isActive`, `createdAt` プロパティを持つ
  - `createdAt` が ISO 8601 形式の文字列である
  - **期待結果の理由**: MyDeck の型定義に準拠したデータが返される必要がある

- **テストの目的**: ユーザー固有データの取得が正常に動作することを確認
  - **確認ポイント**: 空配列の場合も正常に処理される（ユーザーが未登録の場合）

- 🔵 **信頼性レベル**: 青信号（blob-storage-design.md Lines 150-161 より）

---

### TC-005: saveBattleLogs() で対戦履歴を正常に保存できる

- **テスト名**: BattleLog[] 配列を Blob Storage に JSON 形式で正常に保存できる
  - **何をテストするか**: `saveBattleLogs()` メソッドが配列を JSON にシリアライズし、Blob Storage にアップロードできることを確認
  - **期待される動作**: データが `battle-logs.json` として保存され、Content-Type ヘッダーが `application/json` に設定される

- **入力値**:
  ```typescript
  const battleLogs: BattleLog[] = [
    {
      id: '1',
      date: '2025/10/27',
      battleType: 'ランクマッチ',
      rank: 'ダイアモンド',
      group: 'A',
      myDeckId: '1',
      turn: '先攻',
      result: '勝ち',
      opponentDeckId: '2',
    }
  ];
  ```
  - **入力データの意味**: 1件の対戦履歴を持つ配列（最小限の有効なデータ）

- **期待される結果**:
  - `Promise<void>` が正常に resolve される
  - Blob Storage SDK の `upload()` メソッドが呼ばれる
  - JSON が整形されている（`JSON.stringify(data, null, 2)`）
  - HTTP ヘッダーに `blobContentType: 'application/json'` が含まれる
  - **期待結果の理由**: REQ-602 により JSON 形式での保存が必須

- **テストの目的**: データの書き込みが正常に機能することを確認
  - **確認ポイント**:
    - JSON シリアライズが正しく行われる
    - Blob Storage への upload が成功する
    - エラーなく完了する

- 🔵 **信頼性レベル**: 青信号（REQ-602, blob-storage-design.md Lines 190-208 より）

---

### TC-006: saveMyDecks() でマイデッキを正常に保存できる

- **テスト名**: MyDeck[] 配列を Blob Storage に JSON 形式で正常に保存できる
  - **何をテストするか**: `saveMyDecks()` メソッドが MyDeck 配列を保存できることを確認
  - **期待される動作**: `my-decks.json` としてデータが保存される

- **入力値**:
  ```typescript
  const myDecks: MyDeck[] = [
    {
      id: '1',
      deckId: '1',
      deckCode: '3.1.3.1.3.1...',
      deckName: '秘術オデンスペル',
      isActive: true,
      createdAt: '2024-01-01T00:00:00.000Z',
    }
  ];
  ```
  - **入力データの意味**: 1件のマイデッキデータ

- **期待される結果**:
  - `Promise<void>` が正常に resolve される
  - `writeJsonFile('my-decks.json', myDecks)` が呼ばれる
  - **期待結果の理由**: `saveBattleLogs()` と同様のロジックで動作すべき

- **テストの目的**: 複数のファイルに対して書き込みロジックが共通化されていることを確認
  - **確認ポイント**: `writeJsonFile()` の汎用性

- 🟡 **信頼性レベル**: 黄信号（blob-storage-design.md からの妥当な推測）

---

## 2. 異常系テストケース（エラーハンドリング）

### TC-101: 不正な接続文字列でエラーが発生する

- **テスト名**: 無効な接続文字列を渡した場合、適切なエラーがスローされる
  - **エラーケースの概要**: 接続文字列のフォーマットが不正な場合
  - **エラー処理の重要性**: 設定ミスを早期に検出し、デバッグを容易にする

- **入力値**:
  - `connectionString`: `"invalid_connection_string"`
  - `containerName`: `"shadowverse-data"`
  - **不正な理由**: Azure Storage の接続文字列フォーマットに準拠していない
  - **実際の発生シナリオ**: 環境変数の設定ミス、コピー&ペーストの失敗

- **期待される結果**:
  - コンストラクタまたは初回アクセス時にエラーがスローされる
  - エラーメッセージに接続文字列の不正が明記される
  - **エラーメッセージの内容**: Azure SDK の標準エラーメッセージ
  - **システムの安全性**: 不正な状態でのデータアクセスを防止

- **テストの目的**: 設定エラーの早期検出
  - **品質保証の観点**: 本番環境での設定ミスによる障害を未然に防ぐ

- 🔵 **信頼性レベル**: 青信号（NFR-102, architecture.md Lines 354-366 より）

---

### TC-102: ファイルが存在しない場合にエラーが発生する

- **テスト名**: Blob Storage にファイルが存在しない場合、BlobNotFound エラーがスローされる
  - **エラーケースの概要**: 初回アクセス時やファイル削除後のアクセス
  - **エラー処理の重要性**: ファイルの存在確認と適切なエラーハンドリング

- **入力値**: `getBattleLogs()` を呼び出すが、`battle-logs.json` が存在しない
  - **不正な理由**: ファイルが未作成または削除されている
  - **実際の発生シナリオ**: システム初回起動時、データ削除後、ストレージ障害

- **期待される結果**:
  - `BlobNotFoundError` または類似のエラーがスローされる
  - エラーメッセージにファイル名が含まれる
  - 3回のリトライは実行されない（404エラーはリトライ対象外）
  - **エラーメッセージの内容**: "Failed to read battle-logs.json: BlobNotFound"
  - **システムの安全性**: ファイル不存在を明確に通知し、適切な初期化を促す

- **テストの目的**: ファイル不存在時の適切なエラーハンドリング
  - **品質保証の観点**: ユーザーに分かりやすいエラーメッセージを提供

- 🔵 **信頼性レベル**: 青信号（EDGE-002, dataflow.md Lines 318-345 より）

---

### TC-103: ネットワークエラー時に3回リトライする

- **テスト名**: ネットワークエラー発生時、指数バックオフで3回リトライする
  - **エラーケースの概要**: 一時的なネットワーク障害、タイムアウト
  - **エラー処理の重要性**: 一時的な障害に対する耐障害性の向上

- **入力値**: `getBattleLogs()` を呼び出すが、ネットワークエラーが発生
  - **不正な理由**: ネットワーク接続の不安定性、Azure Storage の一時的な障害
  - **実際の発生シナリオ**: Wi-Fi接続の不安定、データセンター障害、タイムアウト

- **期待される結果**:
  - 1回目失敗 → 1秒待機 → 2回目実行
  - 2回目失敗 → 2秒待機 → 3回目実行
  - 3回目失敗 → 4秒待機 → 4回目実行
  - 4回目失敗 → エラーをスロー
  - エラーメッセージ: "Failed to read battle-logs.json after 3 attempts: [元のエラー]"
  - **エラーメッセージの内容**: リトライ回数と最終エラーを明記
  - **システムの安全性**: 無限ループを防ぎつつ、一時的な障害を乗り越える

- **テストの目的**: リトライ機構の動作確認
  - **品質保証の観点**: EDGE-001, EDGE-002 要件への準拠

- 🔵 **信頼性レベル**: 青信号（EDGE-001, EDGE-002, dataflow.md Lines 318-345 より）

---

### TC-104: JSON パースエラー時に適切なエラーが発生する

- **テスト名**: Blob Storage 上のファイルが不正な JSON 形式の場合、SyntaxError がスローされる
  - **エラーケースの概要**: JSON 形式の破損、手動編集ミス
  - **エラー処理の重要性**: データ整合性の保証

- **入力値**: `battle-logs.json` の内容が不正なJSON（例: `{invalid json}`）
  - **不正な理由**: JSON 構文エラー、カンマ欠落、クォート欠落
  - **実際の発生シナリオ**: 手動編集ミス、データ破損、アップロードエラー

- **期待される結果**:
  - `SyntaxError` がスローされる
  - エラーメッセージに JSON パースエラーが明記される
  - リトライは実行されない（パースエラーは再試行しても解決しない）
  - **エラーメッセージの内容**: "Unexpected token ..." (標準 JSON.parse エラー)
  - **システムの安全性**: 不正なデータでの動作を防止

- **テストの目的**: データ整合性チェックの動作確認
  - **品質保証の観点**: 不正なデータによるシステム障害を防ぐ

- 🟡 **信頼性レベル**: 黄信号（エラーハンドリング要件からの妥当な推測）

---

### TC-105: 認証エラー時に即座にエラーが発生する（リトライしない）

- **テスト名**: 認証エラー (401 Unauthorized) の場合、リトライせず即座にエラーをスローする
  - **エラーケースの概要**: 接続文字列の認証情報が不正
  - **エラー処理の重要性**: リトライしても解決しないエラーの早期検出

- **入力値**: 不正な AccountKey を含む接続文字列
  - **不正な理由**: AccountKey が期限切れまたは誤っている
  - **実際の発生シナリオ**: キーのローテーション後の更新漏れ、設定ミス

- **期待される結果**:
  - 1回目のアクセスで即座にエラーがスローされる
  - リトライは実行されない（認証エラーはリトライ対象外）
  - エラーメッセージに認証失敗が明記される
  - **エラーメッセージの内容**: "Unauthorized: Invalid account key"
  - **システムの安全性**: 無駄なリトライを避け、素早くエラーを通知

- **テストの目的**: 認証エラーの適切な処理
  - **品質保証の観点**: リトライすべきエラーとリトライすべきでないエラーの区別

- 🟡 **信頼性レベル**: 黄信号（エラーハンドリング要件からの妥当な推測）

---

### TC-106: 権限エラー時に即座にエラーが発生する（リトライしない）

- **テスト名**: 権限エラー (403 Forbidden) の場合、リトライせず即座にエラーをスローする
  - **エラーケースの概要**: コンテナへのアクセス権限がない
  - **エラー処理の重要性**: 権限設定の不備を早期に検出

- **入力値**: 読み取り権限のない接続文字列
  - **不正な理由**: SAS Token の権限不足、IAM ロールの設定ミス
  - **実際の発生シナリオ**: 権限設定の誤り、SAS Token の期限切れ

- **期待される結果**:
  - 1回目のアクセスで即座にエラーがスローされる
  - リトライは実行されない
  - **エラーメッセージの内容**: "Forbidden: Insufficient permissions"
  - **システムの安全性**: セキュリティ設定の不備を明確に通知

- **テストの目的**: 権限エラーの適切な処理
  - **品質保証の観点**: NFR-102 (セキュリティ要件) への準拠

- 🟡 **信頼性レベル**: 黄信号（セキュリティ要件からの妥当な推測）

---

### TC-107: タイムアウトエラー時にリトライする

- **テスト名**: タイムアウトエラー発生時、指数バックオフでリトライする
  - **エラーケースの概要**: ネットワーク遅延、サーバー負荷による応答遅延
  - **エラー処理の重要性**: 一時的な遅延に対する耐障害性

- **入力値**: `getBattleLogs()` を呼び出すが、タイムアウトが発生
  - **不正な理由**: ネットワーク遅延、Blob Storage の高負荷
  - **実際の発生シナリオ**: 大きなファイルのダウンロード、サーバー負荷

- **期待される結果**:
  - ネットワークエラーと同様に3回リトライする
  - 指数バックオフが適用される
  - **エラーメッセージの内容**: "Failed to read battle-logs.json after 3 attempts: Timeout"
  - **システムの安全性**: タイムアウト時も適切にリトライし、ユーザー体験を向上

- **テストの目的**: タイムアウト時のリトライ機構の確認
  - **品質保証の観点**: NFR-001 (レスポンス時間3秒以内) への対応

- 🔵 **信頼性レベル**: 青信号（EDGE-001, NFR-001 より）

---

## 3. 境界値テストケース（最小値、最大値、null等）

### TC-201: 空配列の対戦履歴を取得できる

- **テスト名**: `battle-logs.json` が空配列 `[]` の場合、正常に空配列を返す
  - **境界値の意味**: データ件数がゼロの状態（最小値）
  - **境界値での動作保証**: 空データでもエラーにならないことを保証

- **入力値**: `battle-logs.json` の内容が `[]`
  - **境界値選択の根拠**: データ削除後、初回利用時の状態
  - **実際の使用場面**: ユーザーがすべてのデータを削除した場合

- **期待される結果**:
  - `Promise<BattleLog[]>` が resolve される
  - `battleLogs.length === 0` である
  - エラーが発生しない
  - **境界での正確性**: 空配列でも型は `BattleLog[]` として正しく扱われる
  - **一貫した動作**: 空でないデータと同じ処理フローで扱われる

- **テストの目的**: 最小データ量（ゼロ件）での動作確認
  - **堅牢性の確認**: エッジケースでの安定動作

- 🔵 **信頼性レベル**: 青信号（REQ-501, requirements.md Line 82 より）

---

### TC-202: 大量データ（1,000件）を正常に取得できる

- **テスト名**: `battle-logs.json` に1,000件のデータがある場合、3秒以内に取得できる
  - **境界値の意味**: NFR-003 で定義された想定データ量上限
  - **境界値での動作保証**: 上限付近でもパフォーマンス要件を満たす

- **入力値**: 1,000件の BattleLog データ（約300KB）
  - **境界値選択の根拠**: NFR-003 (データ量上限1,000件/300KB)
  - **実際の使用場面**: ヘビーユーザーが1年間使用した場合

- **期待される結果**:
  - `Promise<BattleLog[]>` が正常に返される
  - `battleLogs.length === 1000` である
  - レスポンス時間が3秒以内（NFR-001）
  - メモリエラーが発生しない
  - **境界での正確性**: すべてのデータが正しくパースされる
  - **一貫した動作**: 少量データと同じ処理フローで扱われる

- **テストの目的**: 想定最大データ量でのパフォーマンス確認
  - **堅牢性の確認**: NFR-001, NFR-003 への準拠

- 🔵 **信頼性レベル**: 青信号（NFR-001, NFR-003 より）

---

### TC-203: 極端に大きなデータ（10,000件）でエラーハンドリングが機能する

- **テスト名**: `battle-logs.json` に10,000件のデータがある場合の動作を確認
  - **境界値の意味**: EDGE-102 で定義された境界値上限
  - **境界値での動作保証**: 想定外の大量データでも動作またはエラーを返す

- **入力値**: 10,000件の BattleLog データ（約3MB）
  - **境界値選択の根拠**: EDGE-102 (10,000件の境界値テスト)
  - **実際の使用場面**: 長期間使用、データインポートによる大量登録

- **期待される結果**:
  - データ取得は成功する（エラーにならない）
  - レスポンス時間は3秒を超える可能性がある（NFR-001の範囲外）
  - メモリ使用量が許容範囲内（約10MB以下）
  - **境界での正確性**: データは正しくパースされる
  - **一貫した動作**: 警告ログなどで大量データを通知する（実装次第）

- **テストの目的**: 境界値を超えた場合の動作確認
  - **堅牢性の確認**: システムがクラッシュせず、適切に処理またはエラーを返す

- 🔵 **信頼性レベル**: 青信号（EDGE-102 より）

---

### TC-204: 空文字列のコンテナ名でエラーが発生する

- **テスト名**: コンテナ名が空文字列 `""` の場合、エラーがスローされる
  - **境界値の意味**: 最小文字数（ゼロ文字）
  - **境界値での動作保証**: 不正な入力を拒否する

- **入力値**:
  - `connectionString`: 正常な接続文字列
  - `containerName`: `""`
  - **境界値選択の根拠**: Azure Blob Storage の命名規則（3-63文字）
  - **実際の使用場面**: 設定ミス、環境変数の未設定

- **期待される結果**:
  - コンストラクタまたは初回アクセス時にエラーがスローされる
  - エラーメッセージにコンテナ名の不正が明記される
  - **境界での正確性**: 不正な入力を明確に拒否
  - **一貫した動作**: 他のバリデーションエラーと同じ方法で処理

- **テストの目的**: コンテナ名のバリデーション確認
  - **堅牢性の確認**: 不正な設定での動作を防止

- 🟡 **信頼性レベル**: 黄信号（Azure 命名規則からの妥当な推測）

---

### TC-205: nullまたはundefinedの入力でTypeScriptエラーが発生する

- **テスト名**: `saveBattleLogs(null)` や `saveBattleLogs(undefined)` が TypeScript コンパイルエラーになる
  - **境界値の意味**: null/undefined の扱い
  - **境界値での動作保証**: TypeScript の型システムによる静的検証

- **入力値**:
  - `saveBattleLogs(null as any)` （型アサーションで強制）
  - `saveBattleLogs(undefined as any)`
  - **境界値選択の根拠**: 型安全性の確認
  - **実際の使用場面**: JavaScriptからの呼び出し、型の不一致

- **期待される結果**:
  - TypeScript strict mode でコンパイルエラーが発生する
  - 実行時にエラーがスローされる（型アサーションで強制した場合）
  - **境界での正確性**: null/undefined を受け付けない
  - **一貫した動作**: TypeScript の型システムによる保護

- **テストの目的**: 型安全性の確認
  - **堅牢性の確認**: NFR-103 (入力バリデーション) への準拠

- 🔵 **信頼性レベル**: 青信号（NFR-103, TypeScript strict mode より）

---

## 4. 統合テストケース（実際のAzure Storage使用）

### TC-301: Azure Storage Emulator (Azurite) を使用した統合テスト

- **テスト名**: 実際の Azurite を使用してデータの読み書きが正常に動作する
  - **何をテストするか**: 実際の Blob Storage SDK との統合動作
  - **期待される動作**: ローカル環境で本番と同じ動作を確認

- **入力値**:
  - Azurite の接続文字列
  - テストデータ（BattleLog[], DeckMaster[], MyDeck[]）
  - **入力データの意味**: 本番環境と同等の構成でテスト

- **期待される結果**:
  - データの書き込み → 読み込みが成功する
  - JSON 形式が正しく保持される
  - Content-Type ヘッダーが正しく設定される
  - **期待結果の理由**: 実際の Blob Storage との互換性を保証

- **テストの目的**: 実環境での動作確認
  - **確認ポイント**: モックではなく実際の SDK を使用した動作

- 🟡 **信頼性レベル**: 黄信号（統合テストは環境依存のため）

---

### TC-302: 並行アクセス時の動作確認（Last Write Wins）

- **テスト名**: 複数のクライアントが同時にデータを書き込む場合、Last Write Wins で動作する
  - **何をテストするか**: Phase 1 の並行制御戦略（楽観的ロックなし）
  - **期待される動作**: 最後の書き込みが反映される

- **入力値**:
  - 2つの BlobStorageClient インスタンス
  - 異なる BattleLog データ
  - **入力データの意味**: 並行アクセスのシミュレーション

- **期待される結果**:
  - 両方の書き込みが成功する
  - 最後の書き込み内容がファイルに反映される
  - データの上書きが発生する（意図的な動作）
  - **期待結果の理由**: Phase 1 では楽観的ロック未実装（blob-storage-design.md Lines 235-247）

- **テストの目的**: 並行制御戦略の動作確認
  - **確認ポイント**: NFR-002 (同時実行ユーザー数10人以下) での動作

- 🟡 **信頼性レベル**: 黄信号（blob-storage-design.md Lines 235-247 からの妥当な推測）

---

## 5. テストケース実装ガイドライン

### モック戦略

```typescript
// Azure Storage Blob SDK のモック例
jest.mock('@azure/storage-blob', () => ({
  BlobServiceClient: {
    fromConnectionString: jest.fn().mockReturnValue({
      getContainerClient: jest.fn().mockReturnValue({
        getBlobClient: jest.fn(),
        getBlockBlobClient: jest.fn(),
      }),
    }),
  },
}));
```

### テストデータ準備

```typescript
// モックデータ定義
const mockBattleLogs: BattleLog[] = [
  {
    id: '1',
    date: '2025/10/27',
    battleType: 'ランクマッチ',
    rank: 'ダイアモンド',
    group: 'A',
    myDeckId: '1',
    turn: '先攻',
    result: '勝ち',
    opponentDeckId: '2',
  },
];
```

### 非同期テストの記述

```typescript
// 非同期テストの例
it('getBattleLogs() で対戦履歴を取得できる', async () => {
  // 【テスト目的】: Blob Storage からデータを正常に取得できることを確認
  // 【テスト内容】: getBattleLogs() メソッドを呼び出し、BattleLog[] が返却されることを検証
  // 【期待される動作】: Promise が resolve され、配列が返却される

  // Given: BlobStorageClient インスタンスを準備
  const client = new BlobStorageClient(connectionString, containerName);

  // When: getBattleLogs() を実行
  const result = await client.getBattleLogs();

  // Then: 結果が BattleLog[] 型である
  expect(Array.isArray(result)).toBe(true); // 【検証項目】: 配列が返却される
  expect(result.length).toBeGreaterThanOrEqual(0); // 【検証項目】: 空配列を含む有効な配列
});
```

---

## 6. カバレッジ目標

| 対象 | 目標カバレッジ | 理由 |
|------|---------------|------|
| **行カバレッジ** | 90%以上 | すべての処理が実行されることを保証 |
| **分岐カバレッジ** | 85%以上 | if/else, try/catch の全分岐をテスト |
| **関数カバレッジ** | 100% | すべてのpublicメソッドがテストされる |
| **条件カバレッジ** | 80%以上 | 論理演算子の組み合わせをテスト |

---

## 7. 品質判定

### ✅ 高品質: テストケース実装可能

- **テストケース分類**: 正常系(6)・異常系(7)・境界値(5)・統合(2) = 合計20件で網羅されている
- **期待値定義**: 各テストケースの期待値が明確に記述されている
- **技術選択**: TypeScript 5.7+ + Jest 29.7.0 + ts-jest で確定
- **実装可能性**: 現在の技術スタックで実現可能（追加パッケージ: @types/jest, ts-jest のみ）
- **要件カバレッジ**: REQ-601, REQ-602, EDGE-001, EDGE-002, NFR-001〜103 をカバー
- **信頼性レベル**: 🔵 85%, 🟡 15% （高信頼性）

---

## 8. 次のステップ

✅ **テストケース洗い出し完了**

次のお勧めステップ: `/tsumiki:tdd-red` でRedフェーズ（失敗テスト作成）を開始します。

---

**作成日**: 2025-10-27
**更新日**: 2025-10-27
**ステータス**: ✅ 完了
