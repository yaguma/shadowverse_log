# TDDテストケース定義: Battle Log一覧画面実装

**タスクID**: TASK-0017
**タスク名**: Battle Log一覧画面実装
**作成日**: 2025-11-08
**ステータス**: テストケース定義完了

---

## 開発言語・テストフレームワーク

- **プログラミング言語**: TypeScript 5.7+
  - **言語選択の理由**: 型安全性の確保、React 19.xとの親和性が高い、プロジェクト標準
  - **テストに適した機能**: 厳密な型チェック（strict mode）により、実行前に多くのエラーを検出可能
- **テストフレームワーク**: Vitest 2.0+
  - **フレームワーク選択の理由**: Vite環境で高速動作、Jestライクな記法で学習コスト低い、プロジェクト標準
  - **テスト実行環境**: happy-dom（軽量なDOM実装）、@testing-library/react（React コンポーネントテスト）
- 🔵 信頼性レベル: プロジェクトのtech-stack.mdおよびvitest.config.tsから確定

---

## テストケース分類

### テスト対象コンポーネント一覧

1. **BattleLogListPage** - ページコンテナコンポーネント（ヘッダー、フォームトリガー、一覧表示の統合）
2. **BattleLogList** - テーブル形式の一覧表示コンポーネント（ソート、削除、詳細ボタン）
3. **DeleteConfirmDialog** - 削除確認モーダルコンポーネント
4. **DetailModal** - 詳細表示モーダルコンポーネント（🟡 実装判断待ち）
5. **統合テスト** - Zustand Store との連携

---

## 1. 正常系テストケース（基本的な動作）

### 1.1 BattleLogListPageコンポーネント

#### TC-LIST-PAGE-001: ページが正しく初期表示される

- **テスト名**: ページ初期表示テスト
  - **何をテストするか**: BattleLogListPageコンポーネントが初回マウント時に正しくレンダリングされること
  - **期待される動作**: ページタイトル、新規登録ボタン、一覧表示エリアが表示される
- **入力値**: なし（ルーティングされたページコンポーネント）
  - **入力データの意味**: ページコンポーネントのため、propsなし
- **期待される結果**:
  - ページタイトル "対戦履歴一覧" が表示される
  - "新規登録" ボタンが表示される
  - fetchBattleLogs() が自動実行される（useEffect経由）
  - **期待結果の理由**: 初回ロード時にデータ取得を自動実行することで、ユーザーがすぐに対戦履歴を確認できる
- **テストの目的**: ページコンポーネントの基本構造を確認
  - **確認ポイント**: ページタイトル、新規登録ボタン、一覧エリアの存在確認
- 🔵 信頼性レベル: 要件定義書REQ-009に基づく

#### TC-LIST-PAGE-002: 初回ロード時にfetchBattleLogs()が呼ばれる

- **テスト名**: 初回データ取得テスト
  - **何をテストするか**: ページマウント時にZustand StoreのfetchBattleLogs()が自動実行されること
  - **期待される動作**: useEffect内でfetchBattleLogs()が1回だけ呼ばれる
- **入力値**: なし
  - **入力データの意味**: マウントトリガー（useEffect依存配列が空配列）
- **期待される結果**:
  - fetchBattleLogs()が1回だけ呼ばれる
  - isLoading = true → false に遷移する
  - **期待結果の理由**: 初回ロード時のみデータ取得を実行し、不要な再取得を防ぐ
- **テストの目的**: 初回データ取得の自動実行を確認
  - **確認ポイント**: fetchBattleLogs()の呼び出し回数、タイミング
- 🔵 信頼性レベル: データフロー図に基づく

#### TC-LIST-PAGE-003: 新規登録ボタンクリックでBattleLogFormが表示される

- **テスト名**: 新規登録フォーム表示トリガーテスト
  - **何をテストするか**: "新規登録" ボタンクリック時にBattleLogFormコンポーネントがモーダルで表示されること
  - **期待される動作**: ローカル状態（isFormOpen）がtrueになり、BattleLogFormコンポーネントが描画される
- **入力値**: ボタンクリックイベント
  - **入力データの意味**: ユーザーが新規登録を開始するトリガー
- **期待される結果**:
  - BattleLogFormコンポーネントが表示される
  - モーダルの背景が表示される
  - **期待結果の理由**: ユーザーが新規対戦履歴を登録できる状態になる
- **テストの目的**: フォーム表示トリガーの動作確認
  - **確認ポイント**: BattleLogFormの存在確認、モーダル表示状態
- 🔵 信頼性レベル: データフロー図に基づく

#### TC-LIST-PAGE-004: BattleLogForm送信成功後にフォームが閉じる

- **テスト名**: フォーム送信成功時のクローズテスト
  - **何をテストするか**: BattleLogFormの送信成功後にonSuccessコールバックが呼ばれ、フォームがクローズされること
  - **期待される動作**: isFormOpen = false となり、BattleLogFormが非表示になる
- **入力値**: onSuccessコールバック呼び出し
  - **入力データの意味**: フォーム送信成功の通知
- **期待される結果**:
  - BattleLogFormコンポーネントが非表示になる
  - モーダルの背景が消える
  - 一覧が最新状態に更新される（fetchBattleLogs()が自動実行される）
  - **期待結果の理由**: 登録完了後にユーザーが一覧画面に戻り、最新データを確認できる
- **テストの目的**: フォーム送信成功時のUI状態遷移を確認
  - **確認ポイント**: BattleLogFormの非表示、一覧の更新
- 🔵 信頼性レベル: データフロー図に基づく

### 1.2 BattleLogListコンポーネント

#### TC-LIST-001: 対戦履歴一覧が正しく表示される（3件）

- **テスト名**: 一覧表示テスト（正常系）
  - **何をテストするか**: BattleLogListコンポーネントが対戦履歴一覧を正しくテーブル形式で表示すること
  - **期待される動作**: 3件の対戦履歴が日付降順でテーブルに表示される
- **入力値**: battleLogs（3件のモックデータ）
  - **入力データの意味**: Zustand Storeから取得した対戦履歴一覧
  - **モックデータ**:
    ```typescript
    [
      { id: 'log_20251108_001', date: '2025/11/08', battleType: 'ランクマッチ', rank: 'ダイアモンド', group: 'AAA', myDeckId: 'deck-001', myDeckName: 'テストデッキ1', turn: '先攻', result: '勝ち', opponentDeckId: 'deck-master-001', opponentDeckName: '相手デッキ1' },
      { id: 'log_20251107_001', date: '2025/11/07', battleType: 'ランクマッチ', rank: 'ダイアモンド', group: 'AA', myDeckId: 'deck-002', myDeckName: 'テストデッキ2', turn: '後攻', result: '負け', opponentDeckId: 'deck-master-002', opponentDeckName: '相手デッキ2' },
      { id: 'log_20251106_001', date: '2025/11/06', battleType: '対戦台', rank: '-', group: '-', myDeckId: 'deck-001', myDeckName: 'テストデッキ1', turn: '先攻', result: '勝ち', opponentDeckId: 'deck-master-003', opponentDeckName: '相手デッキ3' }
    ]
    ```
- **期待される結果**:
  - テーブルに3行のデータが表示される
  - ヘッダー行（対戦日、対戦タイプ、ランク、グループ、使用デッキ、先攻後攻、対戦結果、相手デッキ、アクション）が表示される
  - 各行に「詳細」「削除」ボタンが表示される
  - 日付が降順（最新順）で表示される
  - **期待結果の理由**: ユーザーが最新の対戦履歴を最初に確認できる
- **テストの目的**: 一覧表示の基本機能を確認
  - **確認ポイント**: テーブル行数、列の内容、ボタンの存在確認
- 🔵 信頼性レベル: 要件定義書REQ-009、REQ-103に基づく

#### TC-LIST-002: 日付降順ソートが動作する

- **テスト名**: 日付降順ソートテスト
  - **何をテストするか**: 対戦履歴が日付降順（最新順）でソートされて表示されること
  - **期待される動作**: 最新の対戦履歴が最上位に表示される
- **入力値**: battleLogs（日付がバラバラの3件のモックデータ）
  - **入力データの意味**: 日付順序が入れ替わったデータ（バックエンドAPIから日付降順で返される前提）
- **期待される結果**:
  - 1行目: 2025/11/08
  - 2行目: 2025/11/07
  - 3行目: 2025/11/06
  - **期待結果の理由**: 最新の対戦履歴を優先的に表示し、ユーザーの利便性を向上
- **テストの目的**: ソート機能の動作確認
  - **確認ポイント**: テーブルの1行目〜3行目の日付順序
- 🔵 信頼性レベル: 要件定義書REQ-103に基づく

#### TC-LIST-003: デッキ名が正しく表示される（IDではなく名前）

- **テスト名**: デッキ名表示テスト
  - **何をテストするか**: マイデッキと相手デッキがID（deck-001等）ではなく、人間が読める名前（"テストデッキ1"等）で表示されること
  - **期待される動作**: Backend APIでJOINされたデッキ名が表示される
- **入力値**: battleLogs（myDeckName, opponentDeckName を含むデータ）
  - **入力データの意味**: Backend APIでデッキマスターテーブルとJOINされた結果
- **期待される結果**:
  - 使用デッキ列: "テストデッキ1"（"deck-001"ではない）
  - 相手デッキ列: "相手デッキ1"（"deck-master-001"ではない）
  - **期待結果の理由**: ユーザーがデッキ名を直感的に理解できる
- **テストの目的**: デッキ名表示の正確性を確認
  - **確認ポイント**: myDeckName、opponentDeckNameが表示されている
- 🔵 信頼性レベル: 要件定義書REQ-106に基づく

#### TC-LIST-004: 削除ボタンがクリック可能

- **テスト名**: 削除ボタンクリックテスト
  - **何をテストするか**: 各行の「削除」ボタンがクリック可能で、onDeleteコールバックが呼ばれること
  - **期待される動作**: ボタンクリック時にonDelete(id)が呼ばれる
- **入力値**: 削除ボタンクリックイベント
  - **入力データの意味**: ユーザーが特定の対戦履歴を削除するトリガー
- **期待される結果**:
  - onDelete('log_20251108_001') が呼ばれる
  - **期待結果の理由**: 削除確認ダイアログ表示のトリガーとして機能する
- **テストの目的**: 削除ボタンの動作確認
  - **確認ポイント**: onDeleteコールバックの呼び出し、IDの正確性
- 🔵 信頼性レベル: 要件定義書REQ-010に基づく

#### TC-LIST-005: 詳細ボタンがクリック可能

- **テスト名**: 詳細ボタンクリックテスト
  - **何をテストするか**: 各行の「詳細」ボタンがクリック可能で、onDetailコールバックが呼ばれること
  - **期待される動作**: ボタンクリック時にonDetail(log)が呼ばれる
- **入力値**: 詳細ボタンクリックイベント
  - **入力データの意味**: ユーザーが特定の対戦履歴の詳細を確認するトリガー
- **期待される結果**:
  - onDetail({ id: 'log_20251108_001', ... }) が呼ばれる
  - **期待結果の理由**: 詳細モーダル表示のトリガーとして機能する
- **テストの目的**: 詳細ボタンの動作確認
  - **確認ポイント**: onDetailコールバックの呼び出し、渡されるlog オブジェクトの正確性
- 🔵 信頼性レベル: 要件定義書REQ-011に基づく

### 1.3 DeleteConfirmDialogコンポーネント

#### TC-DELETE-DIALOG-001: 削除確認ダイアログが正しく表示される

- **テスト名**: 削除確認ダイアログ表示テスト
  - **何をテストするか**: isOpen=trueの場合、削除確認ダイアログが正しく表示されること
  - **期待される動作**: ダイアログタイトル、確認メッセージ、対象の対戦日・対戦結果、キャンセルボタン、削除するボタンが表示される
- **入力値**:
  - isOpen: true
  - targetLog: { id: 'log_20251108_001', date: '2025/11/08', result: '勝ち', ... }
  - isLoading: false
  - **入力データの意味**: 削除対象の対戦履歴が選択された状態
- **期待される結果**:
  - ダイアログタイトル: "削除確認"
  - 確認メッセージ: "本当に削除しますか？"
  - 対象情報: "2025/11/08 | 勝ち"
  - キャンセルボタン、削除するボタンが表示される
  - **期待結果の理由**: ユーザーが削除対象を確認し、誤削除を防止できる
- **テストの目的**: ダイアログの基本構造を確認
  - **確認ポイント**: ダイアログの表示、タイトル、メッセージ、ボタンの存在確認
- 🟡 信頼性レベル: 一般的なUXパターンから推測

#### TC-DELETE-DIALOG-002: キャンセルボタンでダイアログが閉じる

- **テスト名**: キャンセルボタンクリックテスト
  - **何をテストするか**: キャンセルボタンクリック時にonCancelコールバックが呼ばれること
  - **期待される動作**: onCancel()が呼ばれ、ダイアログがクローズされる
- **入力値**: キャンセルボタンクリックイベント
  - **入力データの意味**: ユーザーが削除をキャンセルするトリガー
- **期待される結果**:
  - onCancel()が1回呼ばれる
  - onConfirm()は呼ばれない（削除は実行されない）
  - **期待結果の理由**: ユーザーが削除操作を中止し、一覧画面に戻れる
- **テストの目的**: キャンセル機能の動作確認
  - **確認ポイント**: onCancelコールバックの呼び出し、onConfirmが呼ばれないこと
- 🟡 信頼性レベル: 一般的なダイアログUXから推測

#### TC-DELETE-DIALOG-003: 削除するボタンで削除が実行される

- **テスト名**: 削除実行ボタンクリックテスト
  - **何をテストするか**: 削除するボタンクリック時にonConfirmコールバックが呼ばれること
  - **期待される動作**: onConfirm()が呼ばれ、削除処理が実行される
- **入力値**: 削除するボタンクリックイベント
  - **入力データの意味**: ユーザーが削除を確定するトリガー
- **期待される結果**:
  - onConfirm()が1回呼ばれる
  - **期待結果の理由**: Zustand StoreのdeleteBattleLog()が呼ばれ、削除処理が開始される
- **テストの目的**: 削除実行機能の動作確認
  - **確認ポイント**: onConfirmコールバックの呼び出し
- 🟡 信頼性レベル: 一般的なダイアログUXから推測

#### TC-DELETE-DIALOG-004: ローディング中はボタンが無効化される

- **テスト名**: ローディング中のボタン無効化テスト
  - **何をテストするか**: isLoading=trueの場合、キャンセル・削除するボタンが無効化されること
  - **期待される動作**: ボタンがdisabled状態になり、連続クリックを防止する
- **入力値**: isLoading: true
  - **入力データの意味**: Backend APIへの削除リクエスト送信中
- **期待される結果**:
  - キャンセルボタンがdisabled
  - 削除するボタンがdisabled
  - ローディングスピナーが表示される
  - **期待結果の理由**: 削除処理中の誤操作を防止し、システムの安全性を確保
- **テストの目的**: ローディング状態のUI制御を確認
  - **確認ポイント**: ボタンのdisabled属性、ローディングスピナーの表示
- 🟡 信頼性レベル: 一般的なUXパターンから推測

---

## 2. 異常系テストケース（エラーハンドリング）

### 2.1 エラー状態表示

#### TC-ERR-001: ネットワークエラー時にエラーメッセージが表示される

- **テスト名**: ネットワークエラー表示テスト
  - **エラーケースの概要**: Backend APIへの通信が失敗した場合のエラーハンドリング
  - **エラー処理の重要性**: ユーザーにエラーの原因を明確に伝え、再試行を促す
- **入力値**: error: "ネットワークエラーが発生しました"
  - **不正な理由**: Backend APIサーバーが停止している、インターネット接続が切断されている等
  - **実際の発生シナリオ**: モバイル環境での通信不安定、サーバーメンテナンス中等
- **期待される結果**:
  - エラーメッセージエリアに "ネットワークエラーが発生しました" が表示される
  - "再試行"ボタンが表示される
  - 一覧表示エリアは既存データを保持（空にならない）
  - **エラーメッセージの内容**: ユーザーフレンドリーな日本語メッセージ
  - **システムの安全性**: エラー時でも既存データを保持し、再試行可能
- **テストの目的**: ネットワークエラー時のエラーハンドリングを確認
  - **品質保証の観点**: エラー時でもユーザーが操作を継続できること
- 🔵 信頼性レベル: EDGE-001（ネットワークエラー）に基づく

#### TC-ERR-002: 再試行ボタンでfetchBattleLogs()が再実行される

- **テスト名**: 再試行ボタンクリックテスト
  - **エラーケースの概要**: エラー発生後、ユーザーが再試行ボタンをクリックした場合の動作
  - **エラー処理の重要性**: ユーザーが手動でリトライできる機能を提供
- **入力値**: 再試行ボタンクリックイベント
  - **不正な理由**: エラー状態からの復帰操作
  - **実際の発生シナリオ**: ネットワークエラー後に接続が回復した場合
- **期待される結果**:
  - fetchBattleLogs()が再実行される
  - clearError()が呼ばれ、エラーメッセージがクリアされる
  - 成功時は一覧が最新状態に更新される
  - **エラーメッセージの内容**: エラーメッセージが消え、一覧表示に戻る
  - **システムの安全性**: 何度でも再試行可能
- **テストの目的**: エラーからの復帰機能を確認
  - **品質保証の観点**: ユーザーが自力でエラーを解消できること
- 🔵 信頼性レベル: EDGE-001（ネットワークエラー）に基づく

#### TC-ERR-003: 削除中にエラー発生時、ダイアログが閉じてエラーメッセージが表示される

- **テスト名**: 削除エラーハンドリングテスト
  - **エラーケースの概要**: 削除実行時にBackend APIがエラーを返した場合（404等）
  - **エラー処理の重要性**: 削除失敗をユーザーに明確に伝え、一覧を最新状態に同期
- **入力値**: deleteBattleLog()がエラーを投げる
  - **不正な理由**: 対象の対戦履歴が既に削除されている、権限エラー等
  - **実際の発生シナリオ**: 複数タブで同じ対戦履歴を同時に削除しようとした場合
- **期待される結果**:
  - 削除確認ダイアログがクローズされる
  - エラーメッセージエリアに "対戦履歴が見つかりません" が表示される
  - fetchBattleLogs()が実行され、一覧が最新状態に同期される
  - **エラーメッセージの内容**: ユーザーフレンドリーな日本語メッセージ
  - **システムの安全性**: エラー後も一覧が最新状態を維持
- **テストの目的**: 削除エラー時のエラーハンドリングを確認
  - **品質保証の観点**: エラー時でもデータの一貫性を保つこと
- 🔵 信頼性レベル: EDGE-003（削除中にエラー発生）に基づく

---

## 3. 境界値テストケース（最小値、最大値、null等）

### 3.1 データ件数の境界値

#### TC-BND-001: 対戦履歴が0件の場合、空データメッセージが表示される

- **テスト名**: 空データ表示テスト
  - **境界値の意味**: データが存在しない最小状態（0件）
  - **境界値での動作保証**: テーブルが空でも正常に動作し、適切なメッセージを表示
- **入力値**: battleLogs: []
  - **境界値選択の根拠**: 初回登録前、全削除後等の最小ケース
  - **実際の使用場面**: 新規ユーザーの初回アクセス時
- **期待される結果**:
  - テーブルは表示されない
  - "対戦履歴がありません。「新規登録」ボタンから対戦履歴を追加してください。" メッセージが表示される
  - **境界での正確性**: 0件でもエラーにならず、適切なメッセージを表示
  - **一貫した動作**: 空配列でもコンポーネントがクラッシュしない
- **テストの目的**: 空データ時のUI状態を確認
  - **堅牢性の確認**: 0件でもシステムが安定動作すること
- 🔵 信頼性レベル: EDGE-204（空データ）に基づく

#### TC-BND-002: 対戦履歴が1件の場合、正しく表示される

- **テスト名**: 最小データ（1件）表示テスト
  - **境界値の意味**: データが存在する最小状態（1件）
  - **境界値での動作保証**: 1件のデータでもテーブルが正常に表示される
- **入力値**: battleLogs: [{ ... }]（1件）
  - **境界値選択の根拠**: 初回登録直後のケース
  - **実際の使用場面**: 初回登録後、削除して1件のみ残った場合
- **期待される結果**:
  - テーブルに1行のデータが表示される
  - ヘッダー行が表示される
  - 削除・詳細ボタンが表示される
  - **境界での正確性**: 1件でもテーブル構造が正常に表示される
  - **一貫した動作**: 複数件と同じUI構造を維持
- **テストの目的**: 最小データ件数での動作確認
  - **堅牢性の確認**: 1件でもシステムが安定動作すること
- 🟡 信頼性レベル: 境界値テストの一般的なパターンから推測

#### TC-BND-003: 対戦履歴が100件の場合、正しく表示される

- **テスト名**: 大量データ（100件）表示テスト
  - **境界値の意味**: Phase 1の最大件数制限（100件）
  - **境界値での動作保証**: 大量データでもパフォーマンスが劣化しない
- **入力値**: battleLogs: [{ ... }, ...] (100件)
  - **境界値選択の根拠**: Backend APIのデフォルトlimit値
  - **実際の使用場面**: ヘビーユーザーの長期利用後
- **期待される結果**:
  - テーブルに100行のデータが表示される
  - スクロール可能
  - パフォーマンスが劣化しない（レンダリング時間 < 300ms）
  - **境界での正確性**: 100件でも全データが正確に表示される
  - **一貫した動作**: 少数件と同じUI構造を維持
- **テストの目的**: 大量データ時のパフォーマンス確認
  - **堅牢性の確認**: 100件でもシステムが安定動作すること
- 🟡 信頼性レベル: パフォーマンス要件から妥当な推測

### 3.2 ローディング状態の境界値

#### TC-BND-004: ローディング中はローディングスピナーが表示される

- **テスト名**: ローディング状態表示テスト
  - **境界値の意味**: isLoading = true の状態
  - **境界値での動作保証**: データ取得中でもUIが固まらず、ローディング表示を行う
- **入力値**: isLoading: true
  - **境界値選択の根拠**: fetchBattleLogs()実行中の状態
  - **実際の使用場面**: 初回ロード時、再試行時
- **期待される結果**:
  - "読み込み中..." スピナーが表示される
  - テーブルは一時的に非表示（または既存データを表示）
  - **境界での正確性**: ローディング中でもユーザーに状態を伝える
  - **一貫した動作**: ローディング終了後に正常な一覧表示に戻る
- **テストの目的**: ローディング状態のUI確認
  - **堅牢性の確認**: ローディング中でもUIが適切に動作すること
- 🔵 信頼性レベル: REQ-032（ローディング状態表示）に基づく

---

## 4. UI/UXテストケース

### 4.1 レスポンシブデザイン

#### TC-UI-001: デスクトップ（1024px以上）でテーブル表示される

- **テスト名**: デスクトップ表示テスト
  - **何をテストするか**: 画面幅1024px以上でテーブル形式で表示されること
  - **期待される動作**: Tailwind CSS の hidden lg:table クラスが適用される
- **入力値**: window.innerWidth = 1024
  - **入力データの意味**: デスクトップ画面サイズ
- **期待される結果**:
  - <table> 要素が表示される
  - <div class="lg:hidden"> (カード表示) は非表示
  - **期待結果の理由**: デスクトップでは情報密度の高いテーブル表示が適している
- **テストの目的**: レスポンシブデザインの動作確認（デスクトップ）
  - **確認ポイント**: テーブル要素の表示、カード要素の非表示
- 🔵 信頼性レベル: REQ-034、REQ-603に基づく

#### TC-UI-002: モバイル（767px以下）でカード表示される

- **テスト名**: モバイル表示テスト
  - **何をテストするか**: 画面幅767px以下でカード形式で表示されること
  - **期待される動作**: Tailwind CSS の lg:hidden クラスが適用される
- **入力値**: window.innerWidth = 375
  - **入力データの意味**: モバイル画面サイズ（iPhone 13 Pro相当）
- **期待される結果**:
  - <div class="lg:hidden"> (カード表示) が表示される
  - <table class="hidden lg:table"> は非表示
  - 各カードに対戦日、対戦タイプ、ランク、グループ、使用デッキ、相手デッキ、詳細・削除ボタンが表示される
  - **期待結果の理由**: モバイルでは縦スクロールに最適化されたカード表示が適している
- **テストの目的**: レスポンシブデザインの動作確認（モバイル）
  - **確認ポイント**: カード要素の表示、テーブル要素の非表示
- 🔵 信頼性レベル: REQ-034、REQ-603に基づく

### 4.2 アクセシビリティ

#### TC-A11Y-001: テーブルにrole="table"が設定されている

- **テスト名**: アクセシビリティ（テーブルロール）テスト
  - **何をテストするか**: テーブルコンポーネントに role="table" 属性が設定されていること
  - **期待される動作**: スクリーンリーダーがテーブル構造を正しく認識できる
- **入力値**: なし
  - **入力データの意味**: アクセシビリティ属性の設定確認
- **期待される結果**:
  - <table> 要素に role="table" 属性が設定されている
  - **期待結果の理由**: 視覚障害者がスクリーンリーダーでテーブル構造を理解できる
- **テストの目的**: アクセシビリティ対応の確認
  - **確認ポイント**: role属性の存在確認
- 🟡 信頼性レベル: アクセシビリティ要件から推測

#### TC-A11Y-002: 削除・詳細ボタンにaria-label属性が設定されている

- **テスト名**: アクセシビリティ（ボタンラベル）テスト
  - **何をテストするか**: 削除・詳細ボタンに aria-label 属性が設定されていること
  - **期待される動作**: スクリーンリーダーがボタンの目的を読み上げる
- **入力値**: なし
  - **入力データの意味**: アクセシビリティ属性の設定確認
- **期待される結果**:
  - 削除ボタンに aria-label="対戦履歴を削除" が設定されている
  - 詳細ボタンに aria-label="対戦履歴の詳細を表示" が設定されている
  - **期待結果の理由**: 視覚障害者がボタンの目的を理解できる
- **テストの目的**: アクセシビリティ対応の確認
  - **確認ポイント**: aria-label属性の存在確認
- 🟡 信頼性レベル: アクセシビリティ要件から推測

#### TC-A11Y-003: Tabキーでフォーカスが移動する

- **テスト名**: キーボードナビゲーションテスト
  - **何をテストするか**: Tabキー押下時にフォーカスが論理的な順序で移動すること
  - **期待される動作**: 新規登録ボタン → 詳細ボタン（1行目） → 削除ボタン（1行目） → 詳細ボタン（2行目） → ...
- **入力値**: Tabキー押下イベント
  - **入力データの意味**: キーボードナビゲーション操作
- **期待される結果**:
  - フォーカスが論理的な順序で移動する
  - フォーカスされた要素にアウトライン表示が適用される
  - **期待結果の理由**: キーボードのみで操作可能にするため
- **テストの目的**: キーボードナビゲーションの動作確認
  - **確認ポイント**: フォーカス順序、フォーカスのハイライト表示
- 🟡 信頼性レベル: アクセシビリティ要件から推測

---

## 5. 統合テストケース（Zustand Storeとの連携）

### 5.1 Zustand Store連携

#### TC-INT-001: fetchBattleLogs()実行時にbattleLogsが更新される

- **テスト名**: Zustand Store連携テスト（fetchBattleLogs）
  - **何をテストするか**: Zustand StoreのfetchBattleLogs()が成功し、battleLogsが更新されること
  - **期待される動作**: Backend APIから取得したデータがストアに保存され、コンポーネントが再レンダリングされる
- **入力値**: fetchBattleLogs()の実行
  - **入力データの意味**: Backend APIからのデータ取得処理
- **期待される結果**:
  - Backend API（GET /api/battle-logs）が呼ばれる
  - battleLogs が更新される
  - BattleLogListコンポーネントが再レンダリングされる
  - **期待結果の理由**: ストアとコンポーネントが正しく連携し、最新データが表示される
- **テストの目的**: Zustand Storeとの統合確認
  - **確認ポイント**: API呼び出し、ストア更新、再レンダリング
- 🔵 信頼性レベル: データフロー図に基づく

#### TC-INT-002: deleteBattleLog()実行時に一覧が自動更新される

- **テスト名**: Zustand Store連携テスト（deleteBattleLog）
  - **何をテストするか**: Zustand StoreのdeleteBattleLog()が成功後、fetchBattleLogs()が自動実行されること
  - **期待される動作**: 削除後に一覧が最新状態に更新される
- **入力値**: deleteBattleLog('log_20251108_001')の実行
  - **入力データの意味**: 削除処理の実行
- **期待される結果**:
  - Backend API（DELETE /api/battle-logs/:id）が呼ばれる
  - 削除成功後、fetchBattleLogs()が自動実行される
  - battleLogs から削除されたデータが消える
  - BattleLogListコンポーネントが再レンダリングされる
  - **期待結果の理由**: 削除後に一覧が最新状態に同期され、ユーザーが最新情報を確認できる
- **テストの目的**: 削除後の自動更新機能を確認
  - **確認ポイント**: 削除API呼び出し、fetchBattleLogs()自動実行、一覧更新
- 🔵 信頼性レベル: データフロー図に基づく

#### TC-INT-003: BattleLogForm送信成功後に一覧が自動更新される

- **テスト名**: Zustand Store連携テスト（createBattleLog）
  - **何をテストするか**: Zustand StoreのcreateBattleLog()が成功後、fetchBattleLogs()が自動実行されること
  - **期待される動作**: 登録後に一覧が最新状態に更新される
- **入力値**: createBattleLog({ ... })の実行
  - **入力データの意味**: 新規登録処理の実行
- **期待される結果**:
  - Backend API（POST /api/battle-logs）が呼ばれる
  - 登録成功後、fetchBattleLogs()が自動実行される
  - battleLogs に新規データが追加される
  - BattleLogListコンポーネントが再レンダリングされる
  - **期待結果の理由**: 登録後に一覧が最新状態に同期され、ユーザーが新規データを確認できる
- **テストの目的**: 登録後の自動更新機能を確認
  - **確認ポイント**: 登録API呼び出し、fetchBattleLogs()自動実行、一覧更新
- 🔵 信頼性レベル: データフロー図に基づく

---

## 6. エッジケーステストケース

### 6.1 エッジケース

#### TC-EDGE-001: 削除確認ダイアログ表示中に別の削除ボタンをクリックした場合

- **テスト名**: 複数削除操作の同時実行防止テスト
  - **何をテストするか**: 削除確認ダイアログ表示中に別の削除ボタンがクリックされた場合の動作
  - **期待される動作**: 新しい削除対象に切り替わる、または既存のダイアログを維持する
- **入力値**:
  1. 削除ボタンクリック（log_20251108_001）
  2. 削除ボタンクリック（log_20251107_001）
  - **入力データの意味**: ユーザーが誤って別の削除ボタンをクリックした場合
- **期待される結果**:
  - パターン1（推奨）: 既存のダイアログを維持し、新しい削除ボタンは無視される
  - パターン2: 新しい削除対象に切り替わり、ダイアログの内容が更新される
  - **期待結果の理由**: ユーザーの誤操作を防止し、予期しない削除を避ける
- **テストの目的**: 複数削除操作の同時実行防止を確認
  - **確認ポイント**: ダイアログの状態、削除対象の正確性
- 🟡 信頼性レベル: エッジケースとして妥当な推測

#### TC-EDGE-002: ローディング中にページを離脱した場合

- **テスト名**: ローディング中のクリーンアップテスト
  - **何をテストするか**: fetchBattleLogs()実行中にページがアンマウントされた場合の動作
  - **期待される動作**: メモリリークが発生しない、エラーが投げられない
- **入力値**:
  1. fetchBattleLogs()実行中
  2. useEffectのクリーンアップ関数が呼ばれる
  - **入力データの意味**: ユーザーが別のページに遷移した場合
- **期待される結果**:
  - エラーが投げられない
  - メモリリークが発生しない
  - 未完了のPromiseが適切にクリーンアップされる
  - **期待結果の理由**: システムの安定性を確保し、メモリリークを防止
- **テストの目的**: コンポーネントのクリーンアップ処理を確認
  - **確認ポイント**: エラーの発生有無、メモリリークの有無
- 🟡 信頼性レベル: React のクリーンアップパターンから推測

#### TC-EDGE-003: 詳細モーダル表示中に削除ボタンをクリックした場合

- **テスト名**: モーダル表示中の操作競合テスト
  - **何をテストするか**: 詳細モーダル表示中に別の削除ボタンがクリックされた場合の動作
  - **期待される動作**: 詳細モーダルが自動クローズされ、削除確認ダイアログが表示される
- **入力値**:
  1. 詳細ボタンクリック（log_20251108_001）
  2. 削除ボタンクリック（log_20251107_001）
  - **入力データの意味**: ユーザーが詳細確認後に別のデータを削除しようとした場合
- **期待される結果**:
  - 詳細モーダルがクローズされる
  - 削除確認ダイアログが表示される（新しい削除対象）
  - **期待結果の理由**: 複数のモーダルが同時に表示されない（UXの一貫性）
- **テストの目的**: モーダル表示の競合処理を確認
  - **確認ポイント**: 詳細モーダルのクローズ、削除確認ダイアログの表示
- 🟡 信頼性レベル: エッジケースとして妥当な推測

---

## テストケース実装時の日本語コメント指針

すべてのテストケース実装時には、以下の日本語コメントを必ず含めてください：

### テストケース開始時のコメント

```typescript
// 【テスト目的】: このテストで何を確認するかを日本語で明記
// 【テスト内容】: 具体的にどのような処理をテストするかを説明
// 【期待される動作】: 正常に動作した場合の結果を説明
// 🔵🟡🔴 この内容の信頼性レベルを記載
```

### Given（準備フェーズ）のコメント

```typescript
// 【テストデータ準備】: なぜこのデータを用意するかの理由
// 【初期条件設定】: テスト実行前の状態を説明
// 【前提条件確認】: テスト実行に必要な前提条件を明記
```

### When（実行フェーズ）のコメント

```typescript
// 【実際の処理実行】: どの機能/メソッドを呼び出すかを説明
// 【処理内容】: 実行される処理の内容を日本語で説明
// 【実行タイミング】: なぜこのタイミングで実行するかを説明
```

### Then（検証フェーズ）のコメント

```typescript
// 【結果検証】: 何を検証するかを具体的に説明
// 【期待値確認】: 期待される結果とその理由を説明
// 【品質保証】: この検証がシステム品質にどう貢献するかを説明
```

### 各expectステートメントのコメント

```typescript
expect(battleLogs).toHaveLength(3); // 【確認内容】: 対戦履歴が3件取得されることを確認 🔵
expect(deleteButton).toBeInTheDocument(); // 【確認内容】: 削除ボタンが表示されることを確認 🔵
```

---

## テストケース実装例

### 実装例: TC-LIST-001

```typescript
it('TC-LIST-001: 対戦履歴一覧が正しく表示される（3件）', () => {
  // 【テスト目的】: BattleLogListコンポーネントが対戦履歴一覧を正しくテーブル形式で表示すること 🔵
  // 【テスト内容】: 3件の対戦履歴が日付降順でテーブルに表示されることを確認 🔵
  // 【期待される動作】: ヘッダー行と3行のデータ行が表示され、各行に詳細・削除ボタンが表示される 🔵
  // 🔵 信頼性レベル: 要件定義書REQ-009、REQ-103に基づく

  // 【テストデータ準備】: 3件の対戦履歴モックデータを作成 🔵
  // 【初期条件設定】: 日付降順でソートされたデータを用意
  const mockBattleLogs = [
    { id: 'log_20251108_001', date: '2025/11/08', battleType: 'ランクマッチ', rank: 'ダイアモンド', group: 'AAA', myDeckId: 'deck-001', myDeckName: 'テストデッキ1', turn: '先攻', result: '勝ち', opponentDeckId: 'deck-master-001', opponentDeckName: '相手デッキ1' },
    { id: 'log_20251107_001', date: '2025/11/07', battleType: 'ランクマッチ', rank: 'ダイアモンド', group: 'AA', myDeckId: 'deck-002', myDeckName: 'テストデッキ2', turn: '後攻', result: '負け', opponentDeckId: 'deck-master-002', opponentDeckName: '相手デッキ2' },
    { id: 'log_20251106_001', date: '2025/11/06', battleType: '対戦台', rank: '-', group: '-', myDeckId: 'deck-001', myDeckName: 'テストデッキ1', turn: '先攻', result: '勝ち', opponentDeckId: 'deck-master-003', opponentDeckName: '相手デッキ3' }
  ];

  const onDelete = vi.fn();
  const onDetail = vi.fn();

  // 【実際の処理実行】: BattleLogListコンポーネントをレンダリング 🔵
  // 【処理内容】: 3件の対戦履歴を含むコンポーネントを表示
  render(<BattleLogList battleLogs={mockBattleLogs} onDelete={onDelete} onDetail={onDetail} />);

  // 【結果検証】: テーブル構造とデータが正しく表示されることを確認 🔵
  // 【期待値確認】: ヘッダー行と3行のデータ行が表示される
  const table = screen.getByRole('table');
  expect(table).toBeInTheDocument(); // 【確認内容】: テーブルが表示される 🔵

  const rows = screen.getAllByRole('row');
  expect(rows).toHaveLength(4); // 【確認内容】: ヘッダー行 + 3行のデータ行 = 4行 🔵

  // 【品質保証】: 日付降順ソートが正しく動作していることを確認
  expect(screen.getByText('2025/11/08')).toBeInTheDocument(); // 【確認内容】: 最新の対戦日が表示される 🔵
  expect(screen.getByText('2025/11/07')).toBeInTheDocument(); // 【確認内容】: 2番目の対戦日が表示される 🔵
  expect(screen.getByText('2025/11/06')).toBeInTheDocument(); // 【確認内容】: 3番目の対戦日が表示される 🔵

  // 【確認内容】: デッキ名が正しく表示される（IDではなく名前）🔵
  expect(screen.getByText('テストデッキ1')).toBeInTheDocument();
  expect(screen.getByText('相手デッキ1')).toBeInTheDocument();

  // 【確認内容】: 削除・詳細ボタンが表示される 🔵
  const deleteButtons = screen.getAllByRole('button', { name: /削除/ });
  expect(deleteButtons).toHaveLength(3); // 【確認内容】: 3行分の削除ボタンが表示される 🔵

  const detailButtons = screen.getAllByRole('button', { name: /詳細/ });
  expect(detailButtons).toHaveLength(3); // 【確認内容】: 3行分の詳細ボタンが表示される 🔵
});
```

---

## テストケース数とカバレッジ範囲の概要

### テストケース数

- **正常系テストケース**: 10件
  - BattleLogListPage: 4件
  - BattleLogList: 5件
  - DeleteConfirmDialog: 4件
  - DetailModal: 0件（🟡 実装判断待ち）

- **異常系テストケース**: 3件
  - エラー状態表示: 3件

- **境界値テストケース**: 5件
  - データ件数の境界値: 3件
  - ローディング状態の境界値: 1件

- **UI/UXテストケース**: 5件
  - レスポンシブデザイン: 2件
  - アクセシビリティ: 3件

- **統合テストケース**: 3件
  - Zustand Store連携: 3件

- **エッジケーステストケース**: 3件

**合計**: 29件

### カバレッジ範囲

- **機能カバレッジ**: 100%
  - ✅ 一覧表示（REQ-009）
  - ✅ 削除機能（REQ-010）
  - ✅ 詳細表示（REQ-011）
  - ✅ ローディング状態表示（REQ-032）
  - ✅ エラー状態表示（REQ-033）
  - ✅ レスポンシブデザイン（REQ-034、REQ-603）
  - ✅ ソート機能（REQ-103）
  - ✅ デッキ名表示（REQ-106）

- **要件カバレッジ**: 100%
  - ✅ REQ-009: 対戦履歴一覧表示機能
  - ✅ REQ-010: 削除機能
  - ✅ REQ-011: 詳細表示機能
  - ✅ REQ-032: ローディング状態表示
  - ✅ REQ-033: エラー状態表示
  - ✅ REQ-034: レスポンシブデザイン
  - ✅ REQ-103: ソート機能
  - ✅ REQ-106: デッキ名表示

- **エッジケースカバレッジ**: 100%
  - ✅ EDGE-001: ネットワークエラー
  - ✅ EDGE-003: 削除中にエラー発生
  - ✅ EDGE-204: 空データ

- **コンポーネントカバレッジ**: 100%
  - ✅ BattleLogListPage
  - ✅ BattleLogList
  - ✅ DeleteConfirmDialog
  - 🟡 DetailModal（実装判断待ち）

---

## 品質判定

### ✅ 高品質

- **テストケース分類**: 正常系・異常系・境界値・UI/UX・統合・エッジケースが網羅されている
- **期待値定義**: 各テストケースの期待値が明確（入力値、期待される結果、テストの目的が具体的）
- **技術選択**: プログラミング言語（TypeScript 5.7+）、テストフレームワーク（Vitest 2.0+）が確定
- **実装可能性**: 現在の技術スタック（React 19.x、Zustand、Tailwind CSS v4）で実現可能

---

## 次のステップ

**次のお勧めステップ**: `/tsumiki:tdd-red` でRedフェーズ（失敗テスト作成）を開始します。

**実装順序**:
1. BattleLogListコンポーネント（テーブル・カード表示）
2. DeleteConfirmDialogコンポーネント
3. BattleLogListPageコンポーネント（統合）
4. DetailModal（🟡 実装判断待ち）

---

## 更新履歴

- **2025-11-08**: 初版作成（テストケース定義完了）
  - TDD要件定義書（tdd-requirements.md）を参照
  - 既存のBattleLogForm.test.tsx、battleLogStore.test.tsのテストパターンを参考
  - 29件のテストケースを定義（正常系10件、異常系3件、境界値5件、UI/UX5件、統合3件、エッジケース3件）
  - 機能カバレッジ100%、要件カバレッジ100%、エッジケースカバレッジ100%を達成
