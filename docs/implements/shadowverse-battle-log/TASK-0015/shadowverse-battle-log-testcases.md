# TDDテストケース定義書: Zustand State Management実装

**機能名**: Zustand State Management - Frontend State Management with API Integration
**タスクID**: TASK-0015
**実装者**: AI Assistant (Claude)
**作成日**: 2025-11-05
**更新日**: 2025-11-05

---

## 開発言語・テストフレームワーク

### プログラミング言語: TypeScript 5.9+

- **言語選択の理由**: 🔵
  - プロジェクト全体でTypeScript 5.9+を採用している
  - 型安全性により、ランタイムエラーを事前に検出できる
  - IDEのサポートが優れており、開発効率が向上する
  - Backend APIとの型定義を共有できる（`frontend/src/types/index.ts`）

- **テストに適した機能**: 🔵
  - 型推論によりテストコードの可読性が高い
  - インターフェース定義により、モックの作成が容易
  - ジェネリック型により、再利用可能なテストヘルパーを作成できる

### テストフレームワーク: Vitest

- **フレームワーク選択の理由**: 🔵
  - Vite環境と完全に統合され、設定が最小限で済む
  - Jest互換のAPIで学習コストが低い
  - 高速な実行速度（ESMネイティブサポート）
  - TypeScriptのサポートが標準で含まれている
  - 既存のバックエンドテスト（Jest）と類似のAPI

- **テスト実行環境**: 🔵
  - Node.js環境（開発環境）
  - CI/CD環境（GitHub Actions等）
  - カバレッジ測定: `vitest --coverage`
  - ウォッチモード: `vitest --watch`

- **モックライブラリ**: 🔵
  - Vitestの組み込みモック機能（`vi.mock()`）
  - API Clientのモック化（`vi.fn()`）
  - Zustandストアのテスト（実際のストアインスタンスを使用）

---

## テストケース一覧

### 1. API Client テストケース（`frontend/src/api/client.test.ts`）

#### TC-API-001: GETリクエスト - 正常系

- **テスト名**: GETリクエストが成功し、レスポンスデータが正しく返される
  - **何をテストするか**: 🔵 API Client の `get<T>()` 関数が正常にGETリクエストを送信し、レスポンスをパースできること
  - **期待される動作**: 🔵 `ApiResponse<T>` 型のレスポンスが返され、`data` フィールドにデータが含まれる

- **入力値**: 🔵
  - `endpoint`: `/battle-logs`
  - モックレスポンス:
    ```json
    {
      "success": true,
      "data": {
        "battleLogs": [
          {
            "id": "log_20251104_001",
            "date": "2025/11/04",
            "battleType": "ランクマッチ",
            "rank": "ダイアモンド",
            "group": "AA",
            "myDeckId": "deck-001",
            "turn": "先攻",
            "result": "勝ち",
            "opponentDeckId": "deck-101"
          }
        ],
        "total": 1,
        "limit": 100,
        "offset": 0
      },
      "meta": {
        "timestamp": "2025-11-04T12:00:00Z",
        "requestId": "req-001"
      }
    }
    ```
  - **入力データの意味**: 🔵 Backend APIから対戦履歴一覧を取得する典型的なリクエスト

- **期待される結果**: 🔵
  - `get<BattleLogsResponse>('/battle-logs')` が `BattleLogsResponse` 型のデータを返す
  - `data.battleLogs` が配列で、1件のデータが含まれる
  - `data.total` が 1
  - **期待結果の理由**: 🔵 Backend APIの仕様（`docs/implements/shadowverse-battle-log/TASK-0008/requirements.md`）に準拠

- **テストの目的**: 🔵 GETリクエストの基本動作を確認
  - **確認ポイント**: 🔵
    - HTTP GETメソッドが呼ばれる
    - レスポンスの `success` フィールドが `true`
    - レスポンスの `data` フィールドが正しくパースされる
    - エンドポイントURLが正しく構築される（`API_BASE_URL + endpoint`）

#### TC-API-002: POSTリクエスト - 正常系

- **テスト名**: POSTリクエストが成功し、作成されたデータが返される
  - **何をテストするか**: 🔵 API Client の `post<T>()` 関数が正常にPOSTリクエストを送信し、リクエストボディを正しく送信できること
  - **期待される動作**: 🔵 新規リソースが作成され、作成されたデータが返される

- **入力値**: 🔵
  - `endpoint`: `/battle-logs`
  - `data`:
    ```json
    {
      "date": "2025-11-04",
      "battleType": "ランクマッチ",
      "rank": "ダイアモンド",
      "group": "AA",
      "myDeckId": "deck-001",
      "turn": "先攻",
      "result": "勝ち",
      "opponentDeckId": "deck-101"
    }
    ```
  - モックレスポンス:
    ```json
    {
      "success": true,
      "data": {
        "id": "log_20251104_001",
        "date": "2025/11/04",
        "battleType": "ランクマッチ",
        "rank": "ダイアモンド",
        "group": "AA",
        "myDeckId": "deck-001",
        "turn": "先攻",
        "result": "勝ち",
        "opponentDeckId": "deck-101"
      },
      "meta": {
        "timestamp": "2025-11-04T12:00:00Z",
        "requestId": "req-002"
      }
    }
    ```
  - **入力データの意味**: 🔵 新規対戦履歴を登録する典型的なリクエスト

- **期待される結果**: 🔵
  - `post<BattleLog>('/battle-logs', data)` が `BattleLog` 型のデータを返す
  - 返されたデータに `id` が含まれる（Backend側で生成）
  - `date` が `YYYY/MM/DD` 形式に変換されている
  - **期待結果の理由**: 🔵 Backend APIの仕様（`docs/implements/shadowverse-battle-log/TASK-0007/requirements.md`）に準拠

- **テストの目的**: 🔵 POSTリクエストの基本動作を確認
  - **確認ポイント**: 🔵
    - HTTP POSTメソッドが呼ばれる
    - リクエストボディが正しくJSON化される
    - `Content-Type: application/json` ヘッダーが設定される
    - レスポンスが正しくパースされる

#### TC-API-003: DELETEリクエスト - 正常系

- **テスト名**: DELETEリクエストが成功し、削除完了メッセージが返される
  - **何をテストするか**: 🔵 API Client の `del<T>()` 関数が正常にDELETEリクエストを送信できること
  - **期待される動作**: 🔵 リソースが削除され、成功レスポンスが返される

- **入力値**: 🔵
  - `endpoint`: `/battle-logs/log_20251104_001`
  - モックレスポンス:
    ```json
    {
      "success": true,
      "data": {
        "message": "対戦履歴を削除しました"
      },
      "meta": {
        "timestamp": "2025-11-04T12:00:00Z",
        "requestId": "req-003"
      }
    }
    ```
  - **入力データの意味**: 🔵 特定の対戦履歴を削除するリクエスト

- **期待される結果**: 🔵
  - `del('/battle-logs/log_20251104_001')` が成功レスポンスを返す
  - `success` が `true`
  - **期待結果の理由**: 🔵 Backend APIの仕様（`docs/implements/shadowverse-battle-log/TASK-0008/requirements.md`）に準拠

- **テストの目的**: 🔵 DELETEリクエストの基本動作を確認
  - **確認ポイント**: 🔵
    - HTTP DELETEメソッドが呼ばれる
    - エンドポイントURLにIDが正しく含まれる
    - レスポンスが正しくパースされる

#### TC-API-004: APIエラーレスポンス処理（400 Bad Request）

- **テスト名**: バリデーションエラー時に適切なエラーが投げられる
  - **エラーケースの概要**: 🔵 Backend APIが400 Bad Requestを返した場合の処理
  - **エラー処理の重要性**: 🔵 クライアント側で適切なエラーメッセージを表示するため

- **入力値**: 🔵
  - `endpoint`: `/battle-logs`
  - `data`: 不正なデータ（未来の日付など）
  - モックレスポンス:
    ```json
    {
      "success": false,
      "error": {
        "code": "VALIDATION_ERROR",
        "message": "未来の日付は入力できません",
        "details": {
          "field": "date",
          "value": "2099-12-31"
        }
      },
      "meta": {
        "timestamp": "2025-11-04T12:00:00Z",
        "requestId": "req-004"
      }
    }
    ```
  - **不正な理由**: 🔵 未来の日付は対戦履歴として不正
  - **実際の発生シナリオ**: 🔵 ユーザーが誤って未来の日付を入力した場合

- **期待される結果**: 🔵
  - `Error` が投げられる
  - エラーメッセージが「未来の日付は入力できません」
  - **エラーメッセージの内容**: 🔵 Backend APIから返されたメッセージをそのまま使用
  - **システムの安全性**: 🔵 エラー時にアプリケーションがクラッシュしない

- **テストの目的**: 🔵 APIエラーレスポンスの適切な処理
  - **品質保証の観点**: 🔵 ユーザーにわかりやすいエラーメッセージを表示できること

#### TC-API-005: ネットワークエラー処理

- **テスト名**: ネットワークエラー時に適切なエラーが投げられる
  - **エラーケースの概要**: 🔵 ネットワーク接続が切断されている、またはBackend APIが応答しない場合
  - **エラー処理の重要性**: 🔵 オフライン時の動作を明確にし、ユーザーに適切なメッセージを表示するため

- **入力値**: 🔵
  - `endpoint`: `/battle-logs`
  - モックが `fetch()` でネットワークエラーを投げる
  - **不正な理由**: 🔵 ネットワーク接続が利用できない
  - **実際の発生シナリオ**: 🔵 モバイル環境でのオフライン状態、Backend APIのダウンタイム

- **期待される結果**: 🔵
  - `Error` が投げられる
  - エラーメッセージが「ネットワークエラーが発生しました」
  - **エラーメッセージの内容**: 🔵 ユーザーが理解しやすい日本語メッセージ
  - **システムの安全性**: 🔵 エラー時にアプリケーションがクラッシュしない

- **テストの目的**: 🔵 ネットワークエラーの適切な処理
  - **品質保証の観点**: 🔵 オフライン時でもアプリケーションが安全に動作すること

#### TC-API-006: サーバーエラー処理（500 Internal Server Error）

- **テスト名**: サーバーエラー時に適切なエラーが投げられる
  - **エラーケースの概要**: 🔵 Backend APIで予期しないエラーが発生した場合
  - **エラー処理の重要性**: 🔵 サーバー側のエラーを適切にハンドリングし、ユーザーに通知するため

- **入力値**: 🔵
  - `endpoint`: `/battle-logs`
  - モックレスポンス: HTTP 500 ステータス
  - **不正な理由**: 🔵 Backend APIの内部エラー
  - **実際の発生シナリオ**: 🔵 データベース接続エラー、予期しない例外

- **期待される結果**: 🔵
  - `Error` が投げられる
  - エラーメッセージが「サーバーエラーが発生しました」
  - **エラーメッセージの内容**: 🔵 ユーザーが理解しやすい日本語メッセージ
  - **システムの安全性**: 🔵 エラー時にアプリケーションがクラッシュしない

- **テストの目的**: 🔵 サーバーエラーの適切な処理
  - **品質保証の観点**: 🔵 Backend APIのエラー時でもアプリケーションが安全に動作すること

---

### 2. Battle Log Store テストケース（`frontend/src/store/battleLogStore.test.ts`）

#### TC-STORE-BL-001: fetchBattleLogs() - 正常系

- **テスト名**: 対戦履歴一覧の取得が成功し、状態が更新される
  - **何をテストするか**: 🔵 BattleLogStore の `fetchBattleLogs()` アクションが正常にデータを取得し、ストアの状態を更新すること
  - **期待される動作**: 🔵 `isLoading` が `true` → `false` に遷移し、`battleLogs` が更新される

- **入力値**: 🔵
  - モックAPI Clientが `BattleLogsResponse` を返す
  - **入力データの意味**: 🔵 Backend APIから取得した対戦履歴一覧

- **期待される結果**: 🔵
  - `isLoading` が最初に `true` になる
  - `error` が `null` になる
  - `battleLogs` が取得したデータで更新される
  - `isLoading` が最終的に `false` になる
  - **期待結果の理由**: 🔵 ローディング状態の正しい管理により、UIで適切なフィードバックを表示できる

- **テストの目的**: 🔵 データ取得の基本フローを確認
  - **確認ポイント**: 🔵
    - API Clientの `get()` メソッドが呼ばれる
    - ローディング状態が正しく遷移する
    - エラー状態がクリアされる

#### TC-STORE-BL-002: fetchBattleLogs() - エラー系

- **テスト名**: 対戦履歴一覧の取得が失敗し、エラー状態が設定される
  - **エラーケースの概要**: 🔵 API呼び出しが失敗した場合の処理
  - **エラー処理の重要性**: 🔵 エラー発生時にユーザーに適切なメッセージを表示するため

- **入力値**: 🔵
  - モックAPI Clientが `Error` を投げる
  - **不正な理由**: 🔵 ネットワークエラーまたはAPIエラー
  - **実際の発生シナリオ**: 🔵 Backend APIがダウンしている、認証エラー

- **期待される結果**: 🔵
  - `isLoading` が最初に `true` になる
  - `error` にエラーメッセージが設定される
  - `battleLogs` は変更されない（前回取得したデータが保持される）
  - `isLoading` が最終的に `false` になる
  - **エラーメッセージの内容**: 🔵 API Clientから返されたエラーメッセージ
  - **システムの安全性**: 🔵 エラー時でも前回のデータが保持され、アプリケーションが使用可能

- **テストの目的**: 🔵 エラーハンドリングの確認
  - **品質保証の観点**: 🔵 エラー時でもアプリケーションが安全に動作すること

#### TC-STORE-BL-003: createBattleLog() - 正常系

- **テスト名**: 新規対戦履歴の登録が成功し、previousInputが保存される
  - **何をテストするか**: 🔵 BattleLogStore の `createBattleLog()` アクションが正常にデータを登録し、`previousInput` を保存すること
  - **期待される動作**: 🔵 データが登録され、`previousInput` が更新され、一覧が再取得される

- **入力値**: 🔵
  - `input`:
    ```typescript
    {
      date: "2025-11-04",
      battleType: "ランクマッチ",
      rank: "ダイアモンド",
      group: "AA",
      myDeckId: "deck-001",
      turn: "先攻",
      result: "勝ち",
      opponentDeckId: "deck-101"
    }
    ```
  - **入力データの意味**: 🔵 ユーザーが入力した新規対戦履歴データ

- **期待される結果**: 🔵
  - `isLoading` が `true` → `false` に遷移
  - `error` が `null`
  - `previousInput` に入力値が保存される
  - `fetchBattleLogs()` が呼ばれて一覧が更新される
  - **期待結果の理由**: 🔵 前回入力値を保存することで、次回入力時のUXが向上する（REQ-301）

- **テストの目的**: 🔵 データ登録とpreviousInput保存の確認
  - **確認ポイント**: ��
    - API Clientの `post()` メソッドが呼ばれる
    - `previousInput` が正しく保存される
    - 登録後に一覧が再取得される

#### TC-STORE-BL-004: createBattleLog() - エラー系

- **テスト名**: 新規対戦履歴の登録が失敗し、エラー状態が設定される
  - **エラーケースの概要**: 🔵 バリデーションエラーまたはAPIエラーが発生した場合
  - **エラー処理の重要性**: 🔵 ユーザーに入力エラーを明確に伝えるため

- **入力値**: 🔵
  - モックAPI Clientが `Error` を投げる（バリデーションエラー）
  - **不正な理由**: 🔵 入力データが不正（未来の日付など）
  - **実際の発生シナリオ**: 🔵 ユーザーが誤った入力をした場合

- **期待される結果**: 🔵
  - `isLoading` が `true` → `false` に遷移
  - `error` にエラーメッセージが設定される
  - `previousInput` は更新されない
  - `fetchBattleLogs()` は呼ばれない
  - **エラーメッセージの内容**: 🔵 バリデーションエラーの詳細（「未来の日付は入力できません」など）
  - **システムの安全性**: 🔵 エラー時は登録処理が中断され、データの整合性が保たれる

- **テストの目的**: 🔵 登録エラー時の適切な処理
  - **品質保証の観点**: 🔵 不正なデータが登録されないこと

#### TC-STORE-BL-005: deleteBattleLog() - 正常系

- **テスト名**: 対戦履歴の削除が成功し、一覧が更新される
  - **何をテストするか**: 🔵 BattleLogStore の `deleteBattleLog()` アクションが正常にデータを削除し、一覧を再取得すること
  - **期待される動作**: 🔵 データが削除され、一覧が再取得される

- **入力値**: 🔵
  - `id`: `"log_20251104_001"`
  - **入力データの意味**: 🔵 削除対象の対戦履歴ID

- **期待される結果**: 🔵
  - `isLoading` が `true` → `false` に遷移
  - `error` が `null`
  - `fetchBattleLogs()` が呼ばれて一覧が更新される
  - **期待結果の理由**: 🔵 削除後に一覧を再取得することで、UIに最新の状態が反映される

- **テストの目的**: 🔵 データ削除の基本フローを確認
  - **確認ポイント**: 🔵
    - API Clientの `del()` メソッドが正しいIDで呼ばれる
    - 削除後に一覧が再取得される

#### TC-STORE-BL-006: deleteBattleLog() - エラー系（存在しないID）

- **テスト名**: 存在しない対戦履歴IDの削除が失敗し、エラー状態が設定される
  - **エラーケースの概要**: 🔵 削除対象のIDが存在しない場合
  - **エラー処理の重要性**: 🔵 存在しないリソースへのアクセスを適切にハンドリングするため

- **入力値**: 🔵
  - `id`: `"log_99999999_999"`（存在しないID）
  - **不正な理由**: 🔵 指定されたIDのデータが存在しない
  - **実際の発生シナリオ**: 🔵 他のクライアントが既に削除した、URLの直接入力による不正なID

- **期待される結果**: 🔵
  - `isLoading` が `true` → `false` に遷移
  - `error` にエラーメッセージが設定される（「対戦履歴が見つかりません」など）
  - `fetchBattleLogs()` は呼ばれない
  - **エラーメッセージの内容**: 🔵 ユーザーが理解しやすいメッセージ
  - **システムの安全性**: 🔵 存在しないデータの削除試行時でもアプリケーションが安全に動作

- **テストの目的**: 🔵 削除エラー時の適切な処理
  - **品質保証の観点**: 🔵 不正なIDでの削除試行が適切にハンドリングされること

#### TC-STORE-BL-007: setPreviousInput() - 正常系

- **テスト名**: 前回入力値が正しく保存される
  - **何をテストするか**: 🔵 BattleLogStore の `setPreviousInput()` アクションが入力値を正しく保存すること
  - **期待される動作**: 🔵 `previousInput` が更新される

- **入力値**: 🔵
  - `input`:
    ```typescript
    {
      battleType: "ランクマッチ",
      rank: "ダイアモンド",
      group: "AA",
      myDeckId: "deck-001"
    }
    ```
  - **入力データの意味**: 🔵 ユーザーが次回の入力時に再利用したい値

- **期待される結果**: 🔵
  - `previousInput` が入力値で更新される
  - 同期処理のため、即座に反映される
  - **期待結果の理由**: 🔵 フォームの初期値として使用し、ユーザーの入力手間を削減する（REQ-301）

- **テストの目的**: 🔵 previousInput保存機能の確認
  - **確認ポイント**: 🔵
    - 部分的な入力値（Partial型）でも保存できる
    - 即座に反映される

#### TC-STORE-BL-008: clearError() - 正常系

- **テスト名**: エラー状態が正しくクリアされる
  - **何をテストするか**: 🔵 BattleLogStore の `clearError()` アクションがエラー状態をクリアすること
  - **期待される動作**: 🔵 `error` が `null` になる

- **入力値**: 🔵
  - 事前にエラー状態が設定されている
  - **入力データの意味**: 🔵 エラー状態をクリアするアクション

- **期待される結果**: 🔵
  - `error` が `null` になる
  - 同期処理のため、即座に反映される
  - **期待結果の理由**: 🔵 エラーメッセージを閉じた後、次回のエラー表示に備える

- **テストの目的**: 🔵 エラー状態のクリア機能を確認
  - **確認ポイント**: 🔵
    - エラー状態が確実にクリアされる

#### TC-STORE-BL-009: 複数のアクションが連続で呼ばれる場合（エッジケース）

- **テスト名**: 複数のAPI呼び出しが連続で発生しても正しく動作する
  - **境界値の意味**: 🟡 複数のAPI呼び出しが同時に発生した場合の動作
  - **境界値での動作保証**: 🟡 最後のAPI呼び出しの結果が反映される

- **入力値**: 🟡
  - `fetchBattleLogs()` を連続で2回呼び出す
  - **境界値選択の根拠**: 🟡 ユーザーが素早くボタンをダブルクリックした場合
  - **実際の使用場面**: 🟡 リフレッシュボタンの連打

- **期待される結果**: 🟡
  - 両方のAPI呼び出しが完了する
  - `isLoading` は最後のAPI呼び出しが完了するまで `true` のまま
  - 最終的には最後のレスポンスで状態が更新される
  - **境界での正確性**: 🟡 競合状態が発生しない
  - **一貫した動作**: 🟡 エラーが発生しない

- **テストの目的**: 🟡 複数のAPI呼び出しの処理を確認
  - **堅牢性の確認**: 🟡 同時実行でも安全に動作すること

---

### 3. Statistics Store テストケース（`frontend/src/store/statisticsStore.test.ts`）

#### TC-STORE-STAT-001: fetchStatistics() - 正常系（期間: 1week）

- **テスト名**: 直近1週間の統計データの取得が成功する
  - **何をテストするか**: 🔵 StatisticsStore の `fetchStatistics()` アクションが正常に統計データを取得すること
  - **期待される動作**: 🔵 `period` が `'1week'` の場合、7日前から今日までのデータを取得する

- **入力値**: 🔵
  - `period`: `'1week'`
  - モックAPI Clientが `StatisticsResponse` を返す
  - **入力データの意味**: 🔵 直近1週間の統計データ

- **期待される結果**: 🔵
  - `isLoading` が `true` → `false` に遷移
  - `error` が `null`
  - `statistics` が取得したデータで更新される
  - API Clientの `get()` が `?startDate=...&endDate=...` のクエリパラメータ付きで呼ばれる
  - `startDate` が7日前、`endDate` が今日
  - **期待結果の理由**: 🔵 期間設定に基づいた正しいデータ範囲を取得する（REQ-202）

- **テストの目的**: 🔵 期間設定に基づいた統計データ取得を確認
  - **確認ポイント**: 🔵
    - 日付計算が正確（7日前）
    - クエリパラメータが正しく構築される

#### TC-STORE-STAT-002: fetchStatistics() - 正常系（期間: 1month）

- **テスト名**: 直近1ヶ月の統計データの取得が成功する
  - **何をテストするか**: 🔵 `period` が `'1month'` の場合の期間計算が正しいこと
  - **期待される動作**: 🔵 30日前から今日までのデータを取得する

- **入力値**: 🔵
  - `period`: `'1month'`
  - **入力データの意味**: 🔵 直近1ヶ月の統計データ

- **期待される結果**: 🔵
  - `startDate` が30日前、`endDate` が今日
  - **期待結果の理由**: 🔵 期間設定に基づいた正しいデータ範囲を取得する（REQ-202）

- **テストの目的**: 🔵 1ヶ月期間の正確性を確認
  - **確認ポイント**: 🔵
    - 日付計算が正確（30日前）

#### TC-STORE-STAT-003: fetchStatistics() - 正常系（期間: 3months）

- **テスト名**: 直近3ヶ月の統計データの取得が成功する
  - **何をテストするか**: 🔵 `period` が `'3months'` の場合の期間計算が正しいこと
  - **期待される動作**: 🔵 90日前から今日までのデータを取得する

- **入力値**: 🔵
  - `period`: `'3months'`
  - **入力データの意味**: 🔵 直近3ヶ月の統計データ

- **期待される結果**: 🔵
  - `startDate` が90日前、`endDate` が今日
  - **期待結果の理由**: 🔵 期間設定に基づいた正しいデータ範囲を取得する（REQ-202）

- **テストの目的**: 🔵 3ヶ月期間の正確性を確認
  - **確認ポイント**: 🔵
    - 日付計算が正確（90日前）

#### TC-STORE-STAT-004: fetchStatistics() - 正常系（期間: custom）

- **テスト名**: カスタム期間の統計データの取得が成功する
  - **何をテストするか**: 🔵 `period` が `'custom'` の場合、`customStartDate` と `customEndDate` を使用すること
  - **期待される動作**: 🔵 ユーザーが指定した期間のデータを取得する

- **入力値**: 🔵
  - `period`: `'custom'`
  - `customStartDate`: `'2025-10-01'`
  - `customEndDate`: `'2025-10-31'`
  - **入力データの意味**: 🔵 ユーザーが指定した任意の期間の統計データ

- **期待される結果**: 🔵
  - `startDate` が `'2025-10-01'`、`endDate` が `'2025-10-31'`
  - **期待結果の理由**: 🔵 ユーザーが指定した期間で統計を取得する（REQ-202）

- **テストの目的**: 🔵 カスタム期間の正確性を確認
  - **確認ポイント**: 🔵
    - `customStartDate` と `customEndDate` が使用される

#### TC-STORE-STAT-005: fetchStatistics() - エラー系

- **テスト名**: 統計データの取得が失敗し、エラー状態が設定される
  - **エラーケースの概要**: 🔵 API呼び出しが失敗した場合
  - **エラー処理の重要性**: 🔵 エラー発生時にユーザーに適切なメッセージを表示するため

- **入力値**: 🔵
  - モックAPI Clientが `Error` を投げる
  - **不正な理由**: 🔵 Backend APIのエラー
  - **実際の発生シナリオ**: 🔵 データベースエラー、タイムアウト

- **期待される結果**: 🔵
  - `isLoading` が `true` → `false` に遷移
  - `error` にエラーメッセージが設定される
  - `statistics` は変更されない（前回取得したデータが保持される）
  - **エラーメッセージの内容**: 🔵 API Clientから返されたエラーメッセージ
  - **システムの安全性**: 🔵 エラー時でも前回のデータが保持される

- **テストの目的**: 🔵 エラーハンドリングの確認
  - **品質保証の観点**: 🔵 エラー時でもアプリケーションが安全に動作すること

#### TC-STORE-STAT-006: setPeriod() - 正常系

- **テスト名**: 集計期間の変更が成功し、統計データが再取得される
  - **何をテストするか**: 🔵 StatisticsStore の `setPeriod()` アクションが期間を変更し、自動的に `fetchStatistics()` を呼ぶこと
  - **期待される動作**: 🔵 期間が変更され、新しい期間の統計データが取得される

- **入力値**: 🔵
  - `period`: `'1month'`
  - **入力データの意味**: 🔵 ユーザーが期間を変更したアクション

- **期待される結果**: 🔵
  - `period` が `'1month'` に更新される
  - `fetchStatistics()` が自動的に呼ばれる
  - 新しい期間の統計データが取得される
  - **期待結果の理由**: 🔵 期間変更時に自動的にデータを再取得することで、ユーザーが明示的に更新ボタンを押す必要がない（UX向上）

- **テストの目的**: 🔵 期間変更と自動再取得の確認
  - **確認ポイント**: 🔵
    - `period` が更新される
    - `fetchStatistics()` が呼ばれる

#### TC-STORE-STAT-007: setPeriod() - カスタム期間設定

- **テスト名**: カスタム期間の設定が成功する
  - **何をテストするか**: 🔵 `setPeriod('custom', startDate, endDate)` で `customStartDate` と `customEndDate` が更新されること
  - **期待される動作**: 🔵 カスタム期間が設定され、統計データが取得される

- **入力値**: 🔵
  - `period`: `'custom'`
  - `startDate`: `'2025-10-01'`
  - `endDate`: `'2025-10-31'`
  - **入力データの意味**: 🔵 ユーザーが指定した任意の期間

- **期待される結果**: 🔵
  - `period` が `'custom'` に更新される
  - `customStartDate` が `'2025-10-01'` に更新される
  - `customEndDate` が `'2025-10-31'` に更新される
  - `fetchStatistics()` が呼ばれる
  - **期待結果の理由**: 🔵 ユーザーが任意の期間で統計を表示できる（REQ-202）

- **テストの目的**: 🔵 カスタム期間設定の確認
  - **確認ポイント**: 🔵
    - `customStartDate` と `customEndDate` が更新される

#### TC-STORE-STAT-008: clearError() - 正常系

- **テスト名**: エラー状態が正しくクリアされる
  - **何をテストするか**: 🔵 StatisticsStore の `clearError()` アクションがエラー状態をクリアすること
  - **期待される動作**: 🔵 `error` が `null` になる

- **入力値**: 🔵
  - 事前にエラー状態が設定されている
  - **入力データの意味**: 🔵 エラー状態をクリアするアクション

- **期待される結果**: 🔵
  - `error` が `null` になる
  - **期待結果の理由**: 🔵 エラーメッセージを閉じた後、次回のエラー表示に備える

- **テストの目的**: 🔵 エラー状態のクリア機能を確認
  - **確認ポイント**: 🔵
    - エラー状態が確実にクリアされる

#### TC-STORE-STAT-009: 統計データが0件の場合（境界値）

- **テスト名**: 対戦履歴が0件の期間でもエラーにならない
  - **境界値の意味**: 🔵 統計データが存在しない場合の動作
  - **境界値での動作保証**: 🔵 ゼロ除算エラーが発生しない

- **入力値**: 🔵
  - モックAPI Clientが以下のデータを返す:
    ```json
    {
      "overall": { "totalGames": 0, "wins": 0, "losses": 0, "winRate": 0 },
      "byMyDeck": [],
      "byOpponentDeck": [],
      "byRank": [],
      "byTurn": { "先攻": {...}, "後攻": {...} },
      "opponentDeckDistribution": [],
      "dateRange": { "startDate": "2025-11-01", "endDate": "2025-11-07" }
    }
    ```
  - **境界値選択の根拠**: 🔵 対戦履歴が0件の場合
  - **実際の使用場面**: 🔵 新規ユーザー、データが存在しない期間

- **期待される結果**: 🔵
  - `statistics` が0件のデータで更新される
  - `error` は設定されない（エラーではない）
  - `overall.winRate` が0（ゼロ除算エラーが発生しない）
  - **境界での正確性**: 🔵 ゼロ除算が発生しない
  - **一貫した動作**: 🔵 0件でも統計データとして扱われる

- **テストの目的**: 🔵 0件データの適切な処理を確認
  - **堅牢性の確認**: 🔵 極端な条件下でも安全に動作すること

---

### 4. Deck Store テストケース（`frontend/src/store/deckStore.test.ts`）

#### TC-STORE-DECK-001: fetchDeckMasters() - スタブ実装の確認

- **テスト名**: デッキマスターデータ取得のスタブが正しく動作する
  - **何をテストするか**: 🔵 DeckStore の `fetchDeckMasters()` がスタブとして空配列を返すこと
  - **期待される動作**: 🔵 Phase 2実装まで、空配列が返される

- **入力値**: 🔵
  - スタブ実装（API呼び出しなし）
  - **入力データの意味**: 🔵 Phase 2で実装予定の機能

- **期待される結果**: 🔵
  - `isLoading` が `true` → `false` に遷移
  - `deckMasters` が空配列 `[]`
  - `error` が `null`
  - **期待結果の理由**: 🔵 Phase 2実装までスタブとして機能する

- **テストの目的**: 🔵 スタブ実装の動作確認
  - **確認ポイント**: 🔵
    - エラーが発生しない
    - 空配列が返される

#### TC-STORE-DECK-002: fetchMyDecks() - スタブ実装の確認

- **テスト名**: マイデッキデータ取得のスタブが正しく動作する
  - **何をテストするか**: 🔵 DeckStore の `fetchMyDecks()` がスタブとして空配列を返すこと
  - **期待される動作**: 🔵 Phase 2実装まで、空配列が返される

- **入力値**: 🔵
  - スタブ実装（API呼び出しなし）
  - **入力データの意味**: 🔵 Phase 2で実装予定の機能

- **期待される結果**: 🔵
  - `isLoading` が `true` → `false` に遷移
  - `myDecks` が空配列 `[]`
  - `error` が `null`
  - **期待結果の理由**: 🔵 Phase 2実装までスタブとして機能する

- **テストの目的**: 🔵 スタブ実装の動作確認
  - **確認ポイント**: 🔵
    - エラーが発生しない
    - 空配列が返される

#### TC-STORE-DECK-003: createMyDeck() - スタブ実装の確認

- **テスト名**: マイデッキ作成のスタブが正しく動作する
  - **何をテストするか**: 🔵 DeckStore の `createMyDeck()` がスタブとして何もしないこと
  - **期待される動作**: 🔵 Phase 2実装まで、何もしない

- **入力値**: 🔵
  - スタブ実装（API呼び出しなし）
  - **入力データの意味**: 🔵 Phase 2で実装予定の機能

- **期待される結果**: 🔵
  - `isLoading` が `true` → `false` に遷移
  - `error` が `null`
  - **期待結果の理由**: 🔵 Phase 2実装までスタブとして機能する

- **テストの目的**: 🔵 スタブ実装の動作確認
  - **確認ポイント**: 🔵
    - エラーが発生しない

#### TC-STORE-DECK-004: deleteMyDeck() - スタブ実装の確認

- **テスト名**: マイデッキ削除のスタブが正しく動作する
  - **何をテストするか**: 🔵 DeckStore の `deleteMyDeck()` がスタブとして何もしないこと
  - **期待される動作**: 🔵 Phase 2実装まで、何もしない

- **入力値**: 🔵
  - スタブ実装（API呼び出しなし）
  - **入力データの意味**: 🔵 Phase 2で実装予定の機能

- **期待される結果**: 🔵
  - `isLoading` が `true` → `false` に遷移
  - `error` が `null`
  - **期待結果の理由**: 🔵 Phase 2実装までスタブとして機能する

- **テストの目的**: 🔵 スタブ実装の動作確認
  - **確認ポイント**: 🔵
    - エラーが発生しない

#### TC-STORE-DECK-005: clearError() - 正常系

- **テスト名**: エラー状態が正しくクリアされる
  - **何をテストするか**: 🔵 DeckStore の `clearError()` アクションがエラー状態をクリアすること
  - **期待される動作**: 🔵 `error` が `null` になる

- **入力値**: 🔵
  - 事前にエラー状態が設定されている
  - **入力データの意味**: 🔵 エラー状態をクリアするアクション

- **期待される結果**: 🔵
  - `error` が `null` になる
  - **期待結果の理由**: 🔵 エラーメッセージを閉じた後、次回のエラー表示に備える

- **テストの目的**: 🔵 エラー状態のクリア機能を確認
  - **確認ポイント**: 🔵
    - エラー状態が確実にクリアされる

---

## テストケース実装時の日本語コメント指針

### テストケース開始時のコメント

```typescript
// 【テスト目的】: [このテストで何を確認するかを日本語で明記]
// 【テスト内容】: [具体的にどのような処理をテストするかを説明]
// 【期待される動作】: [正常に動作した場合の結果を説明]
// 🔵🟡🔴 [信頼性レベル]
```

### Given（準備フェーズ）のコメント

```typescript
// 【テストデータ準備】: [なぜこのデータを用意するかの理由]
// 【初期条件設定】: [テスト実行前の状態を説明]
// 【前提条件確認】: [テスト実行に必要な前提条件を明記]
```

### When（実行フェーズ）のコメント

```typescript
// 【実際の処理実行】: [どの機能/メソッドを呼び出すかを説明]
// 【処理内容】: [実行される処理の内容を日本語で説明]
// 【実行タイミング】: [なぜこのタイミングで実行するかを説明]
```

### Then（検証フェーズ）のコメント

```typescript
// 【結果検証】: [何を検証するかを具体的に説明]
// 【期待値確認】: [期待される結果とその理由を説明]
// 【品質保証】: [この検証がシステム品質にどう貢献するかを説明]
```

### 各expectステートメントのコメント

```typescript
expect(store.isLoading).toBe(true); // 【確認内容】: ローディング状態が開始される 🔵
expect(store.battleLogs).toHaveLength(1); // 【確認内容】: 1件のデータが取得される 🔵
expect(store.error).toBeNull(); // 【確認内容】: エラーが発生しない 🔵
```

### セットアップ・クリーンアップのコメント

```typescript
beforeEach(() => {
  // 【テスト前準備】: 各テスト実行前にモックをリセットし、一貫したテスト条件を保証
  // 【環境初期化】: テスト環境をクリーンな状態にする理由と方法
  vi.clearAllMocks();
});

afterEach(() => {
  // 【テスト後処理】: 各テスト実行後にクリーンアップ作業の説明
  // 【状態復元】: 次のテストに影響しないよう状態を復元する理由
  vi.restoreAllMocks();
});
```

---

## テストケース分類サマリー

### 正常系テストケース: 20件

- **API Client**: 3件（GET、POST、DELETE）
- **Battle Log Store**: 4件（fetchBattleLogs、createBattleLog、deleteBattleLog、setPreviousInput、clearError）
- **Statistics Store**: 8件（fetchStatistics x 4期間、setPeriod x 2、clearError、0件データ）
- **Deck Store**: 5件（fetchDeckMasters、fetchMyDecks、createMyDeck、deleteMyDeck、clearError）

### 異常系テストケース: 6件

- **API Client**: 3件（400エラー、ネットワークエラー、500エラー）
- **Battle Log Store**: 2件（fetchBattleLogsエラー、createBattleLogエラー、deleteBattleLogエラー）
- **Statistics Store**: 1件（fetchStatisticsエラー）

### 境界値テストケース: 2件

- **Battle Log Store**: 1件（複数のAPI呼び出しが連続）
- **Statistics Store**: 1件（0件データ）

### 合計: 28件

**目標達成状況**: ✅ 要件定義書で定義された15ケース以上を大幅に上回る28ケースを定義

---

## 品質判定

### ✅ 高品質: 実装可能

#### テストケース分類
- **正常系**: 20件（API Client、各ストアの主要アクション）
- **異常系**: 6件（APIエラー、ネットワークエラー、バリデーションエラー）
- **境界値**: 2件（連続API呼び出し、0件データ）
- **評価**: ✅ すべての分類が網羅されている

#### 期待値定義
- **各テストケースの期待値**: 明確に定義されている
- **エラーケースの期待値**: エラーメッセージの内容まで定義されている
- **評価**: ✅ すべての期待値が明確

#### 技術選択
- **プログラミング言語**: TypeScript 5.9+ ✅
- **テストフレームワーク**: Vitest ✅
- **モックライブラリ**: Vitest組み込み（`vi.mock()`、`vi.fn()`）✅
- **評価**: ✅ 技術スタックが確定している

#### 実装可能性
- **既存テストの参照**: Backend APIの統合テスト（`backend/tests/integration/api-flow.test.ts`）を参考にできる ✅
- **型定義の利用**: `frontend/src/types/index.ts` で型定義済み ✅
- **テストパターン**: Arrange-Act-Assert パターンを採用 ✅
- **評価**: ✅ 現在の技術スタックで実現可能

#### テストカバレッジ目標
- **目標**: 70%以上
- **評価**: ✅ 28件のテストケースで主要機能を網羅しており、目標達成可能

### 信頼性レベルサマリー

- 🔵 **青信号**（ほぼ推測なし）: 95%
  - API Clientの仕様（要件定義書で明確化）
  - 各ストアのアクション仕様（要件定義書で明確化）
  - エラーハンドリングの仕様（要件定義書で明確化）
  - Backend APIとの連携仕様（Backend API要件定義書で明確化）
  - テストフレームワークの選定（技術スタックで確定）

- 🟡 **黄信号**（妥当な推測）: 5%
  - 複数のAPI呼び出しが連続した場合の動作（要件定義書に明記なし、Zustandのデフォルト動作に任せる）
  - Phase 2のDeck Store機能（現在はスタブ実装のみ）

- 🔴 **赤信号**（推測）: 0%

---

## 次のステップ

✅ **テストケース定義完了**

次のお勧めステップ: `/tsumiki:tdd-red` でRedフェーズ（失敗テスト作成）を開始します。

### 実装順序（推奨）

1. **API Client テスト** (`frontend/src/api/client.test.ts`)
   - 基盤となる通信層のため、最初に実装
   - 6ケース

2. **Battle Log Store テスト** (`frontend/src/store/battleLogStore.test.ts`)
   - 最も重要な機能のため、次に実装
   - 9ケース

3. **Statistics Store テスト** (`frontend/src/store/statisticsStore.test.ts`)
   - Battle Log Storeに依存するため、3番目に実装
   - 9ケース

4. **Deck Store テスト** (`frontend/src/store/deckStore.test.ts`)
   - Phase 2向けスタブのため、最後に実装
   - 5ケース

### テスト実行コマンド

```bash
# 単体テスト実行
cd frontend
pnpm test

# テストカバレッジ確認
pnpm test -- --coverage

# ウォッチモード（開発時）
pnpm test -- --watch

# 型チェック
pnpm type-check

# Lintチェック
pnpm lint
```

---

**作成日**: 2025-11-05
**更新日**: 2025-11-05
**ステータス**: ✅ 完了
