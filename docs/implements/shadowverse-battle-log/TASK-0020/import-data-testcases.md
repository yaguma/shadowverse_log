# TASK-0020: Import機能実装 - テストケース定義書

## 生成情報
- **生成日**: 2025-11-10
- **生成ツール**: tsumiki:tdd-testcases
- **タスクID**: TASK-0020
- **機能名**: Import機能（データインポート）
- **フェーズ**: Phase 1

---

## 開発言語・フレームワーク

### プログラミング言語
🔵 **青信号**: tech-stack.mdより

- **言語**: TypeScript 5.7+
- **言語選択の理由**: 型安全性を確保し、開発速度を維持するため（プロジェクト標準）
- **テストに適した機能**: 型推論によるテストコードの品質向上、IDEの補完機能活用

### テストフレームワーク
🔵 **青信号**: tech-stack.mdより

- **テストフレームワーク**: Vitest + React Testing Library
- **フレームワーク選択の理由**: Vite 6.xとの統合、高速なテスト実行、Jest互換API
- **テスト実行環境**: JSDOM（ブラウザ環境のシミュレーション）

---

## テストケース一覧

### 📋 テストケース総数と分類

- **総数**: 22ケース
- **正常系**: 9ケース（TC-IMPORT-001〜009）
- **異常系**: 8ケース（TC-IMPORT-010〜017）
- **境界値/エッジケース**: 5ケース（TC-IMPORT-018〜022）

---

## 1. 正常系テストケース（基本的な動作）

### TC-IMPORT-001: JSON形式ファイルの正常インポート

🔵 **青信号**: REQ-301、acceptance-criteria.md L236より

- **テスト名**: JSON形式ファイルの正常インポート
  - **何をテストするか**: JSON形式のファイルから対戦履歴データを正常にインポートできること
  - **期待される動作**: ファイル選択 → パース → バリデーション → API送信 → 成功メッセージ表示

- **入力値**:
  ```json
  [
    {
      "id": "log_001",
      "date": "2025/10/23",
      "battleType": "ランクマッチ",
      "rank": "ダイアモンド",
      "group": "A",
      "myDeckId": "my_deck_001",
      "turn": "先行",
      "result": "WIN",
      "opponentDeckId": "deck_001"
    }
  ]
  ```
  - **入力データの意味**: 正しいBattleLog形式の1件のデータを含むJSON
  - **ファイルサイズ**: 約200バイト（10MB制限内）

- **期待される結果**:
  - インポート成功: `{ imported: 1, skipped: 0, total: 1 }`
  - 成功メッセージ表示: 「1件のデータをインポートしました」
  - 対戦履歴一覧画面にデータが反映される
  - **期待結果の理由**: REQ-301の要件を満たすため

- **テストの目的**: JSON形式の基本的なインポート処理が正常に動作することを確認
  - **確認ポイント**: ファイルパース、データバリデーション、API通信、UI更新

---

### TC-IMPORT-002: CSV形式ファイルの正常インポート

🔵 **青信号**: REQ-302、acceptance-criteria.md L237より

- **テスト名**: CSV形式ファイルの正常インポート
  - **何をテストするか**: CSV形式のファイルから対戦履歴データを正常にインポートできること
  - **期待される動作**: CSV パース → JSON変換 → バリデーション → API送信 → 成功メッセージ表示

- **入力値**:
  ```csv
  id,date,battleType,rank,group,myDeckId,turn,result,opponentDeckId
  log_001,2025/10/23,ランクマッチ,ダイアモンド,A,my_deck_001,先行,WIN,deck_001
  ```
  - **入力データの意味**: 正しいヘッダー + 1件のデータを含むCSV
  - **文字コード**: UTF-8（日本語対応）

- **期待される結果**:
  - CSV → JSON変換成功
  - インポート成功: `{ imported: 1, skipped: 0, total: 1 }`
  - 成功メッセージ表示: 「1件のデータをインポートしました」
  - **期待結果の理由**: REQ-302の要件を満たすため

- **テストの目的**: CSV形式の基本的なインポート処理が正常に動作することを確認
  - **確認ポイント**: CSVパーサーの動作、ヘッダー行の認識、データ型変換

---

### TC-IMPORT-003: 大量データ（100件）の正常インポート

🔵 **青信号**: acceptance-criteria.md L238、NFR-003（5秒以内）より

- **テスト名**: 大量データ（100件）の正常インポート
  - **何をテストするか**: 100件のデータを一括インポートできること
  - **期待される動作**: 大量データでもパフォーマンス要件（5秒以内）を満たすこと

- **入力値**: 100件のBattleLogデータを含むJSON配列
  - **入力データの意味**: 実際の使用シナリオ（初回セットアップ時の一括登録）を想定
  - **ファイルサイズ**: 約20KB（10MB制限内）

- **期待される結果**:
  - インポート成功: `{ imported: 100, skipped: 0, total: 100 }`
  - 成功メッセージ表示: 「100件のデータをインポートしました」
  - **処理時間**: 5秒以内（パフォーマンス要件NFR-003）
  - **期待結果の理由**: 大量データ処理の性能を保証するため

- **テストの目的**: 大量データのインポート処理が要件を満たすことを確認
  - **確認ポイント**: パフォーマンス、メモリ使用量、UI応答性

---

### TC-IMPORT-004: 複数ファイルの連続インポート

🟡 **黄信号**: 実運用シナリオから妥当な推測

- **テスト名**: 複数ファイルの連続インポート
  - **何をテストするか**: 複数のファイルを連続してインポートできること
  - **期待される動作**: 1回目のインポート完了後、2回目のインポートが正常に実行される

- **入力値**:
  - 1回目: 50件のデータを含むJSON
  - 2回目: 30件のデータを含むCSV
  - **入力データの意味**: 分割されたデータを段階的にインポートするシナリオ

- **期待される結果**:
  - 1回目インポート成功: `{ imported: 50, skipped: 0, total: 50 }`
  - 2回目インポート成功: `{ imported: 30, skipped: 0, total: 30 }`
  - 最終的に80件のデータが登録される
  - **期待結果の理由**: 連続操作時の状態管理が正しく動作することを保証

- **テストの目的**: 連続インポート時の状態管理とデータ整合性を確認
  - **確認ポイント**: 前回インポート結果のクリア、状態のリセット、累積データの正確性

---

### TC-IMPORT-005: インポート後の一覧画面データ反映

🔵 **青信号**: acceptance-criteria.md「一覧画面にインポートされたデータが表示される」より

- **テスト名**: インポート後の一覧画面データ反映
  - **何をテストするか**: インポート成功後、対戦履歴一覧画面にデータが即座に反映されること
  - **期待される動作**: インポート完了 → 一覧画面更新 → 新規データ表示

- **入力値**: 10件のデータを含むJSON
  - **入力データの意味**: 一覧表示で視認できる適度なデータ量

- **期待される結果**:
  - インポート成功メッセージ表示
  - 対戦履歴一覧に10件のデータが追加表示される
  - ページリロードなしで即座に反映される（Zustand状態更新）
  - **期待結果の理由**: UX要件（リアルタイム更新）を満たすため

- **テストの目的**: インポート後のUI更新とデータ同期を確認
  - **確認ポイント**: Zustand storeの更新、コンポーネント再レンダリング、データ整合性

---

### TC-IMPORT-006: 日付形式YYYY/MM/DDの正常パース

🔵 **青信号**: interfaces.ts BattleLog.date型定義より

- **テスト名**: 日付形式YYYY/MM/DDの正常パース
  - **何をテストするか**: YYYY/MM/DD形式の日付文字列が正しくパースされること
  - **期待される動作**: "2025/10/23" → Date型変換 → バリデーション成功

- **入力値**: `{ date: "2025/10/23", ... }`
  - **入力データの意味**: システム標準の日付形式（スラッシュ区切り）

- **期待される結果**:
  - 日付バリデーション成功
  - インポート成功
  - **期待結果の理由**: 日付形式の統一性を保証するため

- **テストの目的**: 日付形式の正確な検証とパースを確認
  - **確認ポイント**: 正規表現バリデーション（`/^\d{4}\/\d{2}\/\d{2}$/`）

---

### TC-IMPORT-007: すべてのBattleType値の正常インポート

🔵 **青信号**: interfaces.ts BattleType型定義より

- **テスト名**: すべてのBattleType値の正常インポート
  - **何をテストするか**: "ランクマッチ", "対戦台", "ロビー大会" の3種類すべてが正常にインポートされること
  - **期待される動作**: Enum値のバリデーションが正しく動作すること

- **入力値**: 3件のデータ（各BattleTypeを1件ずつ）
  - **入力データの意味**: すべての対戦タイプをカバーする網羅的テスト

- **期待される結果**:
  - インポート成功: `{ imported: 3, skipped: 0, total: 3 }`
  - 各BattleTypeが正しく保存される
  - **期待結果の理由**: Enum値のバリデーションロジックの正確性を保証

- **テストの目的**: Enum型のバリデーションが正しく動作することを確認
  - **確認ポイント**: BattleType, Rank, Group, Turn, BattleResultのEnum値検証

---

### TC-IMPORT-008: 最小限の必須フィールドのみのデータインポート

🟡 **黄信号**: 最小限のデータ構造から妥当な推測

- **テスト名**: 最小限の必須フィールドのみのデータインポート
  - **何をテストするか**: 必須フィールド（9項目）のみを含むデータが正常にインポートされること
  - **期待される動作**: オプションフィールドがなくてもバリデーション成功

- **入力値**: 必須フィールド9項目のみを含むJSON
  ```json
  {
    "id": "log_001",
    "date": "2025/10/23",
    "battleType": "ランクマッチ",
    "rank": "ダイアモンド",
    "group": "A",
    "myDeckId": "my_deck_001",
    "turn": "先行",
    "result": "WIN",
    "opponentDeckId": "deck_001"
  }
  ```
  - **入力データの意味**: 最小限の情報でデータを登録するケース

- **期待される結果**:
  - インポート成功
  - 不要なフィールド追加によるエラーが発生しない
  - **期待結果の理由**: データ構造の柔軟性を確保するため

- **テストの目的**: 必須フィールドの正確な識別とバリデーションを確認
  - **確認ポイント**: 必須フィールド検証、オプションフィールドの無視

---

### TC-IMPORT-009: 成功メッセージの正確な件数表示

🔵 **青信号**: acceptance-criteria.md「○件のデータをインポートしました」より

- **テスト名**: 成功メッセージの正確な件数表示
  - **何をテストするか**: インポート成功メッセージに正確な件数が表示されること
  - **期待される動作**: インポート件数 = メッセージ表示件数

- **入力値**: 25件のデータを含むJSON
  - **入力データの意味**: 表示件数の正確性を検証するための中程度のデータ量

- **期待される結果**:
  - 成功メッセージ: 「25件のデータをインポートしました」
  - UI上の件数表示が正確
  - **期待結果の理由**: ユーザーへの正確なフィードバックを提供するため

- **テストの目的**: UI表示の正確性とユーザーフィードバックの品質を確認
  - **確認ポイント**: メッセージテキストの正確性、件数計算ロジック

---

## 2. 異常系テストケース（エラーハンドリング）

### TC-IMPORT-010: JSON形式エラー（不正なJSON）

🔵 **青信号**: acceptance-criteria.md L239、REQ-404より

- **テスト名**: JSON形式エラー（不正なJSON）
  - **エラーケースの概要**: 不正なJSON形式のファイルをインポートしようとした場合
  - **エラー処理の重要性**: ユーザーに分かりやすいエラーメッセージを表示し、システムの安全性を保つ

- **入力値**: `{invalid json` (閉じ括弧なし)
  - **不正な理由**: JSON.parse()がSyntaxErrorを投げる不正な構文
  - **実際の発生シナリオ**: ファイル破損、手動編集ミス、エクスポート失敗

- **期待される結果**:
  - エラーメッセージ表示: 「JSON形式が不正です」
  - インポート処理が中断される
  - データは保存されない（ロールバック）
  - **エラーメッセージの内容**: ユーザーが理解しやすい日本語メッセージ
  - **システムの安全性**: 不正データが混入しない

- **テストの目的**: JSON形式エラーの適切なハンドリングを確認
  - **品質保証の観点**: データ整合性の保護、ユーザーへの適切なフィードバック

---

### TC-IMPORT-011: CSV形式エラー（ヘッダー不正）

🔵 **青信号**: acceptance-criteria.md L240、REQ-404より

- **テスト名**: CSV形式エラー（ヘッダー不正）
  - **エラーケースの概要**: CSVヘッダー行が不正な場合
  - **エラー処理の重要性**: CSVパーサーのエラー検出能力を検証

- **入力値**:
  ```csv
  invalid,header,names
  log_001,2025/10/23,ランクマッチ,...
  ```
  - **不正な理由**: 必須ヘッダー（id, date, battleType等）が欠けている
  - **実際の発生シナリオ**: 別システムからのエクスポートファイル、Excel保存ミス

- **期待される結果**:
  - エラーメッセージ表示: 「CSV形式が不正です」
  - 具体的なエラー内容: 「必須ヘッダーが見つかりません: id, date, battleType」
  - インポート処理が中断される
  - **エラーメッセージの内容**: 不足しているヘッダー名を具体的に表示
  - **システムの安全性**: 不完全なデータを受け入れない

- **テストの目的**: CSV形式のバリデーションとエラー検出を確認
  - **品質保証の観点**: データ構造の整合性チェック、詳細なエラー報告

---

### TC-IMPORT-012: 必須フィールド欠落エラー（dateフィールド）

🔵 **青信号**: acceptance-criteria.md L241、REQ-303より

- **テスト名**: 必須フィールド欠落エラー（dateフィールド）
  - **エラーケースの概要**: 必須フィールド（date）が欠けているデータが含まれる場合
  - **エラー処理の重要性**: データの完全性を保証し、不完全なデータの混入を防ぐ

- **入力値**:
  ```json
  [
    {
      "id": "log_001",
      // "date" フィールドが欠けている
      "battleType": "ランクマッチ",
      ...
    }
  ]
  ```
  - **不正な理由**: BattleLog型の必須フィールドdateが存在しない
  - **実際の発生シナリオ**: 手動編集ミス、プログラムバグによる不完全データ

- **期待される結果**:
  - エラーメッセージ表示: 「ファイル形式が不正です。1行目: dateフィールドが必要です。」
  - **行番号表示**: 具体的な行番号（1行目）を表示
  - **フィールド名表示**: 欠けているフィールド名（date）を表示
  - インポート処理が中断される
  - **エラーメッセージの内容**: 行番号とフィールド名を含む詳細なエラー情報
  - **システムの安全性**: 不完全なデータをデータベースに保存しない

- **テストの目的**: 必須フィールドのバリデーションとエラー報告の正確性を確認
  - **品質保証の観点**: データ完全性の保証、デバッグ容易性の向上

---

### TC-IMPORT-013: 日付形式エラー（YYYY-MM-DD形式）

🔵 **青信号**: interfaces.ts date型定義、requirements.mdより

- **テスト名**: 日付形式エラー（YYYY-MM-DD形式）
  - **エラーケースの概要**: システム標準外の日付形式（YYYY-MM-DD）が使用された場合
  - **エラー処理の重要性**: 日付形式の統一性を保ち、データの一貫性を確保

- **入力値**: `{ date: "2025-10-23", ... }` (ハイフン区切り)
  - **不正な理由**: システム標準はYYYY/MM/DD形式（スラッシュ区切り）
  - **実際の発生シナリオ**: ISO 8601形式での入力、他システムからのデータ移行

- **期待される結果**:
  - エラーメッセージ表示: 「日付形式が不正です。YYYY/MM/DD形式で入力してください。」
  - 具体的なエラー箇所: 「1行目のdateフィールド」
  - インポート処理が中断される
  - **エラーメッセージの内容**: 正しい形式の例を含む分かりやすいメッセージ
  - **システムの安全性**: 日付形式の不整合によるバグを防止

- **テストの目的**: 日付形式のバリデーションロジックの正確性を確認
  - **品質保証の観点**: データフォーマットの統一、パース エラー防止

---

### TC-IMPORT-014: Enum値エラー（不正なbattleType）

🔵 **青信号**: interfaces.ts BattleType型定義より

- **テスト名**: Enum値エラー（不正なbattleType）
  - **エラーケースの概要**: BattleType Enumに定義されていない値が使用された場合
  - **エラー処理の重要性**: Enum値の整合性を保ち、予期しないデータを排除

- **入力値**: `{ battleType: "カジュアルマッチ", ... }` (未定義の値)
  - **不正な理由**: BattleTypeは "ランクマッチ", "対戦台", "ロビー大会" のみ許可
  - **実際の発生シナリオ**: 他システムからのデータ、手動入力ミス

- **期待される結果**:
  - エラーメッセージ表示: 「battleTypeの値が不正です。許可されている値: ランクマッチ, 対戦台, ロビー大会」
  - 具体的なエラー箇所: 「1行目のbattleTypeフィールド」
  - インポート処理が中断される
  - **エラーメッセージの内容**: 許可されている値のリストを表示
  - **システムの安全性**: 不正なEnum値によるアプリケーションエラーを防止

- **テストの目的**: Enum型のバリデーションとエラー報告を確認
  - **品質保証の観点**: 型安全性の保証、データ品質の向上

---

### TC-IMPORT-015: ファイルサイズ超過エラー（10MB以上）

🔵 **青信号**: acceptance-criteria.md L242、NFR-102（セキュリティ要件）より

- **テスト名**: ファイルサイズ超過エラー（10MB以上）
  - **エラーケースの概要**: 10MBを超える巨大なファイルがアップロードされた場合
  - **エラー処理の重要性**: DoS攻撃防止、サーバーリソース保護

- **入力値**: 11MBのJSONファイル（約50,000件のデータ）
  - **不正な理由**: FILE_SIZE_LIMIT = 10MB を超過
  - **実際の発生シナリオ**: 悪意のある攻撃、誤った大容量ファイルの選択

- **期待される結果**:
  - エラーメッセージ表示: 「ファイルサイズが10MBを超えています」
  - **クライアント側でブロック**: サーバー送信前にファイルサイズをチェック
  - アップロード処理が開始されない
  - **エラーメッセージの内容**: ファイルサイズ制限を明示
  - **システムの安全性**: サーバーリソースの保護、DoS攻撃防止

- **テストの目的**: ファイルサイズ制限のバリデーションとセキュリティ対策を確認
  - **品質保証の観点**: セキュリティ要件の遵守、リソース保護

---

### TC-IMPORT-016: ネットワークエラー（API通信失敗）

🟡 **黄信号**: 一般的なエラーハンドリング要件から妥当な推測

- **テスト名**: ネットワークエラー（API通信失敗）
  - **エラーケースの概要**: API通信が失敗した場合（タイムアウト、ネットワーク切断等）
  - **エラー処理の重要性**: ネットワーク障害時のユーザー体験向上、再試行の促進

- **入力値**: 正常なJSONファイル
  - **実際の発生シナリオ**: ネットワーク切断、APIサーバーダウン、タイムアウト

- **期待される結果**:
  - エラーメッセージ表示: 「ネットワークエラーが発生しました。再度お試しください。」
  - **リトライボタン表示**: ユーザーが再試行できるUI
  - データは保存されない
  - ローディング状態が解除される
  - **エラーメッセージの内容**: 再試行を促すメッセージ
  - **システムの安全性**: 不完全な状態でデータが保存されない

- **テストの目的**: ネットワークエラー時の適切なエラーハンドリングを確認
  - **品質保証の観点**: ユーザー体験の向上、エラーリカバリー

---

### TC-IMPORT-017: サーバー側バリデーションエラー（400 Bad Request）

🔵 **青信号**: dataflow.md、api-endpoints.mdより

- **テスト名**: サーバー側バリデーションエラー（400 Bad Request）
  - **エラーケースの概要**: クライアント側バリデーションをパスしたが、サーバー側で拒否された場合
  - **エラー処理の重要性**: 二重バリデーションによるデータ整合性の保証

- **入力値**: クライアント側は正常だがサーバー側で不正とされるデータ
  - **実際の発生シナリオ**: デッキID存在確認失敗、データ整合性チェック失敗

- **期待される結果**:
  - エラーメッセージ表示: 「データの検証に失敗しました」
  - **詳細エラー表示**: サーバーから返却されたエラー詳細を表示
  - 例: 「3行目: myDeckIdが存在しません」
  - インポート処理が中断される
  - **エラーメッセージの内容**: サーバーエラーレスポンスの詳細を含む
  - **システムの安全性**: 二重バリデーションによるデータ品質の保証

- **テストの目的**: サーバー側バリデーションエラーの適切な表示を確認
  - **品質保証の観点**: クライアント・サーバー連携、エラー情報の正確な伝達

---

## 3. 境界値/エッジケーステストケース

### TC-IMPORT-018: 空データ（0件）のインポート

🔵 **青信号**: acceptance-criteria.md L243より

- **テスト名**: 空データ（0件）のインポート
  - **境界値の意味**: データ件数の最小値（0件）
  - **境界値での動作保証**: 空配列でもエラーにならないこと

- **入力値**: `[]` (空配列のJSON)
  - **境界値選択の根拠**: データ件数の最小境界値
  - **実際の使用場面**: 誤ってフィルタリングされた空ファイルの選択

- **期待される結果**:
  - 警告メッセージ表示: 「インポートするデータがありません」
  - **エラー扱いではない**: 警告として処理され、システムは安定動作
  - インポート処理は実行されるが、件数は0件
  - **境界での正確性**: 空データでもクラッシュしない
  - **一貫した動作**: エラーではなく警告として統一的に処理

- **テストの目的**: 空データ時の適切なハンドリングを確認
  - **堅牢性の確認**: 空データでもシステムが安定動作すること

---

### TC-IMPORT-019: 重複ID検出とスキップモード

🔵 **青信号**: acceptance-criteria.md L244、interfaces.ts ImportDataRequest.modeより

- **テスト名**: 重複ID検出とスキップモード
  - **境界値の意味**: ID重複時の動作（スキップ vs 上書き）
  - **境界値での動作保証**: 重複ID時の選択肢が正しく動作すること

- **入力値**:
  - 既存データ: `{ id: "log_001", ... }`
  - インポートデータ: `{ id: "log_001", date: "2025/10/24", ... }` (同じID、異なる内容)
  - **境界値選択の根拠**: ID一意性制約の境界
  - **実際の使用場面**: 同じファイルを誤って再インポート、更新データの取り込み

- **期待される結果**:
  - **409 Conflict レスポンス**: サーバーから重複ID検出通知
  - 重複確認ダイアログ表示: 「重複するIDが見つかりました: log_001」
  - **選択肢表示**: 「上書き」または「スキップ」ボタン
  - **スキップ選択時**: `{ mode: "skip" }` でリクエスト送信
  - 結果: `{ imported: 0, skipped: 1, total: 1 }`
  - メッセージ表示: 「0件のデータをインポートしました（スキップ: 1件）」
  - **境界での正確性**: 重複ID処理ロジックが正確に動作
  - **一貫した動作**: スキップモードで既存データが保護される

- **テストの目的**: ID重複時のスキップモードの動作を確認
  - **堅牢性の確認**: データ整合性の保護、ユーザーの選択権の尊重

---

### TC-IMPORT-020: 重複ID検出と上書きモード

🔵 **青信号**: acceptance-criteria.md L244、interfaces.ts ImportDataRequest.modeより

- **テスト名**: 重複ID検出と上書きモード
  - **境界値の意味**: ID重複時の動作（上書き選択）
  - **境界値での動作保証**: 上書きモードで既存データが正しく更新されること

- **入力値**:
  - 既存データ: `{ id: "log_001", date: "2025/10/23", result: "WIN" }`
  - インポートデータ: `{ id: "log_001", date: "2025/10/24", result: "LOSE" }` (同じID、異なる内容)
  - **境界値選択の根拠**: データ更新処理の境界
  - **実際の使用場面**: データ修正、最新データでの置き換え

- **期待される結果**:
  - 重複確認ダイアログ表示: 「重複するIDが見つかりました: log_001」
  - **上書き選択時**: `{ mode: "overwrite" }` でリクエスト送信
  - 結果: `{ imported: 1, skipped: 0, total: 1 }`
  - **既存データが更新**: date="2025/10/24", result="LOSE" に変更
  - メッセージ表示: 「1件のデータを上書きしました（重複: 1件）」
  - **境界での正確性**: 上書き処理が正確に実行される
  - **一貫した動作**: 新しいデータが既存データを置き換える

- **テストの目的**: ID重複時の上書きモードの動作を確認
  - **堅牢性の確認**: データ更新ロジックの正確性、データ整合性の保持

---

### TC-IMPORT-021: ファイルサイズ境界値（9.99MB）

🟡 **黄信号**: ファイルサイズ制限の境界値から妥当な推測

- **テスト名**: ファイルサイズ境界値（9.99MB）
  - **境界値の意味**: ファイルサイズ制限の上限境界（10MB未満）
  - **境界値での動作保証**: 制限ギリギリでも正常にインポートされること

- **入力値**: 9.99MBのJSONファイル（約45,000件のデータ）
  - **境界値選択の根拠**: FILE_SIZE_LIMIT = 10MBの直下
  - **実際の使用場面**: 大量データの一括インポート

- **期待される結果**:
  - ファイルサイズチェック成功（10MB未満）
  - インポート処理が正常に実行される
  - パフォーマンス要件（5秒以内）を満たすこと
  - **境界での正確性**: 境界値での判定ロジックが正確
  - **一貫した動作**: 境界値でも安定動作

- **テストの目的**: ファイルサイズ制限の境界値での動作を確認
  - **堅牢性の確認**: 境界値での判定精度、大容量データの処理能力

---

### TC-IMPORT-022: 未来の日付の検証

🔵 **青信号**: REQ-401（未来日付エラー）より

- **テスト名**: 未来の日付の検証
  - **境界値の意味**: 日付の上限境界（今日の日付）
  - **境界値での動作保証**: 未来の日付がエラーとして検出されること

- **入力値**: `{ date: "2099/12/31", ... }` (明らかに未来の日付)
  - **境界値選択の根拠**: システムは過去の対戦履歴のみを扱う
  - **実際の使用場面**: 手動入力ミス、日付の誤設定

- **期待される結果**:
  - エラーメッセージ表示: 「未来の日付は入力できません」
  - 具体的なエラー箇所: 「1行目のdateフィールド」
  - インポート処理が中断される
  - **境界での正確性**: 今日の日付との比較ロジックが正確
  - **一貫した動作**: 未来日付は一律拒否

- **テストの目的**: 日付の妥当性検証（未来日付の拒否）を確認
  - **堅牢性の確認**: 論理的に不正なデータの排除、データ品質の向上

---

## テストケース実装時の日本語コメント指針

以下のコメントパターンを各テストケースに適用します：

### テストケース開始時のコメント例

```typescript
// 【テスト目的】: JSON形式のファイルから対戦履歴データを正常にインポートできることを確認
// 【テスト内容】: ファイル選択 → JSON パース → バリデーション → API送信 → 成功メッセージ表示の一連の処理
// 【期待される動作】: インポート成功、1件のデータが登録され、成功メッセージが表示される
// 🔵 信頼性レベル: REQ-301、acceptance-criteria.md L236 に基づく
```

### Given（準備フェーズ）のコメント例

```typescript
// 【テストデータ準備】: 正しいBattleLog形式の1件のデータを含むJSONファイルを作成
// 【初期条件設定】: 既存の対戦履歴データは0件の状態
// 【前提条件確認】: Zustand storeがモックされ、createBattleLog関数が利用可能
```

### When（実行フェーズ）のコメント例

```typescript
// 【実際の処理実行】: ファイル選択ダイアログでJSONファイルを選択し、インポート実行ボタンをクリック
// 【処理内容】: useImportフックのimportData関数を呼び出し、ファイルをパース→バリデーション→API送信
// 【実行タイミング】: ファイル選択後、ユーザーが「インポート実行」ボタンをクリックしたタイミング
```

### Then（検証フェーズ）のコメント例

```typescript
// 【結果検証】: インポート成功メッセージが表示され、対戦履歴一覧に1件のデータが追加されることを確認
// 【期待値確認】: imported=1, skipped=0, total=1 の結果が返却される
// 【品質保証】: ファイルパース、バリデーション、API通信、UI更新の全工程が正常に動作することを保証
```

### 各expectステートメントのコメント例

```typescript
// 【検証項目】: インポート成功件数が1件であることを確認
// 🔵 信頼性レベル: acceptance-criteria.md L236 に基づく
expect(result.imported).toBe(1); // 【確認内容】: 正しく1件のデータがインポートされた

// 【検証項目】: 成功メッセージが正確に表示されることを確認
// 🔵 信頼性レベル: acceptance-criteria.md「○件のデータをインポートしました」に基づく
expect(screen.getByText('1件のデータをインポートしました')).toBeInTheDocument(); // 【確認内容】: ユーザーに正確なフィードバックが提供される
```

---

## テストケース実装順序（優先度）

### Critical（最優先）
1. TC-IMPORT-001: JSON形式ファイルの正常インポート
2. TC-IMPORT-002: CSV形式ファイルの正常インポート
3. TC-IMPORT-010: JSON形式エラー
4. TC-IMPORT-012: 必須フィールド欠落エラー
5. TC-IMPORT-015: ファイルサイズ超過エラー

### High（高優先度）
6. TC-IMPORT-003: 大量データ（100件）の正常インポート
7. TC-IMPORT-005: インポート後の一覧画面データ反映
8. TC-IMPORT-013: 日付形式エラー
9. TC-IMPORT-018: 空データ（0件）のインポート
10. TC-IMPORT-019: 重複ID検出とスキップモード
11. TC-IMPORT-020: 重複ID検出と上書きモード

### Medium（中優先度）
12. TC-IMPORT-006: 日付形式YYYY/MM/DDの正常パース
13. TC-IMPORT-007: すべてのBattleType値の正常インポート
14. TC-IMPORT-011: CSV形式エラー（ヘッダー不正）
15. TC-IMPORT-014: Enum値エラー
16. TC-IMPORT-016: ネットワークエラー
17. TC-IMPORT-022: 未来の日付の検証

### Low（低優先度）
18. TC-IMPORT-004: 複数ファイルの連続インポート
19. TC-IMPORT-008: 最小限の必須フィールドのみのデータインポート
20. TC-IMPORT-009: 成功メッセージの正確な件数表示
21. TC-IMPORT-017: サーバー側バリデーションエラー
22. TC-IMPORT-021: ファイルサイズ境界値（9.99MB）

---

## 品質判定

### ✅ 高品質

**テストケース分類**:
- ✅ 正常系: 9ケース（基本的な動作を網羅）
- ✅ 異常系: 8ケース（エラーハンドリングを網羅）
- ✅ 境界値/エッジケース: 5ケース（境界条件を網羅）

**期待値定義**:
- ✅ 各テストケースの期待値が明確（成功メッセージ、エラーメッセージ、処理結果）
- ✅ 具体的な値とフォーマットを記載
- ✅ 期待結果の理由を明記

**技術選択**:
- ✅ プログラミング言語: TypeScript 5.7+（プロジェクト標準）
- ✅ テストフレームワーク: Vitest + React Testing Library（プロジェクト標準）
- ✅ 実装可能性: 現在の技術スタックで100%実現可能

**実装可能性**:
- ✅ 既存のテストパターン（BattleLogForm.test.tsx）を参考に実装可能
- ✅ Zustand storeのモック、API通信のモック、ファイル選択のモックが利用可能
- ✅ React Testing Libraryの標準機能で全テストケースを実装可能

---

## 次のステップ

次のお勧めステップ: **`/tsumiki:tdd-red`** でRedフェーズ（失敗テスト作成）を開始します。

Redフェーズでは、以下を実施します：
1. ✅ テストケースを優先度順に実装（Critical → High → Medium → Low）
2. ✅ 実装前なので**すべてのテストが失敗する**ことを確認
3. ✅ テスト失敗メッセージの内容を確認し、実装すべき機能を明確化
4. ✅ テストコードの品質を確認（コメント充実度、可読性、保守性）

---

## 更新履歴

- **2025-11-10**: 初版作成（tsumiki:tdd-testcases により自動生成）
  - 要件定義書（import-data-requirements.md）から22テストケースを抽出
  - 正常系9ケース、異常系8ケース、境界値/エッジケース5ケースに分類
  - 優先度順（Critical, High, Medium, Low）に整理
  - 信頼性レベル（🔵🟡🔴）を全テストケースに付与
  - 詳細な日本語コメント指針を作成
