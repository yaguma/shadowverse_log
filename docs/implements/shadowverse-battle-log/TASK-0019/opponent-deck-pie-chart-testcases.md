# TASK-0019 対戦相手デッキ分布円グラフ テストケース定義書

## 概要

このドキュメントはTASK-0019「Statistics Dashboard実装 - グラフ表示」の詳細なテストケースを定義します。TDD（テスト駆動開発）プロセスに従い、要件網羅率と機能網羅率を最大化するため、正常系・異常系・境界値テストケースを網羅的に洗い出します。

**タスクID**: TASK-0019
**機能名**: OpponentDeckPieChart（対戦相手デッキ分布円グラフ）
**開発方針**: TDD（Red → Green → Refactor）
**関連要件定義**: [📋 task-0019-requirements.md](../../../spec/task-0019-requirements.md)
**関連受け入れ基準**: [✅ task-0019-acceptance-criteria.md](../../../spec/task-0019-acceptance-criteria.md)

---

## 開発言語・フレームワーク

### プログラミング言語: TypeScript 5.9+ 🔵

**言語選択の理由**:
- プロジェクト全体で採用されているTypeScript strict modeに統一
- コンパイル時の型チェックによりバグの早期発見が可能
- Rechartsライブラリの型定義が充実しており、型安全な開発が可能
- 既存のStatisticsDashboardPageがTypeScriptで実装されており、一貫性を維持

**テストに適した機能**:
- 型推論により、テストデータの不正な型を事前に検出
- Interface定義により、モックデータの構造を明確化
- Union型で複数のエッジケースを型安全に表現

### テストフレームワーク: Vitest + React Testing Library 🔵

**フレームワーク選択の理由**:
- 既存プロジェクトでVitestが採用されており、統一性を維持
- Viteとのネイティブ統合により、高速なテスト実行（HMR対応）
- React Testing Libraryでユーザー視点のテストが可能
- 既存のStatisticsDashboardPage.test.tsxと同じパターンで記述可能

**テスト実行環境**:
- **開発環境**: `pnpm test`（Watch mode）
- **CI/CD環境**: `pnpm test:coverage`（カバレッジ測定）
- **UIモード**: `pnpm test:ui`（テストケースの可視化）
- **ランタイム**: happy-dom（軽量DOM環境）

---

## 信頼性レベル凡例

各テストケースには、元の資料（要件定義、既存実装、ライブラリドキュメント等）との照合状況を示す信号を記載します：

- 🔵 **青信号**: 元の資料を参考にしてほぼ推測していない場合（要件定義書・受け入れ基準・既存実装に明記）
- 🟡 **黄信号**: 元の資料から妥当な推測の場合（一般的なUX要件・類似機能からの類推）
- 🔴 **赤信号**: 元の資料にない推測の場合（実装時に要確認）

---

## テストケース分類

### 1. 正常系テストケース（基本的な動作）

#### TC-GRAPH-001: 複数の相手デッキが存在する場合、円グラフが正しく表示される 🔵

**テスト名**: 複数デッキデータの円グラフ基本表示
**何をテストするか**: OpponentDeckPieChartコンポーネントに複数のデッキ統計データを渡した際、各デッキが個別のセグメントとして正しく描画される
**期待される動作**: Rechartsの<PieChart>コンポーネントが正常にレンダリングされ、各デッキがセグメントとして視覚的に区別可能な状態で表示される

**入力値**:
```typescript
const opponentDeckStats = [
  { deckId: 'deck_001', deckName: '進化ロイヤル', totalGames: 20, wins: 12, losses: 8, winRate: 60.0 },
  { deckId: 'deck_002', deckName: '守護ビショップ', totalGames: 15, wins: 9, losses: 6, winRate: 60.0 },
  { deckId: 'deck_003', deckName: 'OTKドラゴン', totalGames: 10, wins: 3, losses: 7, winRate: 30.0 },
  { deckId: 'deck_004', deckName: '秘術ウィッチ', totalGames: 5, wins: 2, losses: 3, winRate: 40.0 }
];
```

**入力データの意味**:
- 4種類の相手デッキとの対戦履歴（合計50試合）
- 各デッキの対戦回数が異なる（20, 15, 10, 5回）ため、セグメントサイズが視覚的に区別可能
- REQ-GRAPH-001の基本要件を満たすための代表的なデータセット

**期待される結果**:
- 円グラフコンポーネントが画面に描画される
- 4つのセグメントが表示される
- 各セグメントのサイズが対戦回数の割合に応じている:
  - 進化ロイヤル: 40% (20/50)
  - 守護ビショップ: 30% (15/50)
  - OTKドラゴン: 20% (10/50)
  - 秘術ウィッチ: 10% (5/50)
- 凡例に「進化ロイヤル: 20回」「守護ビショップ: 15回」等が表示される

**期待結果の理由**: REQ-GRAPH-001〜005に基づき、円グラフの基本表示機能が正しく動作することを確認する必要があるため

**テストの目的**: 最も基本的な正常系動作の確認
**確認ポイント**:
- `screen.getByRole('img', { name: /対戦相手デッキ分布/i })`で円グラフが描画される
- セグメント数が正しい（`document.querySelectorAll('.recharts-pie-sector').length === 4`）
- 凡例テキストが正しい

🔵 **信頼性レベル**: REQ-GRAPH-001〜005、受け入れ基準TC-GRAPH-001に基づく

---

#### TC-GRAPH-002: 各セグメントが異なる色で表示される 🔵

**テスト名**: デッキタイプごとの固定カラーパレット適用確認
**何をテストするか**: 各デッキセグメントに固定のカラーパレットが正しく適用されているか
**期待される動作**: `frontend/src/constants/deckColors.ts`で定義されたカラーパレットに基づき、各デッキが一貫した色で表示される

**入力値**: TC-GRAPH-001と同じデータ

**入力データの意味**: デッキタイプごとに異なる色が割り当てられることを確認するため、複数のデッキデータを使用

**期待される結果**:
- 各セグメントの`fill`属性が異なる色コードである
- 同じデッキは常に同じ色で表示される（例: 進化ロイヤル = `#3b82f6`）
- 色覚多様性に配慮したカラーパレット（例: ColorBrewer2のSet2パレット）が使用されている

**期待結果の理由**: REQ-GRAPH-005およびNFR-GRAPH-302（色覚多様性対応）を満たす必要があるため

**テストの目的**: カラーパレットの一貫性と視認性の確保
**確認ポイント**:
- `document.querySelectorAll('.recharts-pie-sector')`の各要素の`fill`属性が異なる
- 定義済みカラーパレットの色が適用されている

🔵 **信頼性レベル**: REQ-GRAPH-005、NFR-GRAPH-302に基づく

---

#### TC-GRAPH-003: 凡例にデッキ名と対戦回数が表示される 🔵

**テスト名**: 凡例の情報表示確認
**何をテストするか**: 円グラフの凡例に各デッキの名前と対戦回数が正しいフォーマットで表示される
**期待される動作**: Rechartsの<Legend>コンポーネントを使用し、「デッキ名: X回」形式で凡例が表示される

**入力値**: TC-GRAPH-001と同じデータ

**入力データの意味**: 凡例表示の正確性を検証するため、複数のデッキデータを使用

**期待される結果**:
- 凡例に「進化ロイヤル: 20回」と表示される
- 凡例に「守護ビショップ: 15回」と表示される
- 凡例に「OTKドラゴン: 10回」と表示される
- 凡例に「秘術ウィッチ: 5回」と表示される
- 凡例のフォントサイズが12px以上（NFR-GRAPH-102）

**期待結果の理由**: REQ-GRAPH-004の要件および受け入れ基準TC-GRAPH-004を満たす必要があるため

**テストの目的**: 凡例の情報が正しく、読みやすい形式で表示されることを確認
**確認ポイント**:
- `screen.getByText('進化ロイヤル: 20回')`が存在する
- `screen.getByText('守護ビショップ: 15回')`が存在する
- 凡例のCSS `font-size`が12px以上

🔵 **信頼性レベル**: REQ-GRAPH-004、NFR-GRAPH-102に基づく

---

#### TC-GRAPH-004: セグメントホバー時にツールチップが表示される 🔵

**テスト名**: ツールチップのインタラクション確認
**何をテストするか**: 円グラフのセグメントにマウスホバーした際、ツールチップが表示され、正しい情報（デッキ名、対戦回数、割合%）が含まれる
**期待される動作**: Rechartsの<Tooltip>コンポーネントが動作し、ホバー時に詳細情報が表示される

**入力値**: TC-GRAPH-001と同じデータ

**入力データの意味**: ツールチップ表示の正確性を検証するため、割合が異なる複数のデッキデータを使用

**期待される結果**:
- セグメントにマウスホバーすると、ツールチップが表示される
- ツールチップに「進化ロイヤル: 20回 (40.0%)」と表示される（進化ロイヤルのセグメントの場合）
- マウスを外すとツールチップが非表示になる
- ツールチップのフォントが読みやすいサイズ（12px以上）

**期待結果の理由**: REQ-GRAPH-009, REQ-GRAPH-010の要件および受け入れ基準TC-GRAPH-012〜014を満たす必要があるため

**テストの目的**: インタラクティブなツールチップ機能の動作確認
**確認ポイント**:
- `userEvent.hover()`でセグメントにホバー
- `screen.getByText(/進化ロイヤル: 20回 \(40\.0%\)/)`が表示される
- `userEvent.unhover()`後にツールチップが消える

🔵 **信頼性レベル**: REQ-GRAPH-009, REQ-GRAPH-010、受け入れ基準TC-GRAPH-012に基づく

---

#### TC-GRAPH-005: PC表示で2カラムレイアウトが表示される 🔵

**テスト名**: レスポンシブレイアウト（PC版）の表示確認
**何をテストするか**: 画面幅768px以上のPC表示時に、デッキ別統計テーブルと円グラフが2カラムレイアウトで並んで表示される
**期待される動作**: Tailwind CSSの`grid grid-cols-1 lg:grid-cols-2`クラスにより、PC表示時は2カラム、モバイル表示時は1カラムになる

**入力値**: TC-GRAPH-001と同じデータ + 画面幅1024px（デスクトップサイズ）

**入力データの意味**: PC表示のレイアウトを検証するため、標準的なデスクトップ画面幅を設定

**期待される結果**:
- デッキ別統計テーブル（DeckStatsTable）が表示される
- 円グラフ（OpponentDeckPieChart）が表示される
- 両方のコンポーネントが横並びに配置される（`display: grid`, `grid-template-columns: repeat(2, minmax(0, 1fr))`）
- 両方のコンポーネントが同じ親要素`<div>`内に配置されている

**期待結果の理由**: REQ-GRAPH-006, REQ-GRAPH-007の要件および受け入れ基準TC-GRAPH-007を満たす必要があるため

**テストの目的**: PCレイアウトの正しい表示とグリッドレイアウトの動作確認
**確認ポイント**:
- `window.innerWidth = 1024`でレンダリング
- デッキ別統計テーブルと円グラフが同時に表示される
- 親要素のCSSクラスに`lg:grid-cols-2`が含まれる

🔵 **信頼性レベル**: REQ-GRAPH-006, REQ-GRAPH-007、受け入れ基準TC-GRAPH-007に基づく

---

#### TC-GRAPH-006: モバイル表示で円グラフのみが表示される 🔵

**テスト名**: レスポンシブレイアウト（モバイル版）の表示確認
**何をテストするか**: 画面幅768px未満のモバイル表示時に、円グラフのみが1カラムレイアウトで表示され、デッキ別統計テーブルが非表示になる
**期待される動作**: Tailwind CSSの`hidden lg:block`クラスにより、モバイル表示時はテーブルが非表示、円グラフのみ表示

**入力値**: TC-GRAPH-001と同じデータ + 画面幅375px（モバイルサイズ）

**入力データの意味**: モバイル表示のレイアウトを検証するため、標準的なスマートフォン画面幅を設定

**期待される結果**:
- 円グラフ（OpponentDeckPieChart）が表示される
- デッキ別統計テーブル（DeckStatsTable）が非表示（`display: none`）
- 円グラフが画面幅いっぱいに表示される（1カラムレイアウト）
- PC版と同じアスペクト比が維持される（正円形）

**期待結果の理由**: REQ-GRAPH-008, REQ-GRAPH-012の要件および受け入れ基準TC-GRAPH-008を満たす必要があるため

**テストの目的**: モバイルレイアウトの正しい表示とレスポンシブデザインの動作確認
**確認ポイント**:
- `window.innerWidth = 375`でレンダリング
- 円グラフが表示される
- デッキ別統計テーブルが非表示（`expect(screen.queryByRole('table')).not.toBeInTheDocument()`）
- 円グラフの`aspect`属性が1（正円形）

🔵 **信頼性レベル**: REQ-GRAPH-008, REQ-GRAPH-012、受け入れ基準TC-GRAPH-008に基づく

---

#### TC-GRAPH-007: 円グラフがアニメーションなしで即座に表示される 🔵

**テスト名**: アニメーション無効化の確認
**何をテストするか**: 円グラフが描画される際、アニメーション効果なしで即座に表示される
**期待される動作**: Rechartsの`isAnimationActive={false}`プロパティにより、アニメーションが無効化されている

**入力値**: TC-GRAPH-001と同じデータ

**入力データの意味**: アニメーション無効化の動作を検証するため、標準的なデータセットを使用

**期待される結果**:
- ページ読み込み後、すぐに円グラフが完全な状態で表示される（アニメーション待機なし）
- 描画時間が500ms以内（NFR-GRAPH-001）
- `<Pie>`コンポーネントの`isAnimationActive`プロパティが`false`

**期待結果の理由**: REQ-GRAPH-011およびNFR-GRAPH-001の要件を満たす必要があるため

**テストの目的**: パフォーマンス要件とユーザー体験の確認
**確認ポイント**:
- レンダリング直後に円グラフが完全に表示される
- React DevTools Profilerで描画時間が500ms以内
- `isAnimationActive={false}`が設定されている

🔵 **信頼性レベル**: REQ-GRAPH-011、NFR-GRAPH-001に基づく

---

#### TC-GRAPH-008: 期間変更時に円グラフが再描画される 🔵

**テスト名**: 期間選択変更時のリアルタイム更新確認
**何をテストするか**: PeriodSelectorで期間を変更した際、円グラフが新しいデータで即座に再描画される
**期待される動作**: StatisticsDashboardPageのuseEffectにより、期間変更時にAPI再取得→円グラフ再描画が実行される

**入力値**:
- 初期データ: TC-GRAPH-001と同じデータ（過去7日間）
- 変更後データ: 異なるデッキ分布データ（過去30日間）
```typescript
const newOpponentDeckStats = [
  { deckId: 'deck_005', deckName: 'ケルベロス葬送ネクロ', totalGames: 40, wins: 25, losses: 15, winRate: 62.5 },
  { deckId: 'deck_006', deckName: 'アグロエルフ', totalGames: 30, wins: 18, losses: 12, winRate: 60.0 },
];
```

**入力データの意味**: 期間変更前後でデッキ分布が異なることを確認するため、別のデータセットを用意

**期待される結果**:
- 期間選択を「過去7日間」→「過去30日間」に変更する
- 円グラフが即座に再描画される
- 新しいデータ（ケルベロス葬送ネクロ、アグロエルフ）のセグメントが表示される
- 古いデータ（進化ロイヤル等）のセグメントが表示されない
- ページ全体のリロードが発生しない（SPA動作）

**期待結果の理由**: REQ-GRAPH-103の要件および受け入れ基準TC-GRAPH-025を満たす必要があるため

**テストの目的**: 期間選択変更時の動的な更新機能の確認
**確認ポイント**:
- `fireEvent.change()`で期間選択を変更
- `waitFor()`で新しいデータの円グラフが表示されることを確認
- `screen.queryByText('進化ロイヤル')`が存在しない
- `screen.getByText('ケルベロス葬送ネクロ')`が存在する

🔵 **信頼性レベル**: REQ-GRAPH-103、受け入れ基準TC-GRAPH-025に基づく

---

### 2. 異常系テストケース（エラーハンドリング）

#### TC-GRAPH-009: データが0件の場合、「データなし」メッセージが表示される 🟡

**テスト名**: 空データ時のフォールバック表示確認
**何をテストするか**: `opponentDeckStats`が空配列の場合、円グラフの代わりに「この期間にはデータがありません」メッセージが表示される
**エラーケースの概要**: ユーザーが対戦していない期間を選択した場合、または新規ユーザーがデータを持っていない場合
**エラー処理の重要性**: 空のグラフを表示するよりも、ユーザーに状況を明確に伝えることでUXを向上

**入力値**:
```typescript
const opponentDeckStats: OpponentDeckStat[] = [];
```

**不正な理由**: データが0件の状態は正常なシステム動作であるが、ユーザーにとっては「何も表示されない」状態を避ける必要がある
**実際の発生シナリオ**: 新規ユーザーが初めてダッシュボードを開いた場合、または対戦していない期間を選択した場合

**期待される結果**:
- 円グラフが表示されない
- 「この期間にはデータがありません」メッセージが円グラフの位置に中央揃えで表示される
- エラーや空のグラフが表示されない

**エラーメッセージの内容**: 「この期間にはデータがありません」（ユーザーフレンドリーで状況が明確）
**システムの安全性**: エラー時でもアプリケーションがクラッシュせず、他のコンポーネント（テーブル等）は正常に動作

**テストの目的**: 空データ時のエラーハンドリングの確認
**品質保証の観点**: ユーザーが混乱せず、適切なフィードバックを受け取れることを保証

**確認ポイント**:
- `screen.getByText('この期間にはデータがありません')`が表示される
- 円グラフ要素（`.recharts-pie`）が存在しない
- 他のコンポーネントが正常に表示される

🟡 **信頼性レベル**: REQ-GRAPH-101、受け入れ基準TC-GRAPH-021から妥当な推測

---

#### TC-GRAPH-010: Recharts描画エラー時にエラーメッセージが表示される 🟡

**テスト名**: グラフ描画エラー時のエラーバウンダリ確認
**何をテストするか**: Rechartsライブラリが内部エラーを起こした場合、エラーバウンダリがキャッチし、適切なエラーメッセージを表示する
**エラーケースの概要**: Rechartsのバグ、ブラウザ互換性問題、またはメモリ不足によるレンダリング失敗
**エラー処理の重要性**: アプリケーション全体のクラッシュを防ぎ、ユーザーに状況を伝える

**入力値**: モックで`<PieChart>`がエラーをスローする状況を作成
```typescript
vi.spyOn(console, 'error').mockImplementation(() => {}); // エラーログを抑制
```

**不正な理由**: Rechartsが予期しないエラーをスローする状況
**実際の発生シナリオ**: 古いブラウザでの描画エラー、メモリ不足、Rechartsのバグ

**期待される結果**:
- エラーメッセージ「グラフの表示に失敗しました」が表示される
- アプリケーション全体がクラッシュしない
- 他のコンポーネント（デッキ別統計テーブル等）は正常に表示される

**エラーメッセージの内容**: 「グラフの表示に失敗しました。ページを再読み込みしてください。」（ユーザーに対処方法を示唆）
**システムの安全性**: エラー時でも他の機能が使用可能な状態を維持

**テストの目的**: エラーバウンダリの動作確認
**品質保証の観点**: エラー時でもシステムが安全に動作し、ユーザーに適切なフィードバックを提供

**確認ポイント**:
- エラーをスローするモックコンポーネントを使用
- `screen.getByText('グラフの表示に失敗しました')`が表示される
- アプリケーションがクラッシュしない

🟡 **信頼性レベル**: EDGE-GRAPH-001、受け入れ基準TC-GRAPH-030から妥当な推測

---

#### TC-GRAPH-011: 不正なデータ形式の場合にエラーハンドリングされる 🟡

**テスト名**: 不正データ形式時のバリデーション確認
**何をテストするか**: `opponentDeckStats`に不正な形式のデータ（null, undefined, 型不一致）が含まれる場合、エラーハンドリングされる
**エラーケースの概要**: APIレスポンスが不正な形式でデータを返した場合
**エラー処理の重要性**: 不正なデータによる予期しないクラッシュを防ぐ

**入力値**:
```typescript
const invalidData: any = [
  { deckId: null, deckName: undefined, totalGames: 'invalid', wins: 10, losses: 5, winRate: 66.7 },
  null,
  undefined
];
```

**不正な理由**:
- `deckId`がnull（string型が期待される）
- `deckName`がundefined（string型が期待される）
- `totalGames`が文字列（number型が期待される）
- 配列要素がnull/undefined

**実際の発生シナリオ**: APIのバグ、ネットワークエラーによるデータ破損、型安全性が不十分なAPI実装

**期待される結果**:
- 不正なデータがフィルタリングされる（または「データ形式が不正です」エラーメッセージ表示）
- アプリケーションがクラッシュしない
- 正常なデータのみが円グラフに表示される

**エラーメッセージの内容**: 「データ形式が不正です。システム管理者にお問い合わせください。」
**システムの安全性**: 不正なデータが混入してもシステムが安全に動作

**テストの目的**: データバリデーションの確認
**品質保証の観点**: 不正なデータによるクラッシュを防ぎ、システムの堅牢性を保証

**確認ポイント**:
- 不正なデータを渡す
- エラーメッセージまたは空のグラフが表示される
- アプリケーションがクラッシュしない

🟡 **信頼性レベル**: EDGE-GRAPH-002、受け入れ基準TC-GRAPH-031から妥当な推測

---

### 3. 境界値テストケース（最小値、最大値、null等）

#### TC-GRAPH-012: 対戦相手が1種類のみの場合、100%の単一セグメントが表示される 🟡

**テスト名**: 最小データセット（1デッキのみ）の円グラフ表示確認
**何をテストするか**: `opponentDeckStats`が1つのデッキのみの場合、100%の単一セグメント円グラフが正しく表示される
**境界値の意味**: データセットの最小単位（1件）での動作を確認
**境界値での動作保証**: 1件のデータでもグラフが正常に描画され、エラーが発生しない

**入力値**:
```typescript
const opponentDeckStats = [
  { deckId: 'deck_001', deckName: '進化ロイヤル', totalGames: 10, wins: 6, losses: 4, winRate: 60.0 }
];
```

**境界値選択の根拠**: 最小のデータセット（1件）で円グラフが正常に動作することを確認するため
**実際の使用場面**: フレンド戦で同じ相手と複数回対戦した場合、または新しいデッキのテストで特定のデッキとのみ対戦している場合

**期待される結果**:
- 100%の単一色セグメント円グラフが表示される
- セグメントにホバーすると「進化ロイヤル: 10回 (100.0%)」と表示される
- エラーやメッセージではなく、正常なグラフとして表示される
- 凡例に「進化ロイヤル: 10回」と表示される

**境界での正確性**: 割合が正確に100.0%と表示される
**一貫した動作**: 複数データの場合と同じUI/UXが維持される

**テストの目的**: 最小データセットでの動作確認
**堅牢性の確認**: 極端に少ないデータでもシステムが安定動作する

**確認ポイント**:
- 円グラフが表示される
- セグメント数が1（`document.querySelectorAll('.recharts-pie-sector').length === 1`）
- ツールチップに「100.0%」と表示される

🟡 **信頼性レベル**: REQ-GRAPH-102、受け入れ基準TC-GRAPH-023から妥当な推測

---

#### TC-GRAPH-013: 対戦相手デッキが20種類以上の場合でも円グラフが正しく表示される 🟡

**テスト名**: 大量データセット（20デッキ以上）の円グラフ表示確認
**何をテストするか**: `opponentDeckStats`が20種類以上の場合でも円グラフが正常に描画され、凡例が見やすく表示される
**境界値の意味**: 大量のデータでもパフォーマンスとUI/UXが維持されることを確認
**境界値での動作保証**: セグメントが多くても視覚的に区別可能で、凡例が適切に表示される

**入力値**:
```typescript
const opponentDeckStats = Array.from({ length: 25 }, (_, i) => ({
  deckId: `deck_${i + 1}`,
  deckName: `デッキ${i + 1}`,
  totalGames: Math.floor(Math.random() * 20) + 1,
  wins: Math.floor(Math.random() * 10),
  losses: Math.floor(Math.random() * 10),
  winRate: Math.random() * 100
}));
```

**境界値選択の根拠**: 通常のプレイでは10種類程度のデッキと対戦することが多いが、長期間のデータでは20種類以上になる可能性がある
**実際の使用場面**: 長期間（3ヶ月以上）のデータを表示する場合、または非常に多様な環境（メタゲームが分散）

**期待される結果**:
- 円グラフに25個のセグメントが表示される
- 各セグメントが視覚的に区別できる（小さいセグメントも表示される）
- 凡例がスクロール可能または複数列で表示される
- パフォーマンスが劣化しない（描画時間が1秒以内）

**境界での正確性**: 大量のデータでも割合の合計が100%になる
**一貫した動作**: 少数データの場合と同じUI/UXが維持される

**テストの目的**: 大量データでのスケーラビリティ確認
**堅牢性の確認**: 極端に多いデータでもシステムが安定動作し、ユーザビリティが損なわれない

**確認ポイント**:
- セグメント数が25（`document.querySelectorAll('.recharts-pie-sector').length === 25`）
- 凡例が見やすく表示される（スクロール可能または複数列）
- パフォーマンステストでレンダリング時間が1秒以内

🟡 **信頼性レベル**: EDGE-GRAPH-101、受け入れ基準TC-GRAPH-033から妥当な推測

---

#### TC-GRAPH-014: 対戦回数が1回のデッキもセグメントとして表示される 🟡

**テスト名**: 最小対戦回数（1回）のセグメント表示確認
**何をテストするか**: 対戦回数が1回のデッキも円グラフのセグメントとして正しく表示される
**境界値の意味**: 対戦回数の最小値（1回）でも正常に表示されることを確認
**境界値での動作保証**: 小さすぎて見えないことがなく、ツールチップで情報が確認できる

**入力値**:
```typescript
const opponentDeckStats = [
  { deckId: 'deck_001', deckName: '進化ロイヤル', totalGames: 50, wins: 30, losses: 20, winRate: 60.0 },
  { deckId: 'deck_002', deckName: '守護ビショップ', totalGames: 1, wins: 0, losses: 1, winRate: 0.0 }
];
```

**境界値選択の根拠**: 対戦回数の最小値（1回）で正常に動作することを確認
**実際の使用場面**: 新しいデッキが環境に登場し、1回だけ対戦した場合

**期待される結果**:
- 対戦回数1回のデッキ（守護ビショップ）もセグメントとして表示される
- ツールチップに「守護ビショップ: 1回 (1.96%)」と表示される（1/51 = 1.96%）
- セグメントが小さすぎて見えないことがない（最小サイズが確保されている）

**境界での正確性**: 割合が正確に計算される（小数点第1位まで表示）
**一貫した動作**: 大きなセグメントと同じUI/UXが維持される

**テストの目的**: 最小対戦回数でのセグメント表示確認
**堅牢性の確認**: 極端に少ない対戦回数でもセグメントが視認可能

**確認ポイント**:
- セグメント数が2（`document.querySelectorAll('.recharts-pie-sector').length === 2`）
- ツールチップに「守護ビショップ: 1回 (1.96%)」と表示される
- 小さなセグメントも視認可能

🟡 **信頼性レベル**: EDGE-GRAPH-102、受け入れ基準TC-GRAPH-035から妥当な推測

---

#### TC-GRAPH-015: 同率のデッキが複数存在する場合、辞書順でソートされる 🟡

**テスト名**: 同一対戦回数のソート順確認
**何をテストするか**: 対戦回数が同じデッキが複数存在する場合、デッキ名の辞書順（五十音順）でソートされる
**境界値の意味**: ソートロジックが正しく動作することを確認
**境界値での動作保証**: 同率の場合でも一貫した順序で表示される

**入力値**:
```typescript
const opponentDeckStats = [
  { deckId: 'deck_003', deckName: 'デッキC', totalGames: 10, wins: 5, losses: 5, winRate: 50.0 },
  { deckId: 'deck_001', deckName: 'デッキA', totalGames: 10, wins: 6, losses: 4, winRate: 60.0 },
  { deckId: 'deck_002', deckName: 'デッキB', totalGames: 10, wins: 4, losses: 6, winRate: 40.0 }
];
```

**境界値選択の根拠**: 同一対戦回数の場合のソートロジックを検証
**実際の使用場面**: 複数のデッキと均等に対戦している場合

**期待される結果**:
- 凡例に「デッキA: 10回」「デッキB: 10回」「デッキC: 10回」の順で表示される
- セグメントの順序が辞書順（A → B → C）になる
- 次回レンダリング時も同じ順序が維持される（一貫性）

**境界での正確性**: ソート順が正確に辞書順になる
**一貫した動作**: 同じデータでは常に同じ順序で表示される

**テストの目的**: ソートロジックの正確性確認
**堅牢性の確認**: 同率データでも一貫した順序で表示される

**確認ポイント**:
- 凡例の順序が「デッキA」「デッキB」「デッキC」
- セグメントの順序が辞書順

🟡 **信頼性レベル**: EDGE-GRAPH-103、受け入れ基準TC-GRAPH-037から妥当な推測

---

#### TC-GRAPH-016: 存在しないデッキIDが含まれる場合、「不明なデッキ」として表示される 🟡

**テスト名**: データ整合性エラー時のフォールバック表示確認
**何をテストするか**: `opponentDeckStats`に存在しないデッキID（マスターデータに登録されていない）が含まれる場合、「不明なデッキ」として表示される
**境界値の意味**: データ整合性エラーが発生してもシステムが正常に動作することを確認
**境界値での動作保証**: エラーが発生せず、フォールバック処理が正しく動作する

**入力値**:
```typescript
const opponentDeckStats = [
  { deckId: 'deck_001', deckName: '進化ロイヤル', totalGames: 20, wins: 12, losses: 8, winRate: 60.0 },
  { deckId: 'deck_999', deckName: null, totalGames: 10, wins: 5, losses: 5, winRate: 50.0 } // 存在しないデッキID
];
```

**境界値選択の根拠**: データ整合性エラーが発生した場合の動作を検証
**実際の使用場面**: デッキマスターデータが更新され、過去のデータと不整合が発生した場合

**期待される結果**:
- 「不明なデッキ: 10回」として表示される
- 円グラフのセグメントが正常に表示される
- エラーが発生しない

**境界での正確性**: 「不明なデッキ」のラベルが正確に表示される
**一貫した動作**: 正常なデータと同じUI/UXが維持される

**テストの目的**: データ整合性エラー時のフォールバック処理確認
**堅牢性の確認**: データ不整合が発生してもシステムが安定動作

**確認ポイント**:
- `screen.getByText('不明なデッキ: 10回')`が表示される
- 円グラフが正常に表示される
- エラーが発生しない

🟡 **信頼性レベル**: EDGE-GRAPH-201、受け入れ基準TC-GRAPH-039から妥当な推測

---

## テストケース実装時の日本語コメント例

以下は、各テストケースを実装する際に含めるべき日本語コメントの例です：

### TC-GRAPH-001の実装例

```typescript
import { render, screen } from '@testing-library/react';
import { describe, expect, it } from 'vitest';
import { OpponentDeckPieChart } from './OpponentDeckPieChart';

describe('OpponentDeckPieChart', () => {
  describe('正常系テスト', () => {
    it('TC-GRAPH-001: 複数の相手デッキが存在する場合、円グラフが正しく表示される', () => {
      // 【テスト目的】: OpponentDeckPieChartコンポーネントの基本的な円グラフ描画機能を確認
      // 【テスト内容】: 複数のデッキ統計データを渡し、各デッキがセグメントとして正しく表示されることをテスト
      // 【期待される動作】: 4つのデッキがそれぞれ異なる色のセグメントとして描画され、凡例に情報が表示される
      // 🔵 信頼性レベル: REQ-GRAPH-001〜005に基づく

      // ========== Given: テストデータ準備 ==========
      // 【テストデータ準備】: 4種類のデッキとの対戦履歴データを用意（合計50試合）
      // 【初期条件設定】: 各デッキの対戦回数が異なり、セグメントサイズが視覚的に区別可能
      // 【前提条件確認】: REQ-GRAPH-001〜005の基本要件を満たすための代表的なデータセット
      const opponentDeckStats = [
        { deckId: 'deck_001', deckName: '進化ロイヤル', totalGames: 20, wins: 12, losses: 8, winRate: 60.0 },
        { deckId: 'deck_002', deckName: '守護ビショップ', totalGames: 15, wins: 9, losses: 6, winRate: 60.0 },
        { deckId: 'deck_003', deckName: 'OTKドラゴン', totalGames: 10, wins: 3, losses: 7, winRate: 30.0 },
        { deckId: 'deck_004', deckName: '秘術ウィッチ', totalGames: 5, wins: 2, losses: 3, winRate: 40.0 }
      ];

      // ========== When: 実際の処理実行 ==========
      // 【実際の処理実行】: OpponentDeckPieChartコンポーネントをレンダリング
      // 【処理内容】: Rechartsの<PieChart>コンポーネントが内部で描画される
      // 【実行タイミング】: テスト開始時に一度だけ実行
      render(<OpponentDeckPieChart data={opponentDeckStats} />);

      // ========== Then: 結果検証 ==========
      // 【結果検証】: 円グラフが正しく描画され、各セグメントと凡例が表示されることを確認
      // 【期待値確認】: 4つのセグメントが表示され、凡例に正しい情報が含まれる
      // 【品質保証】: 基本的なグラフ描画機能が正常に動作することを保証

      // 【検証項目】: 円グラフ全体が描画されている
      // 🔵 信頼性レベル: REQ-GRAPH-001に基づく
      const pieChart = screen.getByRole('img', { name: /対戦相手デッキ分布/i });
      expect(pieChart).toBeInTheDocument(); // 【確認内容】: 円グラフ要素が存在することを確認

      // 【検証項目】: セグメント数が正しい（4つ）
      // 🔵 信頼性レベル: REQ-GRAPH-002に基づく
      const segments = document.querySelectorAll('.recharts-pie-sector');
      expect(segments).toHaveLength(4); // 【確認内容】: 4つのデッキに対応する4つのセグメントが描画されることを確認

      // 【検証項目】: 凡例に各デッキ名と対戦回数が表示されている
      // 🔵 信頼性レベル: REQ-GRAPH-004に基づく
      expect(screen.getByText('進化ロイヤル: 20回')).toBeInTheDocument(); // 【確認内容】: 凡例に「進化ロイヤル: 20回」が表示されることを確認
      expect(screen.getByText('守護ビショップ: 15回')).toBeInTheDocument(); // 【確認内容】: 凡例に「守護ビショップ: 15回」が表示されることを確認
      expect(screen.getByText('OTKドラゴン: 10回')).toBeInTheDocument(); // 【確認内容】: 凡例に「OTKドラゴン: 10回」が表示されることを確認
      expect(screen.getByText('秘術ウィッチ: 5回')).toBeInTheDocument(); // 【確認内容】: 凡例に「秘術ウィッチ: 5回」が表示されることを確認
    });
  });
});
```

---

## テストケースサマリー

### 正常系テストケース: 8ケース

| テストケースID | テスト名 | 信頼性 |
|-------------|---------|-------|
| TC-GRAPH-001 | 複数デッキデータの円グラフ基本表示 | 🔵 |
| TC-GRAPH-002 | デッキタイプごとの固定カラーパレット適用確認 | 🔵 |
| TC-GRAPH-003 | 凡例の情報表示確認 | 🔵 |
| TC-GRAPH-004 | ツールチップのインタラクション確認 | 🔵 |
| TC-GRAPH-005 | レスポンシブレイアウト（PC版）の表示確認 | 🔵 |
| TC-GRAPH-006 | レスポンシブレイアウト（モバイル版）の表示確認 | 🔵 |
| TC-GRAPH-007 | アニメーション無効化の確認 | 🔵 |
| TC-GRAPH-008 | 期間選択変更時のリアルタイム更新確認 | 🔵 |

### 異常系テストケース: 3ケース

| テストケースID | テスト名 | 信頼性 |
|-------------|---------|-------|
| TC-GRAPH-009 | 空データ時のフォールバック表示確認 | 🟡 |
| TC-GRAPH-010 | グラフ描画エラー時のエラーバウンダリ確認 | 🟡 |
| TC-GRAPH-011 | 不正データ形式時のバリデーション確認 | 🟡 |

### 境界値テストケース: 5ケース

| テストケースID | テスト名 | 信頼性 |
|-------------|---------|-------|
| TC-GRAPH-012 | 最小データセット（1デッキのみ）の円グラフ表示確認 | 🟡 |
| TC-GRAPH-013 | 大量データセット（20デッキ以上）の円グラフ表示確認 | 🟡 |
| TC-GRAPH-014 | 最小対戦回数（1回）のセグメント表示確認 | 🟡 |
| TC-GRAPH-015 | 同一対戦回数のソート順確認 | 🟡 |
| TC-GRAPH-016 | データ整合性エラー時のフォールバック表示確認 | 🟡 |

**総テストケース数**: 16ケース
**信頼性レベル内訳**:
- 🔵 青信号（高信頼性）: 8ケース（50%）
- 🟡 黄信号（妥当な推測）: 8ケース（50%）
- 🔴 赤信号（要確認）: 0ケース（0%）

---

## 品質判定

### テストケースの品質評価

✅ **高品質**:

- ✅ **テストケース分類**: 正常系（8ケース）・異常系（3ケース）・境界値（5ケース）が網羅されている
- ✅ **期待値定義**: 各テストケースの期待値が明確で、検証ポイントが具体的に記載されている
- ✅ **技術選択**: TypeScript 5.9+ + Vitest + React Testing Libraryが確定しており、既存実装と一貫性がある
- ✅ **実装可能性**: 現在の技術スタック（React 19, Recharts 3.3.0, Vitest 4.0.7）で実現可能

### 要件網羅率

| 要件カテゴリ | 対応テストケース | 網羅率 |
|------------|----------------|-------|
| REQ-GRAPH-001〜005（基本表示） | TC-GRAPH-001, 002, 003 | 100% |
| REQ-GRAPH-006〜008（レイアウト） | TC-GRAPH-005, 006 | 100% |
| REQ-GRAPH-009〜010（ツールチップ） | TC-GRAPH-004 | 100% |
| REQ-GRAPH-011〜012（デザイン） | TC-GRAPH-007 | 100% |
| REQ-GRAPH-101〜103（条件付き要件） | TC-GRAPH-008, 009 | 100% |
| EDGE-GRAPH-001〜002（エラー処理） | TC-GRAPH-010, 011 | 100% |
| EDGE-GRAPH-101〜103（境界値） | TC-GRAPH-012, 013, 014, 015 | 100% |
| EDGE-GRAPH-201（データ整合性） | TC-GRAPH-016 | 100% |

**総合要件網羅率**: 100%

---

## 次のステップ

### 推奨される次のアクション

✅ **テストケース洗い出し完了**

次のお勧めステップ: **`/tsumiki:tdd-red`** でRedフェーズ（失敗テスト作成）を開始します。

### Redフェーズで実装するテストファイル

以下のテストファイルを作成します：

1. **frontend/src/components/statistics/OpponentDeckPieChart.test.tsx**
   - TC-GRAPH-001〜016の全テストケースを実装
   - Given-When-Thenパターンで記述
   - 日本語コメントを充実させる

2. **frontend/src/pages/StatisticsDashboardPage.test.tsx（追加テスト）**
   - TC-GRAPH-005, 006, 008の統合テスト
   - 既存テストファイルに追記

### 実装時の注意事項

- **TDD原則に従う**: まず失敗するテストを書き、その後に実装を行う
- **日本語コメント**: 各テストケースに「テスト目的」「テスト内容」「期待される動作」を日本語で明記
- **信頼性レベル**: 各expectステートメントに🔵🟡🔴の信号を記載
- **モック戦略**: `apiClient.get`をモック化し、期間変更時のAPI再取得を検証

---

## 変更履歴

| 日付 | 変更内容 | 変更者 |
|------|---------|-------|
| 2025-11-09 | 初版作成（TASK-0019テストケース定義） | Claude Code |

---

**このドキュメントは TDD プロセスの「テストケース洗い出し」フェーズの成果物です。**
