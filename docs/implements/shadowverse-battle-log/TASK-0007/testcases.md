# TDDテストケース定義書: Battle Log CRUD API実装 - 作成機能

**機能名**: Battle Log Create API (対戦履歴作成API)
**タスクID**: TASK-0007
**作成日**: 2025-10-29
**更新日**: 2025-10-29

---

## 1. テスト環境

### 開発言語・フレームワーク

- **プログラミング言語**: TypeScript 5.7+
  - **言語選択の理由**: バックエンドの主要言語。型安全性が高く、Azure Functions v4との統合が容易
  - **テストに適した機能**:
    - 型推論によるテストデータの型安全性
    - Zodとの統合による実行時バリデーション
    - モックとスタブの型チェック
- **テストフレームワーク**: Jest 29.7.0 + ts-jest
  - **フレームワーク選択の理由**:
    - TypeScriptとのネイティブ統合
    - Azure Functions SDK との互換性が高い
    - モック機能が充実（jest.mock()）
    - 既存プロジェクトで使用実績あり（TASK-0006）
  - **テスト実行環境**: Node.js 20 LTS (Azure Functions v4 推奨環境)
- 🔵 **信頼性レベル**: 青信号（jest.config.js、既存テストファイル blobStorageClient.test.ts より）

---

## 2. テストケース一覧

### 2.1 正常系テストケース（基本的な動作）

#### TC-001: 基本的な対戦履歴登録

- **テスト名**: 必須項目をすべて指定した対戦履歴が正しく作成される
  - **何をテストするか**: BattleLogService.createBattleLog() メソッドが、有効な8項目のデータを受け取り、正常に対戦履歴を作成できることを確認
  - **期待される動作**:
    - バリデーションが成功する
    - ID が `log_YYYYMMDD_NNN` 形式で自動生成される
    - Blob Storage に正しく保存される
    - 作成された BattleLog オブジェクトが返却される
- **入力値**:
  ```typescript
  {
    date: "2025-01-24",
    battleType: "ランクマッチ",
    rank: "ダイアモンド",
    group: "AAA",
    myDeckId: "deck_001",
    turn: "先攻",
    result: "勝ち",
    opponentDeckId: "deck_master_002"
  }
  ```
  - **入力データの意味**: 典型的なランクマッチの対戦結果を表す。すべての必須項目が有効な値で埋まっている代表的なケース
- **期待される結果**:
  ```typescript
  {
    id: "log_20250124_001",  // 初回登録のため001
    date: "2025/01/24",      // YYYY-MM-DD → YYYY/MM/DD に変換
    battleType: "ランクマッチ",
    rank: "ダイアモンド",
    group: "AAA",
    myDeckId: "deck_001",
    turn: "先攻",
    result: "勝ち",
    opponentDeckId: "deck_master_002"
  }
  ```
  - **期待結果の理由**:
    - ID: 初回登録のため連番001が生成される（REQ-004）
    - date: API入力は `YYYY-MM-DD`、保存時は `YYYY/MM/DD` に変換（REQ-601: 既存データ互換性）
    - その他のフィールド: 入力値がそのまま保存される
- **テストの目的**: 正常系の基本動作確認（REQ-001, REQ-002, REQ-004）
  - **確認ポイント**:
    - バリデーションがパスする
    - ID生成ロジックが正しく動作する
    - 日付形式変換が正しく行われる
    - Blob Storage への保存が成功する
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 349-390、tasks/shadowverse-battle-log-phase2.md Lines 301-322 より）

---

#### TC-002: 日付省略時に今日の日付が自動設定される

- **テスト名**: date フィールドを省略した場合、今日の日付が自動的に設定される
  - **何をテストするか**: date フィールドがオプショナルであり、省略時に Zod のデフォルト値処理で今日の日付（JST基準）が設定されることを確認
  - **期待される動作**:
    - バリデーション時に date が今日の日付に補完される
    - ID生成時に今日の日付が使用される
- **入力値**:
  ```typescript
  {
    // date フィールドなし
    battleType: "対戦台",
    rank: "ルビー",
    group: "A",
    myDeckId: "deck_002",
    turn: "後攻",
    result: "負け",
    opponentDeckId: "deck_master_005"
  }
  ```
  - **入力データの意味**: ユーザーが日付を入力せず、対戦直後に記録するケース（最も一般的な使用パターン）
- **期待される結果**:
  ```typescript
  {
    id: "log_20250129_001",  // テスト実行日が2025-01-29の場合
    date: "2025/01/29",      // 今日の日付が自動設定される
    battleType: "対戦台",
    rank: "ルビー",
    group: "A",
    myDeckId: "deck_002",
    turn: "後攻",
    result: "負け",
    opponentDeckId: "deck_master_005"
  }
  ```
  - **期待結果の理由**:
    - Zodスキーマの `.default(() => new Date().toISOString().split('T')[0])` により、今日の日付が自動設定される
    - ユーザー体験向上: 対戦直後の記録時に日付入力が不要
- **テストの目的**: デフォルト値処理の動作確認（requirements.md Lines 392-432）
  - **確認ポイント**:
    - date フィールドが自動補完される
    - 補完された日付が今日の日付と一致する（タイムゾーン考慮）
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 103-111、tasks/shadowverse-battle-log-phase2.md Lines 324-342 より）

---

#### TC-003: 同日の複数登録で連番が正しく生成される

- **テスト名**: 同じ日付に複数の対戦履歴を登録した場合、連番が正しくインクリメントされる
  - **何をテストするか**: ID生成ロジックが既存のログを読み込み、同日の最大連番を取得して +1 する動作を確認
  - **期待される動作**:
    - 既存ログから同日の履歴をフィルタリング
    - 最大連番を取得（001, 002 → 最大002）
    - 新規IDは003として生成される
- **入力値**:
  - **前提条件**: 既存ログに `log_20250124_001`, `log_20250124_002` が存在
  - **新規登録データ**:
    ```typescript
    {
      date: "2025-01-24",
      battleType: "ランクマッチ",
      rank: "ダイアモンド",
      group: "AAA",
      myDeckId: "deck_001",
      turn: "先攻",
      result: "勝ち",
      opponentDeckId: "deck_master_003"
    }
    ```
  - **入力データの意味**: 同日に3件目の対戦結果を記録するケース（エッジケース1）
- **期待される結果**:
  ```typescript
  {
    id: "log_20250124_003",  // 既存の最大002 + 1 = 003
    // 他のフィールドは省略
  }
  ```
  - **期待結果の理由**: ID生成ロジックの正確性を保証（REQ-004, EDGE-103）
- **テストの目的**: ID自動生成の連番機能確認（requirements.md Lines 436-458）
  - **確認ポイント**:
    - 既存ログが正しく読み込まれる
    - 同日のログが正しくフィルタリングされる
    - 最大連番が正しく取得される（002）
    - 新規IDが003として生成される
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 211-227、tasks/shadowverse-battle-log-phase2.md Lines 388-410 より）

---

#### TC-004: 連番が飛んでいる場合に最大値から+1される

- **テスト名**: 既存ログの連番に欠番がある場合、最大値から+1された連番が生成される
  - **何をテストするか**: ID生成ロジックが連番の欠番を無視し、常に最大値から+1する動作を確認
  - **期待される動作**:
    - 既存ログの連番: 001, 005 (002-004は削除済み)
    - 新規IDは最大値005 + 1 = 006 として生成される
- **入力値**:
  - **前提条件**: 既存ログに `log_20250124_001`, `log_20250124_005` が存在（002-004は削除済み）
  - **新規登録データ**:
    ```typescript
    {
      date: "2025-01-24",
      battleType: "ランクマッチ",
      rank: "ダイアモンド",
      group: "AAA",
      myDeckId: "deck_001",
      turn: "先攻",
      result: "勝ち",
      opponentDeckId: "deck_master_003"
    }
    ```
  - **入力データの意味**: 過去に対戦履歴を削除した後、新規登録するケース（エッジケース2）
- **期待される結果**:
  ```typescript
  {
    id: "log_20250124_006",  // 既存の最大005 + 1 = 006（002-004は無視）
    // 他のフィールドは省略
  }
  ```
  - **期待結果の理由**:
    - 連番の欠番を埋めない（削除した履歴のIDを再利用しない）
    - 単調増加を保証することでID衝突を防ぐ
- **テストの目的**: ID生成ロジックの堅牢性確認（requirements.md Lines 460-466）
  - **確認ポイント**:
    - 欠番が無視される
    - 最大値（005）が正しく取得される
    - 新規IDが006として生成される
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 460-466、tasks/shadowverse-battle-log-phase2.md Lines 412-433 より）

---

#### TC-005: 空のbattle-logs.jsonで初回登録時にID=001が生成される

- **テスト名**: battle-logs.json が空配列の場合、ID = log_YYYYMMDD_001 が生成される
  - **何をテストするか**: システム初回起動時、またはすべての対戦履歴を削除した後の初回登録時の動作を確認
  - **期待される動作**:
    - 既存ログ = [] の場合
    - 同日のログが0件 → 最大連番 = 0
    - 新規IDは001として生成される
- **入力値**:
  - **前提条件**: battle-logs.json が `[]`（空配列）
  - **新規登録データ**:
    ```typescript
    {
      date: "2025-01-24",
      battleType: "ランクマッチ",
      rank: "ダイアモンド",
      group: "AAA",
      myDeckId: "deck_001",
      turn: "先攻",
      result: "勝ち",
      opponentDeckId: "deck_master_002"
    }
    ```
  - **入力データの意味**: システム初回利用時、または全データ削除後の初回登録（エッジケース3）
- **期待される結果**:
  ```typescript
  {
    id: "log_20250124_001",  // 初回登録のため001
    // 他のフィールドは省略
  }
  ```
  - **期待結果の理由**: 空配列から最大連番0を取得し、0 + 1 = 1 → "001" として生成
- **テストの目的**: 初期状態での動作確認（requirements.md Lines 468-474）
  - **確認ポイント**:
    - 空配列が正しく処理される
    - 最大連番が0として扱われる
    - 新規IDが001として生成される
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 468-474 より）

---

#### TC-006: 各enum型のすべての値が正しく保存される

- **テスト名**: battleType, rank, group, turn, result の各enum型で許可されたすべての値が正しく保存される
  - **何をテストするか**: Zodバリデーションが各enumの許可値をすべて受け入れ、正しく保存されることを確認
  - **期待される動作**:
    - すべてのenum値でバリデーションがパスする
    - 各値が正しく Blob Storage に保存される
- **入力値**（複数パターン）:
  - **パターン1**: battleType = "対戦台"
  - **パターン2**: battleType = "ロビー大会"
  - **パターン3**: rank = "サファイア", "トパーズ", "-"
  - **パターン4**: group = "AA", "Master", "-"
  - **パターン5**: turn = "後攻"
  - **パターン6**: result = "負け"
  - **入力データの意味**: enum型の網羅的なバリエーションテスト（境界値ではないが、型の完全性を保証）
- **期待される結果**:
  - すべてのパターンでバリデーションが成功
  - 入力値がそのまま保存される
  - **期待結果の理由**: enum型の完全性とバリデーションの正確性を保証（REQ-002）
- **テストの目的**: enum型バリデーションの網羅性確認（types/index.ts Lines 1-24、requirements.md Lines 113-146）
  - **確認ポイント**:
    - 各enum値がバリデーションを通過する
    - 保存されたデータが入力値と一致する
- 🔵 **信頼性レベル**: 青信号（types/index.ts Lines 85-93、requirements.md Lines 113-146 より）

---

### 2.2 異常系テストケース（エラーハンドリング）

#### TC-101: 未来日付の入力でバリデーションエラー

- **テスト名**: 未来の日付を入力した場合、バリデーションエラーが発生する
  - **エラーケースの概要**: ユーザーが誤って未来の日付を入力したケース
  - **エラー処理の重要性**:
    - データ整合性の保証（過去の対戦履歴のみを記録）
    - ユーザーの入力ミスを早期に検出
    - 統計計算の正確性を保証（REQ-401）
- **入力値**:
  ```typescript
  {
    date: "2099-12-31",  // 未来日付
    battleType: "ランクマッチ",
    rank: "ダイアモンド",
    group: "AAA",
    myDeckId: "deck_001",
    turn: "先攻",
    result: "勝ち",
    opponentDeckId: "deck_master_002"
  }
  ```
  - **不正な理由**: 対戦履歴は過去または今日の記録であるべき（未来の対戦は存在しない）
  - **実際の発生シナリオ**:
    - ユーザーの入力ミス（年の桁を間違える）
    - カレンダーUIの操作ミス
    - タイムゾーンの設定ミス
- **期待される結果**:
  - ZodError がスローされる
  - エラーメッセージ: `"未来の日付は入力できません"`
  - **エラーメッセージの内容**: ユーザーにとって分かりやすい日本語メッセージ（NFR-202）
  - **システムの安全性**: バリデーションで拒否され、Blob Storage への保存は行われない
- **テストの目的**: 未来日付バリデーションの動作確認（REQ-401）
  - **品質保証の観点**: データの時間的整合性を保証し、統計計算の信頼性を維持
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 477-512、tasks/shadowverse-battle-log-phase2.md Lines 346-359 より）

---

#### TC-102: 必須項目が欠落している場合にバリデーションエラー

- **テスト名**: 必須項目（rank, group, myDeckId, turn, result, opponentDeckId）が欠けている場合、バリデーションエラーが発生する
  - **エラーケースの概要**: フロントエンドのバグやネットワークエラーにより、必須項目が欠落したリクエストが送信されるケース
  - **エラー処理の重要性**:
    - データ完全性の保証（8項目すべてが必須: REQ-004）
    - 不完全なデータの保存を防止
    - フロントエンドのバグを早期に検出
- **入力値**:
  ```typescript
  {
    date: "2025-01-24",
    battleType: "ランクマッチ"
    // rank, group, myDeckId, turn, result, opponentDeckId が欠けている
  }
  ```
  - **不正な理由**: 対戦履歴は8項目すべてが必須（REQ-002, REQ-004）
  - **実際の発生シナリオ**:
    - フロントエンドのバグ（フォーム送信前のバリデーション漏れ）
    - ネットワークエラーによるデータ欠落
    - APIの誤用（手動でリクエストを構築した場合）
- **期待される結果**:
  - ZodError がスローされる
  - エラーメッセージ（複数フィールド）:
    - `rank`: "Required"
    - `group`: "Required"
    - `myDeckId`: "マイデッキIDは必須です"
    - `turn`: "Required"
    - `result`: "Required"
    - `opponentDeckId`: "相手デッキIDは必須です"
  - **エラーメッセージの内容**: 各フィールドごとに明確なエラーメッセージを返す（REQ-402）
  - **システムの安全性**: 不完全なデータは保存されない
- **テストの目的**: 必須項目バリデーションの動作確認（REQ-402）
  - **品質保証の観点**: データ完全性を保証し、統計計算や一覧表示で不具合が発生しないようにする
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 514-549、tasks/shadowverse-battle-log-phase2.md Lines 361-369 より）

---

#### TC-103: 不正なenum値でバリデーションエラー

- **テスト名**: battleType に不正な値（許可されていない文字列）を入力した場合、バリデーションエラーが発生する
  - **エラーケースの概要**: enum型に定義されていない値が入力されるケース
  - **エラー処理の重要性**:
    - データ整合性の保証（統計計算でのフィルタリング精度）
    - フロントエンドとバックエンドの型定義の一致を保証
    - 予期しない値による不具合を防止
- **入力値**:
  ```typescript
  {
    date: "2025-01-24",
    battleType: "不正なタイプ",  // 許可されていない値
    rank: "ダイアモンド",
    group: "AAA",
    myDeckId: "deck_001",
    turn: "先攻",
    result: "勝ち",
    opponentDeckId: "deck_master_002"
  }
  ```
  - **不正な理由**: battleType は `"ランクマッチ" | "対戦台" | "ロビー大会"` のみ許可（types/index.ts Line 4）
  - **実際の発生シナリオ**:
    - フロントエンドのバグ（セレクトボックスの値が不正）
    - APIの誤用（手動でリクエストを構築した場合）
    - 型定義の不一致（フロントエンドとバックエンドの型が同期していない）
- **期待される結果**:
  - ZodError がスローされる
  - エラーメッセージ: `"対戦タイプが不正です"`
  - **エラーメッセージの内容**: 日本語で分かりやすいメッセージ（NFR-202）
  - **システムの安全性**: 不正な値は保存されない
- **テストの目的**: enum型バリデーションの厳密性確認（requirements.md Lines 551-586）
  - **品質保証の観点**: 型安全性を保証し、統計計算や一覧表示で正しくデータがグルーピングされることを保証
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 551-586、tasks/shadowverse-battle-log-phase2.md Lines 371-384 より）

---

#### TC-104: 日付形式が不正な場合にバリデーションエラー

- **テスト名**: date フィールドが YYYY-MM-DD 形式ではない場合、バリデーションエラーが発生する
  - **エラーケースの概要**: 日付のフォーマットが不正なケース（スラッシュ区切り、ドット区切り、順序違い等）
  - **エラー処理の重要性**:
    - データ形式の統一性を保証
    - ID生成ロジックの正常動作を保証（日付文字列から YYYYMMDD を抽出）
    - フロントエンドとバックエンドのデータ形式の一致を保証
- **入力値**:
  ```typescript
  {
    date: "2025/01/24",  // スラッシュ区切り（誤り）
    battleType: "ランクマッチ",
    rank: "ダイアモンド",
    group: "AAA",
    myDeckId: "deck_001",
    turn: "先攻",
    result: "勝ち",
    opponentDeckId: "deck_master_002"
  }
  ```
  - **不正な理由**: API入力は `YYYY-MM-DD` 形式のみ許可（requirements.md Lines 103-111）
  - **実際の発生シナリオ**:
    - フロントエンドの日付フォーマットミス
    - 手動でリクエストを構築した場合のフォーマット誤り
    - 国際化対応の不備（地域によって異なる日付形式）
- **期待される結果**:
  - ZodError がスローされる
  - エラーメッセージ: `"日付はYYYY-MM-DD形式で入力してください"`
  - **エラーメッセージの内容**: 正しいフォーマットを明示（NFR-202）
  - **システムの安全性**: 不正な形式の日付は保存されない
- **テストの目的**: 日付形式バリデーションの動作確認（requirements.md Lines 588-623）
  - **品質保証の観点**: データ形式の統一性を保証し、ID生成やソート処理で不具合が発生しないようにする
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 588-623 より）

---

#### TC-105: myDeckId が空文字列の場合にバリデーションエラー

- **テスト名**: myDeckId が空文字列の場合、バリデーションエラーが発生する
  - **エラーケースの概要**: 文字列型のフィールドが空文字列で送信されるケース
  - **エラー処理の重要性**:
    - データ完全性の保証（空文字列は無効なデッキID）
    - 外部キー制約のような論理的整合性を保証
    - 統計計算でのデッキ別集計の正確性を保証
- **入力値**:
  ```typescript
  {
    date: "2025-01-24",
    battleType: "ランクマッチ",
    rank: "ダイアモンド",
    group: "AAA",
    myDeckId: "",  // 空文字列
    turn: "先攻",
    result: "勝ち",
    opponentDeckId: "deck_master_002"
  }
  ```
  - **不正な理由**: myDeckId は `.min(1)` 制約により、空文字列は不可（requirements.md Lines 128-131）
  - **実際の発生シナリオ**:
    - フロントエンドのバリデーション漏れ
    - ユーザーがセレクトボックスで何も選択せずに送信
    - APIの誤用
- **期待される結果**:
  - ZodError がスローされる
  - エラーメッセージ: `"マイデッキIDは必須です"`
  - **エラーメッセージの内容**: 空文字列が無効であることを明示
  - **システムの安全性**: 空文字列のデッキIDは保存されない
- **テストの目的**: 文字列型フィールドの空文字列バリデーション（requirements.md Lines 128-131）
  - **品質保証の観点**: デッキIDの完全性を保証し、外部結合や統計計算で不具合が発生しないようにする
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 128-131 より）

---

#### TC-106: opponentDeckId が空文字列の場合にバリデーションエラー

- **テスト名**: opponentDeckId が空文字列の場合、バリデーションエラーが発生する
  - **エラーケースの概要**: TC-105と同様に、相手デッキIDが空文字列のケース
  - **エラー処理の重要性**: TC-105と同様
- **入力値**:
  ```typescript
  {
    date: "2025-01-24",
    battleType: "ランクマッチ",
    rank: "ダイアモンド",
    group: "AAA",
    myDeckId: "deck_001",
    turn: "先攻",
    result: "勝ち",
    opponentDeckId: ""  // 空文字列
  }
  ```
  - **不正な理由**: opponentDeckId は `.min(1)` 制約により、空文字列は不可（requirements.md Lines 143-146）
  - **実際の発生シナリオ**: TC-105と同様
- **期待される結果**:
  - ZodError がスローされる
  - エラーメッセージ: `"相手デッキIDは必須です"`
  - **エラーメッセージの内容**: 空文字列が無効であることを明示
  - **システムの安全性**: 空文字列のデッキIDは保存されない
- **テストの目的**: 文字列型フィールドの空文字列バリデーション（requirements.md Lines 143-146）
  - **品質保証の観点**: TC-105と同様
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 143-146 より）

---

#### TC-107: Blob Storage読み込みエラー時に例外がスロー

- **テスト名**: getBattleLogs() が失敗した場合、エラーがスローされる
  - **エラーケースの概要**: Blob Storage接続エラー、タイムアウト、ネットワーク障害等
  - **エラー処理の重要性**:
    - インフラ障害時の適切なエラーハンドリング
    - ユーザーへのフィードバック（500エラー）
    - リトライ処理の動作確認（BlobStorageClientで3回リトライ）
- **入力値**:
  - **前提条件**: BlobStorageClient.getBattleLogs() がエラーをスローする環境（モック）
  - **入力データ**: 正常なリクエストボディ
  - **不正な理由**: Blob Storage側の障害（インフラレイヤーのエラー）
  - **実際の発生シナリオ**:
    - Azure Blob Storage の一時的な障害
    - ネットワークの切断
    - 接続文字列の設定ミス
    - コンテナが削除された
- **期待される結果**:
  - BattleLogService.createBattleLog() がエラーをスロー
  - エラーメッセージ: `"Failed to read battle-logs.json after 3 attempts: [元のエラー]"` (BlobStorageClientのリトライ後)
  - **エラーメッセージの内容**: リトライ回数とエラー詳細を含む
  - **システムの安全性**: エラーはAzure Functionsハンドラーでキャッチされ、500エラーとして返される
- **テストの目的**: Blob Storage障害時のエラーハンドリング確認（EDGE-001, EDGE-002）
  - **品質保証の観点**: インフラ障害に対する耐障害性を保証し、適切なエラーメッセージをユーザーに提供
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 625-647、tasks/shadowverse-battle-log-phase2.md Lines 436-454 より）

---

#### TC-108: Blob Storage書き込みエラー時に例外がスロー

- **テスト名**: saveBattleLogs() が失敗した場合、エラーがスローされる
  - **エラーケースの概要**: TC-107と同様に、Blob Storage書き込み時のエラー
  - **エラー処理の重要性**:
    - データ保存失敗時の適切なエラーハンドリング
    - データ損失の防止（トランザクション的な動作）
    - ユーザーへのフィードバック（500エラー）
- **入力値**:
  - **前提条件**: BlobStorageClient.saveBattleLogs() がエラーをスローする環境（モック）
  - **入力データ**: 正常なリクエストボディ
  - **不正な理由**: Blob Storage側の障害（書き込み権限不足、ストレージ容量不足等）
  - **実際の発生シナリオ**:
    - Azure Blob Storage の一時的な障害
    - 書き込み権限の不足（SAS tokenの期限切れ）
    - ストレージ容量の不足
    - ネットワークの切断
- **期待される結果**:
  - BattleLogService.createBattleLog() がエラーをスロー
  - エラーメッセージ: `"Failed to write battle-logs.json after 3 attempts: [元のエラー]"` (BlobStorageClientのリトライ後)
  - **エラーメッセージの内容**: リトライ回数とエラー詳細を含む
  - **システムの安全性**:
    - エラーはAzure Functionsハンドラーでキャッチされ、500エラーとして返される
    - データの不整合は発生しない（既存ログは変更されない）
- **テストの目的**: Blob Storage障害時のエラーハンドリング確認（EDGE-001, EDGE-002）
  - **品質保証の観点**: データ保存失敗時の適切なエラーハンドリングを保証し、データ損失を防ぐ
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 625-647、tasks/shadowverse-battle-log-phase2.md Lines 436-454 より）

---

### 2.3 境界値テストケース（最小値、最大値、null等）

#### TC-201: 空配列の既存ログで初回登録

- **テスト名**: battle-logs.json が空配列の場合、ID = log_YYYYMMDD_001 が生成される（TC-005と重複）
  - **境界値の意味**: データ件数の最小値（0件）
  - **境界値での動作保証**: 空データでもエラーにならず、正しくID=001が生成される
- **入力値**: TC-005と同じ
- **期待される結果**: TC-005と同じ
- **テストの目的**: 最小データ量での動作確認
  - **堅牢性の確認**: 空配列が正しく処理される
- 🔵 **信頼性レベル**: 青信号（TC-005を参照）

**注**: TC-201はTC-005と実質的に同じテストケースのため、TC-005に統合されています。

---

#### TC-202: 同日の連番が999に達した場合の動作

- **テスト名**: 同日の連番が999に達した場合、1000として生成される（4桁になる）
  - **境界値の意味**: 連番の最大値（3桁の上限999）
  - **境界値での動作保証**: 999を超えても正常に動作する（4桁になる）
- **入力値**:
  - **前提条件**: 既存ログに `log_20250124_999` が存在
  - **新規登録データ**: 正常なリクエストボディ（date: "2025-01-24"）
  - **境界値選択の根拠**: ID生成ロジックが3桁ゼロパディング（`.padStart(3, '0')`）を使用しているため、999を超えた場合の動作を確認
  - **実際の使用場面**: 1日に1000件以上の対戦履歴を記録するケース（現実的には稀だが、システムの堅牢性を保証）
- **期待される結果**:
  ```typescript
  {
    id: "log_20250124_1000",  // 999 + 1 = 1000（4桁）
    // 他のフィールドは省略
  }
  ```
  - **境界での正確性**: `.padStart(3, '0')` は既に3桁以上の文字列に対しては何もしないため、"1000"がそのまま使用される
  - **一貫した動作**: 3桁から4桁への遷移が自然に行われる
- **テストの目的**: ID生成ロジックの桁数オーバーフロー確認
  - **堅牢性の確認**: 極端な使用状況でもシステムが正常に動作する
- 🟡 **信頼性レベル**: 黄信号（ID生成ロジックの実装（tasks/shadowverse-battle-log-phase2.md Lines 116-147）からの妥当な推測）

---

#### TC-203: 日付が2000-01-01（過去の境界値）の場合

- **テスト名**: date = "2000-01-01" のような過去の日付が正常に処理される
  - **境界値の意味**: 過去の日付の現実的な下限値
  - **境界値での動作保証**: 過去の日付でも正常に動作する
- **入力値**:
  ```typescript
  {
    date: "2000-01-01",
    battleType: "ランクマッチ",
    rank: "ダイアモンド",
    group: "AAA",
    myDeckId: "deck_001",
    turn: "先攻",
    result: "勝ち",
    opponentDeckId: "deck_master_002"
  }
  ```
  - **境界値選択の根拠**: Y2K問題以降の日付として2000年を選択（現実的な下限値）
  - **実際の使用場面**: 過去の対戦履歴を遡って記録するケース（現実的には稀）
- **期待される結果**:
  ```typescript
  {
    id: "log_20000101_001",
    date: "2000/01/01",
    // 他のフィールドは省略
  }
  ```
  - **境界での正確性**: 過去の日付でも正しくID生成と保存が行われる
  - **一貫した動作**: 未来日付チェック（今日より大きいかどうか）が正しく動作する
- **テストの目的**: 過去日付の下限値での動作確認
  - **堅牢性の確認**: 過去の日付でもシステムが正常に動作する
- 🟡 **信頼性レベル**: 黄信号（未来日付チェック（requirements.md Lines 103-111）からの妥当な推測）

---

#### TC-204: 日付が今日の場合（境界値）

- **テスト名**: date = 今日の日付の場合、正常に処理される（未来日付エラーにならない）
  - **境界値の意味**: 未来日付チェックの境界値（今日 = 未来ではない）
  - **境界値での動作保証**: 今日の日付は未来日付ではないため、バリデーションをパスする
- **入力値**:
  ```typescript
  {
    date: "2025-10-29",  // テスト実行日が2025-10-29の場合
    battleType: "ランクマッチ",
    rank: "ダイアモンド",
    group: "AAA",
    myDeckId: "deck_001",
    turn: "先攻",
    result: "勝ち",
    opponentDeckId: "deck_master_002"
  }
  ```
  - **境界値選択の根拠**: 未来日付チェックのロジック（`inputDate > today`）で、今日が境界値となる
  - **実際の使用場面**: 対戦直後に今日の日付を明示的に入力するケース
- **期待される結果**:
  - バリデーションが成功する
  - 正常にBattleLogが作成される
  - **境界での正確性**: 今日の日付が未来日付として拒否されない
  - **一貫した動作**: `today.setHours(23, 59, 59, 999)` により、今日の23:59:59までは未来ではない
- **テストの目的**: 未来日付チェックの境界値確認
  - **堅牢性の確認**: 境界値での判定ロジックが正確に動作する
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 103-111、tasks/shadowverse-battle-log-phase2.md Lines 73-79 より）

---

#### TC-205: リクエストボディが空オブジェクト {} の場合

- **テスト名**: リクエストボディが空オブジェクト {} の場合、複数フィールドのバリデーションエラーが発生する
  - **境界値の意味**: リクエストデータの最小値（何も入力されていない状態）
  - **境界値での動作保証**: すべての必須項目でバリデーションエラーが発生する
- **入力値**:
  ```typescript
  {}  // 空オブジェクト
  ```
  - **境界値選択の根拠**: 最小限のリクエストデータ（フィールドが一つもない状態）
  - **実際の使用場面**:
    - フロントエンドのバグ（送信前のデータが未設定）
    - APIの誤用（空のPOSTリクエスト）
- **期待される結果**:
  - ZodError がスローされる
  - 複数フィールドでエラー:
    - `battleType`: "Required"
    - `rank`: "Required"
    - `group`: "Required"
    - `myDeckId`: "マイデッキIDは必須です"
    - `turn`: "Required"
    - `result`: "Required"
    - `opponentDeckId`: "相手デッキIDは必須です"
  - `date` フィールドはデフォルト値が設定されるため、エラーにならない
  - **境界での正確性**: すべての必須項目が正しく検出される
  - **一貫した動作**: デフォルト値を持つフィールドとそうでないフィールドの動作が一貫している
- **テストの目的**: 最小リクエストデータでのバリデーション動作確認
  - **堅牢性の確認**: 空リクエストでも適切なエラーメッセージが返される
- 🔵 **信頼性レベル**: 青信号（requirements.md Lines 514-549、tasks/shadowverse-battle-log-phase2.md Lines 82-111 より）

---

### 2.4 統合テストケース（Azure Functions エンドポイント）

#### TC-301: POST /api/battle-logs エンドポイントが正常に動作する

- **テスト名**: Azure Functions エンドポイント POST /api/battle-logs が正常にリクエストを処理し、201レスポンスを返す
  - **何をテストするか**: Azure Functionsハンドラーが正しく実装され、BattleLogServiceと連携してレスポンスを返すことを確認
  - **期待される動作**:
    - リクエストボディがパースされる
    - BattleLogService.createBattleLog() が呼び出される
    - 201 Created レスポンスが返される
    - レスポンスボディが ApiResponse<{battleLog}> 形式である
- **入力値**:
  - **HTTPリクエスト**:
    - メソッド: POST
    - パス: /api/battle-logs
    - ボディ:
      ```json
      {
        "date": "2025-01-24",
        "battleType": "ランクマッチ",
        "rank": "ダイアモンド",
        "group": "AAA",
        "myDeckId": "deck_001",
        "turn": "先攻",
        "result": "勝ち",
        "opponentDeckId": "deck_master_002"
      }
      ```
  - **入力データの意味**: 実際のHTTPリクエストを模擬したテストデータ
- **期待される結果**:
  ```typescript
  {
    status: 201,
    jsonBody: {
      success: true,
      data: {
        battleLog: {
          id: "log_20250124_001",
          date: "2025/01/24",
          battleType: "ランクマッチ",
          rank: "ダイアモンド",
          group: "AAA",
          myDeckId: "deck_001",
          turn: "先攻",
          result: "勝ち",
          opponentDeckId: "deck_master_002"
        }
      },
      meta: {
        timestamp: expect.any(String),  // ISO 8601形式
        requestId: expect.any(String)   // Azure Functions invocation ID
      }
    }
  }
  ```
  - **期待結果の理由**:
    - status: 201 Created（リソース作成成功）
    - ApiResponse型に準拠したレスポンス形式（types/index.ts Lines 98-110）
    - IDが正しく生成されている
- **テストの目的**: Azure Functionsエンドポイントの統合動作確認
  - **確認ポイント**:
    - リクエストパースが正しく動作する
    - BattleLogServiceとの連携が正しく動作する
    - レスポンス形式が正しい
    - HTTPステータスコードが正しい
- 🔵 **信頼性レベル**: 青信号（tasks/shadowverse-battle-log-phase2.md Lines 193-270、Lines 463-492 より）

---

#### TC-302: バリデーションエラー時に400レスポンスを返す

- **テスト名**: バリデーションエラーが発生した場合、400 Bad Request レスポンスを返す
  - **何をテストするか**: Azure Functionsハンドラーが ZodError を正しくキャッチし、400エラーレスポンスを返すことを確認
  - **期待される動作**:
    - ZodError がスローされる
    - エラーハンドラーがキャッチする
    - 400 Bad Request レスポンスが返される
    - エラー詳細がレスポンスボディに含まれる
- **入力値**:
  - **HTTPリクエスト**:
    - メソッド: POST
    - パス: /api/battle-logs
    - ボディ:
      ```json
      {
        "date": "2099-12-31",
        "battleType": "ランクマッチ",
        "rank": "ダイアモンド",
        "group": "AAA",
        "myDeckId": "deck_001",
        "turn": "先攻",
        "result": "勝ち",
        "opponentDeckId": "deck_master_002"
      }
      ```
  - **入力データの意味**: 未来日付によるバリデーションエラーを引き起こすリクエスト
- **期待される結果**:
  ```typescript
  {
    status: 400,
    jsonBody: {
      success: false,
      error: {
        code: "VALIDATION_ERROR",
        message: "入力値が不正です",
        details: {
          "date": "未来の日付は入力できません"
        }
      },
      meta: {
        timestamp: expect.any(String),
        requestId: expect.any(String)
      }
    }
  }
  ```
  - **期待結果の理由**:
    - status: 400 Bad Request（クライアント側のエラー）
    - ApiResponse型に準拠したエラーレスポンス形式
    - エラー詳細がフィールド名とメッセージのマップとして返される
- **テストの目的**: バリデーションエラー時のエラーハンドリング確認
  - **確認ポイント**:
    - ZodErrorが正しくキャッチされる
    - エラーメッセージが正しくマッピングされる
    - HTTPステータスコードが400である
- 🔵 **信頼性レベル**: 青信号（tasks/shadowverse-battle-log-phase2.md Lines 232-250 より）

---

#### TC-303: Blob Storageエラー時に500レスポンスを返す

- **テスト名**: Blob Storage接続エラーが発生した場合、500 Internal Server Error レスポンスを返す
  - **何をテストするか**: Azure Functionsハンドラーが予期しないエラー（Blob Storageエラー等）を正しくキャッチし、500エラーレスポンスを返すことを確認
  - **期待される動作**:
    - BattleLogService.createBattleLog() がエラーをスロー
    - エラーハンドラーがキャッチする
    - 500 Internal Server Error レスポンスが返される
    - エラー詳細は含まれない（セキュリティ上、内部エラーは隠蔽）
- **入力値**:
  - **HTTPリクエスト**: 正常なリクエストボディ
  - **前提条件**: BlobStorageClient.getBattleLogs() がエラーをスローする環境（モック）
  - **入力データの意味**: Blob Storage障害によるサーバーエラーを引き起こすリクエスト
- **期待される結果**:
  ```typescript
  {
    status: 500,
    jsonBody: {
      success: false,
      error: {
        code: "INTERNAL_SERVER_ERROR",
        message: "サーバーエラーが発生しました"
      },
      meta: {
        timestamp: expect.any(String),
        requestId: expect.any(String)
      }
    }
  }
  ```
  - **期待結果の理由**:
    - status: 500 Internal Server Error（サーバー側のエラー）
    - ApiResponse型に準拠したエラーレスポンス形式
    - エラー詳細は含まれない（セキュリティ上、内部エラーの詳細は隠蔽）
- **テストの目的**: Blob Storageエラー時のエラーハンドリング確認
  - **確認ポイント**:
    - 予期しないエラーが正しくキャッチされる
    - HTTPステータスコードが500である
    - エラー詳細が隠蔽される
- 🔵 **信頼性レベル**: 青信号（tasks/shadowverse-battle-log-phase2.md Lines 253-267 より）

---

### 2.5 ユーティリティ関数のテストケース

#### TC-401: generateBattleLogId() が正しくIDを生成する（既存ログなし）

- **テスト名**: generateBattleLogId() 関数が、既存ログが空の場合に log_YYYYMMDD_001 を生成する
  - **何をテストするか**: ID生成関数が正しくIDフォーマットを生成できることを確認
  - **期待される動作**:
    - 日付文字列（YYYY-MM-DD）をYYYYMMDDに変換
    - 既存ログが空の場合、連番001を生成
- **入力値**:
  - `existingLogs`: `[]` (空配列)
  - `date`: `"2025-01-24"`
  - **入力データの意味**: 初回登録時のID生成
- **期待される結果**:
  - 戻り値: `"log_20250124_001"`
  - **期待結果の理由**: ID形式の正確性を保証
- **テストの目的**: ID生成関数の基本動作確認
  - **確認ポイント**:
    - 日付形式変換が正しい
    - 連番が001で始まる
    - ID形式が正しい
- 🔵 **信頼性レベル**: 青信号（tasks/shadowverse-battle-log-phase2.md Lines 116-147 より）

---

#### TC-402: generateBattleLogId() が正しくIDを生成する（既存ログあり）

- **テスト名**: generateBattleLogId() 関数が、既存ログがある場合に最大連番+1を生成する
  - **何をテストするか**: ID生成関数が既存ログから最大連番を取得し、+1する動作を確認
  - **期待される動作**:
    - 既存ログをフィルタリング（同日のみ）
    - 最大連番を取得
    - 最大連番+1を3桁ゼロパディング
- **入力値**:
  - `existingLogs`:
    ```typescript
    [
      { id: "log_20250124_001", date: "2025/01/24", ... },
      { id: "log_20250124_002", date: "2025/01/24", ... }
    ]
    ```
  - `date`: `"2025-01-24"`
  - **入力データの意味**: 同日に既存ログがある場合のID生成
- **期待される結果**:
  - 戻り値: `"log_20250124_003"`
  - **期待結果の理由**: 既存の最大連番002 + 1 = 003
- **テストの目的**: ID生成関数の連番インクリメント動作確認
  - **確認ポイント**:
    - 同日のログが正しくフィルタリングされる
    - 最大連番が正しく取得される（002）
    - 新規連番が003として生成される
- 🔵 **信頼性レベル**: 青信号（tasks/shadowverse-battle-log-phase2.md Lines 116-147 より）

---

#### TC-403: generateBattleLogId() が異なる日付のログを無視する

- **テスト名**: generateBattleLogId() 関数が、異なる日付のログを無視して連番を生成する
  - **何をテストするか**: ID生成関数が同日のログのみをフィルタリングし、他の日付のログを無視することを確認
  - **期待される動作**:
    - 既存ログから同日のログのみをフィルタリング
    - 他の日付のログは無視
    - 同日の最大連番のみを取得
- **入力値**:
  - `existingLogs`:
    ```typescript
    [
      { id: "log_20250123_001", date: "2025/01/23", ... },  // 前日
      { id: "log_20250123_005", date: "2025/01/23", ... },  // 前日
      { id: "log_20250124_001", date: "2025/01/24", ... },  // 当日
      { id: "log_20250125_010", date: "2025/01/25", ... }   // 翌日
    ]
    ```
  - `date`: `"2025-01-24"`
  - **入力データの意味**: 複数日のログがある場合、当日のログのみを考慮してID生成
- **期待される結果**:
  - 戻り値: `"log_20250124_002"`
  - **期待結果の理由**:
    - 前日の005、翌日の010は無視される
    - 当日の最大連番001 + 1 = 002
- **テストの目的**: ID生成関数の日付フィルタリング動作確認
  - **確認ポイント**:
    - 同日のログのみがフィルタリングされる
    - 他の日付のログが無視される
    - 正しい連番が生成される
- 🔵 **信頼性レベル**: 青信号（tasks/shadowverse-battle-log-phase2.md Lines 127-133 より）

---

#### TC-404: isFutureDate() が未来日付を正しく検出する

- **テスト名**: isFutureDate() 関数が未来の日付を正しく検出する
  - **何をテストするか**: 未来日付チェック関数が正しく動作することを確認
  - **期待される動作**:
    - 入力日付が今日より大きい場合、trueを返す
    - 入力日付が今日以下の場合、falseを返す
- **入力値**:
  - **パターン1**: `"2099-12-31"` (未来日付)
  - **パターン2**: `"2025-10-29"` (今日の日付、テスト実行日が2025-10-29の場合)
  - **パターン3**: `"2025-10-28"` (過去日付)
  - **入力データの意味**: 未来日付チェックの各境界値
- **期待される結果**:
  - **パターン1**: `true` (未来日付)
  - **パターン2**: `false` (今日は未来ではない)
  - **パターン3**: `false` (過去日付)
  - **期待結果の理由**: 未来日付チェックの正確性を保証
- **テストの目的**: 未来日付チェック関数の動作確認
  - **確認ポイント**:
    - 未来日付が正しく検出される
    - 今日の日付が未来ではないと判定される
    - 過去日付が未来ではないと判定される
- 🔵 **信頼性レベル**: 青信号（tasks/shadowverse-battle-log-phase2.md Lines 73-79 より）

---

## 3. テストケース実装時の日本語コメント指針

### テストケース開始時のコメント

```typescript
// 【テスト目的】: [このテストで何を確認するかを日本語で明記]
// 【テスト内容】: [具体的にどのような処理をテストするかを説明]
// 【期待される動作】: [正常に動作した場合の結果を説明]
// 🔵🟡🔴 [信頼性レベル]
```

### Given（準備フェーズ）のコメント

```typescript
// 【テストデータ準備】: [なぜこのデータを用意するかの理由]
// 【初期条件設定】: [テスト実行前の状態を説明]
// 【前提条件確認】: [テスト実行に必要な前提条件を明記]
```

### When（実行フェーズ）のコメント

```typescript
// 【実際の処理実行】: [どの機能/メソッドを呼び出すかを説明]
// 【処理内容】: [実行される処理の内容を日本語で説明]
// 【実行タイミング】: [なぜこのタイミングで実行するかを説明]
```

### Then（検証フェーズ）のコメント

```typescript
// 【結果検証】: [何を検証するかを具体的に説明]
// 【期待値確認】: [期待される結果とその理由を説明]
// 【品質保証】: [この検証がシステム品質にどう貢献するかを説明]
```

### 各expectステートメントのコメント

```typescript
// 【検証項目】: [この検証で確認している具体的な項目]
// 🔵🟡🔴 [信頼性レベル]
expect(result.id).toBe("log_20250124_001"); // 【確認内容】: IDが正しく生成されることを確認
expect(result.date).toBe("2025/01/24"); // 【確認内容】: 日付形式が YYYY/MM/DD に変換されることを確認
```

### セットアップ・クリーンアップのコメント

```typescript
beforeEach(() => {
  // 【テスト前準備】: [各テスト実行前に行う準備作業の説明]
  // 【環境初期化】: [テスト環境をクリーンな状態にする理由と方法]
});

afterEach(() => {
  // 【テスト後処理】: [各テスト実行後に行うクリーンアップ作業の説明]
  // 【状態復元】: [次のテストに影響しないよう状態を復元する理由]
});
```

---

## 4. テストカバレッジ目標

### カバレッジ基準

- **関数カバレッジ**: 100%（jest.config.js Line 13より）
- **行カバレッジ**: 90%以上（jest.config.js Line 14より）
- **分岐カバレッジ**: 85%以上（jest.config.js Line 12より）
- **ステートメントカバレッジ**: 90%以上（jest.config.js Line 15より）

### カバレッジ対象

- `src/services/battleLogService.ts`
- `src/utils/validation.ts`
- `src/utils/idGenerator.ts`
- `src/functions/battle-logs.ts`

### カバレッジ除外

- `src/types/index.ts` (型定義のみ、jest.config.js Line 7より)

---

## 5. モック戦略

### BlobStorageClient のモック

```typescript
jest.mock('../../src/storage/blobStorageClient');

beforeEach(() => {
  mockBlobClient = new BlobStorageClient('', '') as jest.Mocked<BlobStorageClient>;
  mockBlobClient.getBattleLogs.mockResolvedValue([]);
  mockBlobClient.saveBattleLogs.mockResolvedValue();
});
```

- **モックの理由**:
  - BlobStorageClientはTASK-0006で実装済み
  - 単体テストではBlob Storageへの実際のアクセスは不要
  - テストの高速化と独立性の確保

### Azure Functions Context のモック

```typescript
const context = {
  invocationId: 'test-invocation-id',
  error: jest.fn(),
} as any;
```

- **モックの理由**:
  - Azure Functions Contextは実行環境依存
  - テストではinvocationIdとerrorメソッドのみ必要

---

## 6. テストデータ

### 正常系テストデータ

```typescript
const validBattleLogInput = {
  date: "2025-01-24",
  battleType: "ランクマッチ" as const,
  rank: "ダイアモンド" as const,
  group: "AAA" as const,
  myDeckId: "deck_001",
  turn: "先攻" as const,
  result: "勝ち" as const,
  opponentDeckId: "deck_master_002",
};
```

### 異常系テストデータ

```typescript
// 未来日付
const futureDateInput = { ...validBattleLogInput, date: "2099-12-31" };

// 不正なenum値
const invalidEnumInput = { ...validBattleLogInput, battleType: "不正なタイプ" };

// 必須項目欠落
const missingFieldsInput = { date: "2025-01-24", battleType: "ランクマッチ" };

// 空文字列
const emptyStringInput = { ...validBattleLogInput, myDeckId: "" };
```

---

## 7. 品質判定

### ✅ 高品質: 実装可能

- **テストケース分類**: 正常系（6ケース）、異常系（8ケース）、境界値（5ケース）、統合テスト（3ケース）、ユーティリティ（4ケース）の合計26ケースで網羅されている
- **期待値定義**: 各テストケースの期待値が明確に定義され、理由も明記されている
- **技術選択**: TypeScript + Jest + ts-jest が確定しており、既存プロジェクトとの整合性が高い
- **実装可能性**:
  - モック戦略が明確
  - テストデータが準備されている
  - 既存のテストパターン（TASK-0006）を踏襲している
  - カバレッジ目標が具体的

### 信頼性レベルサマリー

- 🔵 **青信号** (ほぼ推測なし): 85%以上
  - 正常系テストケース（6ケース）
  - 異常系テストケース（8ケース）
  - 境界値テストケース（3ケース）
  - 統合テストケース（3ケース）
  - ユーティリティテストケース（4ケース）
- 🟡 **黄信号** (妥当な推測): 15%
  - TC-202（連番999の次が1000になる）
  - TC-203（過去日付の下限値）
- 🔴 **赤信号** (推測): 0%

---

## 8. 次のステップ

✅ **テストケース洗い出し完了**

次のお勧めステップ: `/tsumiki:tdd-red` でRedフェーズ（失敗テスト作成）を開始します。

**完了条件（再掲）**:

- [ ] 正常系テストケース（6ケース以上）が定義されている
- [ ] 異常系テストケース（8ケース以上）が定義されている
- [ ] 境界値テストケース（5ケース以上）が定義されている
- [ ] 統合テストケース（3ケース以上）が定義されている
- [ ] ユーティリティテストケース（4ケース以上）が定義されている
- [ ] 各テストケースに期待値が明確に定義されている
- [ ] テストフレームワーク（Jest + ts-jest）が確定している
- [ ] モック戦略が明確に定義されている
- [ ] カバレッジ目標が設定されている
- [ ] テストデータが準備されている

---

**作成日**: 2025-10-29
**更新日**: 2025-10-29
**ステータス**: ✅ 完了
